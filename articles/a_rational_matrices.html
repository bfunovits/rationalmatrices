<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Rational Matrices • rationalmatrices</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Rational Matrices">
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">rationalmatrices</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.3.3</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/a_rational_matrices.html">Rational Matrices</a></li>
    <li><a class="dropdown-item" href="../articles/b_technical_details_ratm.html">Rational Matrices: Technical Details</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../claude.html">Claude Guide</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/bfunovits/rationalmatrices/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">



<link href="a_rational_matrices_files/htmltools-fill-0.5.9/fill.css" rel="stylesheet">
<script src="a_rational_matrices_files/htmlwidgets-1.6.4/htmlwidgets.js"></script><script src="a_rational_matrices_files/viz-1.8.2/viz.js"></script><link href="a_rational_matrices_files/DiagrammeR-styles-0.2/styles.css" rel="stylesheet">
<script src="a_rational_matrices_files/grViz-binding-1.0.11/grViz.js"></script><div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Rational Matrices</h1>
                        <h4 data-toc-skip class="author">Wolfgang
Scherrer and Bernd Funovits</h4>
            
            <h4 data-toc-skip class="date">2026-01-18</h4>
      

      <div class="d-none name"><code>a_rational_matrices.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<div class="section level3">
<h3 id="what-are-rational-matrices">What are Rational Matrices?<a class="anchor" aria-label="anchor" href="#what-are-rational-matrices"></a>
</h3>
<p>The <code>rationalmatrices</code> package handles <strong>rational
matrices</strong> - matrices whose entries are rational functions of the
lag-operator
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>
(typically
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>z</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><annotation encoding="application/x-tex">z^{-1}</annotation></semantics></math>
in control theory applications).</p>
<p>A rational function can be represented in many equivalent forms:</p>
<ul>
<li>
<strong>Polynomial</strong>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mi>z</mi><mo>+</mo><mi>⋯</mi><mo>+</mo><msub><mi>a</mi><mi>p</mi></msub><msup><mi>z</mi><mi>p</mi></msup></mrow><annotation encoding="application/x-tex">a(z) = a_0 + a_1 z + \cdots + a_p z^p</annotation></semantics></math>
</li>
<li>
<strong>Matrix fractions</strong>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>b</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">a^{-1}(z)b(z)</annotation></semantics></math>
(left LMFD) or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><msup><mi>c</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">d(z)c^{-1}(z)</annotation></semantics></math>
(right RMFD)</li>
<li>
<strong>State-space</strong>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>z</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>I</mi><mo>−</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>B</mi><mo>+</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">C(z^{-1}I - A)^{-1}B + D</annotation></semantics></math>
(standard in control theory)</li>
<li>
<strong>Impulse response</strong>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>0</mn></msub><mo>+</mo><msub><mi>h</mi><mn>1</mn></msub><mi>z</mi><mo>+</mo><msub><mi>h</mi><mn>2</mn></msub><msup><mi>z</mi><mn>2</mn></msup><mo>+</mo><mi>⋯</mi></mrow><annotation encoding="application/x-tex">h_0 + h_1 z + h_2 z^{2} + \cdots</annotation></semantics></math>
(time-domain)</li>
<li>
<strong>Frequency response</strong>: function values on the unit
circle</li>
</ul>
</div>
<div class="section level3">
<h3 id="design-philosophy">Design Philosophy<a class="anchor" aria-label="anchor" href="#design-philosophy"></a>
</h3>
<p>The main goal is to implement classes for rational matrices such that
they behave similarly to ordinary matrices. <strong>Arithmetic
operations should look and feel like standard matrix
manipulation</strong>, while seamlessly converting between the most
appropriate representation for each task.</p>
<p>This package serves as the foundation for <code>RLDM</code> (Rational
Linear Dynamic Models) and is particularly useful for:</p>
<ul>
<li>Linear dynamic time series models (VARMA, state-space)</li>
<li>Control theory and system analysis</li>
<li>Signal processing and filtering</li>
<li>Any application requiring multiple mathematical representations of
the same object</li>
</ul>
</div>
<div class="section level3">
<h3 id="guide-to-this-vignette">Guide to This Vignette<a class="anchor" aria-label="anchor" href="#guide-to-this-vignette"></a>
</h3>
<p>This vignette covers the main user-facing functionality. For
implementation details and mathematical theory, see the companion
vignette “Technical Details”.</p>
<p><strong>Main sections:</strong></p>
<ul>
<li>
<strong>Classes</strong> → Representation Management (#1 in
CLAUDE.md)</li>
<li>
<strong>Operations and Methods</strong> → Arithmetic Operations
(#3), Polynomial Manipulation (#4), Analysis (#5)</li>
<li>
<strong>Realization Algorithms</strong> → Realization Algorithms
(#2)</li>
<li>
<strong>Methods for Polynomials</strong> → Polynomial Manipulation
(#4)</li>
<li>
<strong>Methods for State-Space Forms</strong> → State-Space Tools
(#6)</li>
</ul>
<p>Quick start examples follow below:</p>
<hr>
<p>We start with some basic examples. First we create a scalar
polynomial
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>1</mn><mo>+</mo><mn>0.9</mn><mi>z</mi><mo>+</mo><mn>0.9</mn><msup><mi>z</mi><mn>2</mn></msup><mo>+</mo><msup><mn>0.9</mn><mn>3</mn></msup><msup><mi>z</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">a(z)=1+0.9z+0.9z^2+0.9^3z^3</annotation></semantics></math>,
check that the object is “valid” and print it:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">=</span> <span class="fu"><a href="../reference/polm.html">polm</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">0.9</span>,<span class="fl">0.9</span><span class="op">^</span><span class="fl">2</span>,<span class="fl">0.9</span><span class="op">^</span><span class="fl">3</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/is.html">is.polm</a></span><span class="op">(</span><span class="va">a</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">a</span>, format <span class="op">=</span> <span class="st">'c'</span><span class="op">)</span></span>
<span><span class="co">#&gt; ( 1 x 1 ) matrix polynomial with degree &lt;= 3 </span></span>
<span><span class="co">#&gt;                                [,1]</span></span>
<span><span class="co">#&gt; [1,]  1 + 0.9z + 0.81z^2 + 0.729z^3</span></span></code></pre></div>
<p>Create a scalar rational matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>a</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>b</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">c(z) = a^{-1}(z) b(z)</annotation></semantics></math>
in LMFD form, check that the object is valid and print it:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">c</span> <span class="op">=</span> <span class="fu"><a href="../reference/lmfd.html">lmfd</a></span><span class="op">(</span><span class="va">a</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">0.8</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/is.html">is.lmfd</a></span><span class="op">(</span><span class="va">c</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">c</span><span class="op">)</span></span>
<span><span class="co">#&gt; ( 1 x 1 ) left matrix fraction description a^(-1)(z) b(z) with degrees (p = 3, q = 2)</span></span>
<span><span class="co">#&gt; left factor a(z):</span></span>
<span><span class="co">#&gt;      z^0 [,1] z^1 [,1] z^2 [,1] z^3 [,1]</span></span>
<span><span class="co">#&gt; [1,]        1      0.9     0.81    0.729</span></span>
<span><span class="co">#&gt; right factor b(z):</span></span>
<span><span class="co">#&gt;      z^0 [,1] z^1 [,1] z^2 [,1]</span></span>
<span><span class="co">#&gt; [1,]        1        0     0.64</span></span></code></pre></div>
<p>Compute poles and zeroes of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>⋅</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">c(\cdot)</annotation></semantics></math></p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/poles_and_zeroes.html">poles</a></span><span class="op">(</span><span class="va">c</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] -1.713307e-16-1.111111i -1.713307e-16+1.111111i -1.111111e+00+0.000000i</span></span>
<span><span class="fu"><a href="../reference/poles_and_zeroes.html">zeroes</a></span><span class="op">(</span><span class="va">c</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0-1.25i 0+1.25i</span></span></code></pre></div>
<p>Evaluate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>b</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">a(z), b(z), c(z)</annotation></semantics></math>
on the unit circle and check that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><msup><mi>a</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>b</mi></mrow><annotation encoding="application/x-tex">c=a^{-1}b</annotation></semantics></math>:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## evaluate</span></span>
<span><span class="va">af</span> <span class="op">=</span> <span class="fu"><a href="../reference/zvalues.html">zvalues</a></span><span class="op">(</span><span class="va">c</span><span class="op">$</span><span class="va">a</span>, n.f <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span>
<span><span class="va">bf</span> <span class="op">=</span> <span class="fu"><a href="../reference/zvalues.html">zvalues</a></span><span class="op">(</span><span class="va">c</span><span class="op">$</span><span class="va">b</span>, n.f <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span>
<span><span class="va">cf</span> <span class="op">=</span> <span class="fu"><a href="../reference/zvalues.html">zvalues</a></span><span class="op">(</span><span class="va">c</span>, n.f <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="va">cf</span>, <span class="va">af</span><span class="op">^</span><span class="op">(</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span> <span class="op"><a href="../reference/ratm_mult.html">%r%</a></span> <span class="va">bf</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">cf</span>, format <span class="op">=</span> <span class="st">'iz|j'</span>, digits <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="co">#&gt; ( 1 x 1 ) frequency response</span></span>
<span><span class="co">#&gt;                            [,1]</span></span>
<span><span class="co">#&gt;          z=1+0i [1,] 0.48+0.00i</span></span>
<span><span class="co">#&gt;  z=0.809-0.588i [1,] 0.47+0.19i</span></span>
<span><span class="co">#&gt;  z=0.309-0.951i [1,] 0.44+0.52i</span></span>
<span><span class="co">#&gt; z=-0.309-0.951i [1,] 0.77+0.52i</span></span>
<span><span class="co">#&gt; z=-0.809-0.588i [1,] 0.81+1.31i</span></span>
<span><span class="co">#&gt;         z=-1+0i [1,] 9.06+0.00i</span></span>
<span><span class="co">#&gt; z=-0.809+0.588i [1,] 0.81-1.31i</span></span>
<span><span class="co">#&gt; z=-0.309+0.951i [1,] 0.77-0.52i</span></span>
<span><span class="co">#&gt;  z=0.309+0.951i [1,] 0.44-0.52i</span></span>
<span><span class="co">#&gt;  z=0.809+0.588i [1,] 0.47-0.19i</span></span></code></pre></div>
<p>Produce a “Nyquist” plot, where the imaginary part is plotted versus
the real part. In order to get a “nice, smooth” path, we evaluate the
rational function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">c(z)</annotation></semantics></math>
on a grid of 1024 points on the unit circle:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="fu"><a href="../reference/zvalues.html">zvalues</a></span><span class="op">(</span><span class="va">c</span>, n.f <span class="op">=</span> <span class="fl">1024</span><span class="op">)</span>, which <span class="op">=</span> <span class="st">'nyquist'</span><span class="op">)</span></span></code></pre></div>
<p><img src="a_rational_matrices_files/figure-html/unnamed-chunk-5-1.png" class="r-plt" alt="Nyquist plot of rational function c(z) showing imaginary versus real part on unit circle" width="700"></p>
</div>
</div>
<div class="section level2">
<h2 id="classes-section">Classes<a class="anchor" aria-label="anchor" href="#classes-section"></a>
</h2>
<div class="section level3">
<h3 id="overview-of-representations">Overview of Representations<a class="anchor" aria-label="anchor" href="#overview-of-representations"></a>
</h3>
<p>There are seven major representations (realizations) for rational
matrices, each suited to different tasks:</p>
<ol style="list-style-type: decimal">
<li>
<strong>Polynomial matrices</strong> (<code>polm</code>) - Direct
coefficient representation</li>
<li>
<strong>Laurent polynomials</strong> (<code>lpolm</code>) - Allows
negative powers</li>
<li>
<strong>Left matrix fraction</strong> (<code>lmfd</code>) - For
analysis: a⁻¹(z)b(z)</li>
<li>
<strong>Right matrix fraction</strong> (<code>rmfd</code>) -
Transpose dual: d(z)c⁻¹(z)</li>
<li>
<strong>State-space</strong> (<code>stsp</code>) - For computation:
C(z⁻¹I-A)⁻¹B+D</li>
<li>
<strong>Power series</strong> (<code>pseries</code>) - Impulse
response coefficients</li>
<li>
<strong>Frequency response</strong> (<code>zvalues</code>) - Values
at specific z points</li>
</ol>
<p>The package enables seamless conversion between all these forms.
Furthermore, the coefficients of the power series expansion (here called
<em>impulse response function</em>) and a sufficiently rich set of
values of the rational matrix (here called <em>frequency response
function</em>) uniquely determine the rational matrix and hence may be
seen as another way to represent such a rational matrix.</p>
<p>Note: There are no separate classes for rational <em>scalars</em> or
rational <em>vectors</em>. A scalar is simply a (1×1) matrix and a
vector is a (m×1) or (1×n) matrix.</p>
</div>
<div class="section level3">
<h3 id="representation-conversion-diagram">Representation Conversion Diagram<a class="anchor" aria-label="anchor" href="#representation-conversion-diagram"></a>
</h3>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Keep original diagram for reference - can be displayed if needed</span></span>
<span><span class="fu">DiagrammeR</span><span class="fu">::</span><span class="fu"><a href="https://rich-iannone.github.io/DiagrammeR/reference/grViz.html" class="external-link">grViz</a></span><span class="op">(</span><span class="st">"</span></span>
<span><span class="st">  digraph G {</span></span>
<span><span class="st">    compound=true;</span></span>
<span><span class="st">    splines = lines;</span></span>
<span><span class="st">    graph [layout = dot, rankdir = LR]</span></span>
<span><span class="st">    splines = lines</span></span>
<span><span class="st">    ra [label='polm():\nPolynomial']</span></span>
<span><span class="st">    ra -&gt; rb;</span></span>
<span><span class="st">    ra -&gt; rc;</span></span>
<span><span class="st">    subgraph cluster_repr {</span></span>
<span><span class="st">      label = 'Matrix Fraction &amp; State-Space'</span></span>
<span><span class="st">      fontsize = 14</span></span>
<span><span class="st">      rb [label='lmfd():\nLeft Fraction\na⁻¹(z)b(z)']</span></span>
<span><span class="st">      rc [label='rmfd():\nRight Fraction\nd(z)c⁻¹(z)']</span></span>
<span><span class="st">      rd [label = 'stsp():\nState-Space\nC(z⁻¹I-A)⁻¹B+D']</span></span>
<span><span class="st">      {rank=same; rb,rc,rd}</span></span>
<span><span class="st">    }</span></span>
<span><span class="st">    subgraph cluster_pseries {</span></span>
<span><span class="st">      label = 'Impulse &amp; Frequency Response'</span></span>
<span><span class="st">      pa [label = 'pseries():\nPower Series']</span></span>
<span><span class="st">      pz [label = 'zvalues():\nFunction Values']</span></span>
<span><span class="st">    }</span></span>
<span><span class="st">    ha [label = 'Hankel Matrix\n(Rank Analysis)' ]</span></span>
<span><span class="st">    pa -&gt; ha[label = 'via lags']</span></span>
<span><span class="st">    ha -&gt; rb [label = 'Left\nEchelon', color = 'red']</span></span>
<span><span class="st">    ha -&gt; rd [label = 'Balanced\nRealization', color = 'red']</span></span>
<span><span class="st">    rb -&gt; pa [label = 'Extract', color = 'blue']</span></span>
<span><span class="st">    rd -&gt; pa [label = 'Extract', color = 'blue']</span></span>
<span><span class="st">  }"</span><span class="op">)</span></span></code></pre></div>
<div class="grViz html-widget html-fill-item" id="htmlwidget-ac96cb3ee4656e2e9ec3" style="width:700px;height:432.632880098888px;"></div>
<script type="application/json" data-for="htmlwidget-ac96cb3ee4656e2e9ec3">{"x":{"diagram":"\n  digraph G {\n    compound=true;\n    splines = lines;\n    graph [layout = dot, rankdir = LR]\n    splines = lines\n    ra [label=\"polm():\nPolynomial\"]\n    ra -> rb;\n    ra -> rc;\n    subgraph cluster_repr {\n      label = \"Matrix Fraction & State-Space\"\n      fontsize = 14\n      rb [label=\"lmfd():\nLeft Fraction\na⁻¹(z)b(z)\"]\n      rc [label=\"rmfd():\nRight Fraction\nd(z)c⁻¹(z)\"]\n      rd [label = \"stsp():\nState-Space\nC(z⁻¹I-A)⁻¹B+D\"]\n      {rank=same; rb,rc,rd}\n    }\n    subgraph cluster_pseries {\n      label = \"Impulse & Frequency Response\"\n      pa [label = \"pseries():\nPower Series\"]\n      pz [label = \"zvalues():\nFunction Values\"]\n    }\n    ha [label = \"Hankel Matrix\n(Rank Analysis)\" ]\n    pa -> ha[label = \"via lags\"]\n    ha -> rb [label = \"Left\nEchelon\", color = \"red\"]\n    ha -> rd [label = \"Balanced\nRealization\", color = \"red\"]\n    rb -> pa [label = \"Extract\", color = \"blue\"]\n    rd -> pa [label = \"Extract\", color = \"blue\"]\n  }","config":{"engine":"dot","options":null}},"evals":[],"jsHooks":[]}</script><p>The color scheme:</p>
<ul>
<li>
<strong>Red</strong>: Realization from Hankel matrix (impulse
response)</li>
<li>
<strong>Blue</strong>: Power series extraction from
fractions/state-space</li>
</ul>
<p>Here, we focus on polynomial matrices and rational matrices
represented by a <em>left matrix fraction description</em> or by a
<em>statespace realization</em>.</p>
</div>
<div class="section level3">
<h3 id="polynomial-matrices">Polynomial Matrices<a class="anchor" aria-label="anchor" href="#polynomial-matrices"></a>
</h3>
<p>Polynomial matrices</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mi>z</mi><mo>+</mo><mi>⋯</mi><mo>+</mo><msub><mi>a</mi><mi>p</mi></msub><msup><mi>z</mi><mi>p</mi></msup><mo>,</mo><mspace width="0.278em"></mspace><msub><mi>a</mi><mi>i</mi></msub><mo>∈</mo><msup><mi>ℝ</mi><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow></msup><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> or </mtext><mspace width="0.333em"></mspace></mrow><msub><mi>a</mi><mi>i</mi></msub><mo>∈</mo><msup><mi>ℂ</mi><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">
a(z) = a_0 + a_1 z + \cdots + a_p z^p,\; a_i\in \mathbb{R}^{m\times n} \mbox{ or } a_i \in \mathbb{C}^{m\times n}
</annotation></semantics></math> are represented by objects of class
<code>polm</code>. Such a <code>polm</code> object is simply an
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>,</mo><mi>n</mi><mo>,</mo><mi>p</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(m,n,p+1)</annotation></semantics></math>-dimensional
array which stores the coefficients
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mi>i</mi></msub><annotation encoding="application/x-tex">a_i</annotation></semantics></math>
together with a class attribute <code>c('polm','ratm')</code>.</p>
<p><strong>Note:</strong> We allow for <em>complex</em> coefficients,
<em>empty</em> polynomials
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">m=0</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n=0</annotation></semantics></math>)
and <em>zero</em> polynomials
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a(z)=0</annotation></semantics></math>
for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>∈</mo><mi>ℂ</mi></mrow><annotation encoding="application/x-tex">z\in \mathbb{C}</annotation></semantics></math>).
Zero polynomials may be represented by an
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>,</mo><mi>n</mi><mo>,</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(m,n,0)</annotation></semantics></math>-dimensional
array, i.e. the degree
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>
is equal to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p=-1</annotation></semantics></math>.</p>
<p>The constructor for polynomial matrices is <code><a href="../reference/polm.html">polm()</a></code>. For
testing purposes one may use <code><a href="../reference/test_polm.html">test_polm()</a></code> to create (random)
polynomial matrices.</p>
</div>
<div class="section level3">
<h3 id="left-matrix-fraction-description">Left Matrix Fraction Description<a class="anchor" aria-label="anchor" href="#left-matrix-fraction-description"></a>
</h3>
<p>Any rational
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(m \times n)</annotation></semantics></math>
matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">c(z)</annotation></semantics></math>
may be represented as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>a</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>b</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">c(z) = a^{-1}(z) b(z)</annotation></semantics></math>,
where</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mi>z</mi><mo>+</mo><mi>⋯</mi><mo>+</mo><msub><mi>a</mi><mi>p</mi></msub><msup><mi>z</mi><mi>p</mi></msup></mrow><annotation encoding="application/x-tex">
a(z)  = a_0 + a_1 z + \cdots + a_p z^p
</annotation></semantics></math> is an
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>×</mo><mi>m</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(m \times m)</annotation></semantics></math>
(non singular) polynomial matrix of degree
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>,
and</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>b</mi><mn>0</mn></msub><mo>+</mo><msub><mi>b</mi><mn>1</mn></msub><mi>z</mi><mo>+</mo><mi>⋯</mi><mo>+</mo><msub><mi>b</mi><mi>q</mi></msub><msup><mi>z</mi><mi>q</mi></msup></mrow><annotation encoding="application/x-tex">
b(z) = b_0 + b_1 z + \cdots + b_q z^q
</annotation></semantics></math> is an
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(m \times n)</annotation></semantics></math>
dimensional matrix polynomial of degree
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>.</p>
<p>The matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">c(z)</annotation></semantics></math>
is thus described by the pair
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>b</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a(z), b(z))</annotation></semantics></math>.
Note that the “factors”
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>b</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">a(z), b(z)</annotation></semantics></math>
are by no means unique for given
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">c(z)</annotation></semantics></math>.</p>
<p>Internally such LMFDs are stored as a matrix</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>a</mi><mn>0</mn></msub><mo>,</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>a</mi><mi>p</mi></msub><mo>,</mo><msub><mi>b</mi><mn>0</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>b</mi><mi>q</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>∈</mo><msup><mi>ℝ</mi><mrow><mi>m</mi><mo>×</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>p</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>q</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msup></mrow><annotation encoding="application/x-tex">
[a_0,a_1,\ldots,a_p,b_0,\ldots,b_q] \in \mathbb{R}^{m \times (m(p+1)+n(q+1))}
</annotation></semantics></math> with an attribute
<code>order = c(m,n,p,q)</code> and a class attribute
<code>c('lmfd','ratm')</code>.</p>
<p><strong>Note:</strong> We demand
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">m&gt;0</annotation></semantics></math>,
since it is not clear how to interpret the inverse of an
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>×</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(0 \times 0)</annotation></semantics></math>-dimensional
matrix. Since
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">a(z)</annotation></semantics></math>
is non singular,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">p\geq 0</annotation></semantics></math>
must hold.</p>
<p>The constructor for <code>lmfd</code> objects is <code><a href="../reference/lmfd.html">lmfd()</a></code>.
For testing purposes one may use <code><a href="../reference/test_lmfd.html">test_lmfd()</a></code> to create
(random) rational matrices in LMFD form.</p>
</div>
<div class="section level3">
<h3 id="statespace-representation">Statespace Representation<a class="anchor" aria-label="anchor" href="#statespace-representation"></a>
</h3>
<p>Any rational
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(m \times n)</annotation></semantics></math>-dimensional)
matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">c(z)</annotation></semantics></math>
which has no pole at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">z=0</annotation></semantics></math>
may be represented as</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>C</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>z</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>I</mi><mi>s</mi></msub><mo>−</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>B</mi><mo>+</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">
c(z) = C(z^{-1}I_s - A)^{-1}B + D
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∈</mo><msup><mi>ℝ</mi><mrow><mi>s</mi><mo>×</mo><mi>s</mi></mrow></msup></mrow><annotation encoding="application/x-tex">A\in \mathbb{R}^{s\times s}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>∈</mo><msup><mi>ℝ</mi><mrow><mi>s</mi><mo>×</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">B\in \mathbb{R}^{s\times n}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>∈</mo><msup><mi>ℝ</mi><mrow><mi>m</mi><mo>×</mo><mi>s</mi></mrow></msup></mrow><annotation encoding="application/x-tex">C\in \mathbb{R}^{m\times s}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo>∈</mo><msup><mi>ℝ</mi><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">D\in \mathbb{R}^{m\times n}</annotation></semantics></math>.</p>
<p>The integer
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>
is called the <em>state dimension</em> of the above realization.
Statespace representations are by no means unique, even the state
dimension
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>
is not unique. If the state dimension
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>
is minimal among all possible realizations of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">c(z)</annotation></semantics></math>
then the representation is called <em>minimal</em>.</p>
<p>Internally, statespace realizations are stored as a matrix</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>A</mi></mtd><mtd columnalign="center" style="text-align: center"><mi>B</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>C</mi></mtd><mtd columnalign="center" style="text-align: center"><mi>D</mi></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo>∈</mo><msup><mi>ℝ</mi><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo>+</mo><mi>m</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>×</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo>+</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msup></mrow><annotation encoding="application/x-tex">
\begin{bmatrix}
A &amp; B \\
C &amp; D
\end{bmatrix} \in \mathbb{R}^{(s+m) \times (s+n)}
</annotation></semantics></math> with an attribute
<code>order = c(m,n,s)</code> and a class attribute
<code>c('stsp','ratm')</code>.</p>
<p><strong>Notes</strong>:</p>
<ul>
<li>E.g. the elementary rational function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>z</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">c(z)=z^{-1}</annotation></semantics></math>
does <em>not</em> have a statespace realization of the above form.<br>
</li>
<li>Any of the integers
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>,</mo><mi>n</mi><mo>,</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">m,n,s</annotation></semantics></math>
may be zero.</li>
<li>Many (algebraic) operations are very easy to implement in terms of
statespace representations. Therefore, the package is somewhat “biased”
towards statespace representations.</li>
</ul>
<p>The constructor for <code>stsp</code> objects is <code><a href="../reference/stsp.html">stsp()</a></code>.
For testing purposes one may use <code><a href="../reference/test_stsp.html">test_stsp()</a></code> to create
(random) rational matrices in statespace form.</p>
</div>
<div class="section level3">
<h3 id="power-series">Power Series<a class="anchor" aria-label="anchor" href="#power-series"></a>
</h3>
<p>Impulse response function or transfer function are also used for the
same object.</p>
<p>If the rational matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">c(z)</annotation></semantics></math>
has no pole at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">z=0</annotation></semantics></math>,
then there exists a power series expansion</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>k</mi><mn>0</mn></msub><mo>+</mo><msub><mi>k</mi><mn>1</mn></msub><msup><mi>z</mi><mn>1</mn></msup><mo>+</mo><msub><mi>k</mi><mn>2</mn></msub><msup><mi>z</mi><mn>2</mn></msup><mo>+</mo><mi>⋯</mi></mrow><annotation encoding="application/x-tex">
c(z) = k_0 + k_1 z^1 + k_2 z^2 + \cdots
</annotation></semantics></math> which converges in a (non-empty) circle
around
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">z=0</annotation></semantics></math>.
The sequence of coefficients
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>k</mi><mi>j</mi></msub><mspace width="0.167em"></mspace><mo stretchy="false" form="prefix">|</mo><mspace width="0.167em"></mspace><mi>j</mi><mo>≥</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(k_j \,|\, j \geq 0)</annotation></semantics></math>
here is called <em>impulse response function</em><a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content="&lt;p&gt;This naming is chosen in regard to the connection
between rational matrices and VARMA processes and processes represented
by statespace models.&lt;/p&gt;"><sup>1</sup></a>.</p>
<p>An <code>pseries</code> object stores a finite sequence
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>k</mi><mn>0</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>k</mi><mi>l</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(k_0,\ldots,k_l)</annotation></semantics></math>
as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>,</mo><mi>n</mi><mo>,</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(m,n,(l+1))</annotation></semantics></math>
dimensional array with a class attribute
<code>c('stsp','ratm')</code>.</p>
<p><strong>Note:</strong> Due to the rational structure, a
<em>finite</em> sequence of coefficients is sufficient to reconstruct
the rational matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">c(z)</annotation></semantics></math>,
see e.g. the Ho-Kalman realization algorithm <span class="citation">(Ho
and Kalman 1966)</span> implemented in <code>pseries2stsp</code> and the
function <code>pseries2lmfd</code>. (Of course the number of
coefficients has to be large enough.) Hence, we can interpret (a finite)
impulse response function as another way to represent rational
matrices.</p>
</div>
<div class="section level3">
<h3 id="frequency-response">Frequency Response<a class="anchor" aria-label="anchor" href="#frequency-response"></a>
</h3>
<p>A rational matrix is also uniquely determined by a (finite) set of
function values. An object of class <code>zvalues</code> is an
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>,</mo><mi>n</mi><mo>,</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(m,n,k)</annotation></semantics></math>
dimensional array (which stores the values
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>z</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">c(z_j)</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">j=1,\ldots,k</annotation></semantics></math>
together with an attribute <code>z</code> (which is a vector with
components
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>z</mi><mi>j</mi></msub><annotation encoding="application/x-tex">z_j</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">j=1,\ldots,k</annotation></semantics></math>)
and a class attribute <code>c('freqressp','ratm')</code>.</p>
<p>If the rational matrix represents the transfer function of a
(rational) filter, then often the matrix is evaluated at a grid of
points on the unit circle</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>j</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mi>k</mi><mo>,</mo><mspace width="2.0em"></mspace><msub><mi>z</mi><mi>j</mi></msub><mo>=</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mo>−</mo><mi>i</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mi>π</mi><msub><mi>f</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="2.0em"></mspace><mi>j</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">
f_j = (j-1)/k,\qquad z_j = \exp(-i(2\pi  f_j)),\qquad j=1,\ldots,k
</annotation></semantics></math></p>
<p><strong>Notes</strong>:</p>
<ul>
<li>As stated above the rational function is uniquely determined from a
finite (but sufficiently rich) set of values. However, we have not
implemented an algorithm which computes an “LMFD” or “statespace”
representation for given frequency response.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="operations-section">Operations and Methods<a class="anchor" aria-label="anchor" href="#operations-section"></a>
</h2>
<p>This section covers the main functional areas: - <strong>General
Methods</strong> - Representation Management (#1) - <strong>Convert from
Class x to Class y</strong> - Realization Algorithms (#2) -
<strong>Arithmetics</strong> - Arithmetic Operations (#3) -
<strong>Poles and Zeroes</strong> - Analysis &amp; Properties (#5)</p>
<div class="section level3">
<h3 id="general-methods">General Methods<a class="anchor" aria-label="anchor" href="#general-methods"></a>
</h3>
<ul>
<li>
<code>is.polm(x)</code>, <code>is.lmfd(x)</code>,
<code>is.stsp(x)</code>, <code>is.pseries(x)</code>,
<code>is.zvalues(x)</code> test whether the object <code>x</code> is a
valid (rational matrix) object.</li>
<li>
<code>dim(x)</code> returns a (named) vector with the dimensions of
the rational matrix object.</li>
<li>The <code>str</code> methods produces a one-line description of
rational matrix objects.</li>
<li>The <code>print</code> methods tries to produce a compact display of
the rational matrix object.</li>
<li>
<code>plot</code> methods are implemented for <code>pseries</code>
and <code>zvalues</code> objects.</li>
</ul>
</div>
<div class="section level3">
<h3 id="convert-from-class-x-to-class-y">Convert from Class <code>x</code> to Class <code>y</code><a class="anchor" aria-label="anchor" href="#convert-from-class-x-to-class-y"></a>
</h3>
<p>An essential goal of the package is to provide tools, which allow a
simple conversion of one representation (realization) to another.</p>
<p>The following table gives an overview of these “conversion”
procedures:</p>
<p><img src="a_rational_matrices_files/figure-html/unnamed-chunk-7-1.png" class="r-plt" alt="Table showing rational matrix representation classes and their conversions" width="768"></p>
<p>The colors of the cells mean</p>
<ul>
<li>orange-red: does not make sense (in general)</li>
<li>light-steel-blue: use a two step procure, e.g
<code>as.lmfd(pseries(x, lag.max))</code>
</li>
<li>gold: not (yet) implemented</li>
</ul>
<p>The core procedures which compute an LMFD or statespace realization
for given impules reponse are described in the following subsection.
Some more information may be found in the vignette “technical
details”.</p>
<div class="section level4">
<h4 id="realization-algorithms">Realization Algorithms<a class="anchor" aria-label="anchor" href="#realization-algorithms"></a>
</h4>
<p>One of the characteristic features of rational functions is that the
Hankel matrix of the impulse response<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;Note that the impulse response function is only well
defined if the rational matrix has no pole at
&lt;math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding="application/x-tex"&gt;z=0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;.&lt;/p&gt;'><sup>2</sup></a> coefficients</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>k</mi><mn>1</mn></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>k</mi><mn>2</mn></msub></mtd><mtd columnalign="center" style="text-align: center"><mi>⋯</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>k</mi><mn>2</mn></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>k</mi><mn>3</mn></msub></mtd><mtd columnalign="center" style="text-align: center"><mi>⋯</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd><mtd columnalign="center" style="text-align: center"></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
H = \begin{pmatrix}
k_1 &amp; k_2 &amp; \cdots \\
k_2 &amp; k_3 &amp; \cdots \\
\vdots &amp; \vdots &amp;
\end{pmatrix}
</annotation></semantics></math> has <em>finite</em> rank.</p>
<p>If the rational matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">k(z)</annotation></semantics></math>
has an LMFD representation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>a</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>b</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">k(z)=a^{-1}(z)b(z)</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mi>z</mi><mo>+</mo><mi>⋯</mi><mo>+</mo><msub><mi>a</mi><mi>p</mi></msub><msup><mi>z</mi><mi>p</mi></msup></mrow><annotation encoding="application/x-tex">a(z)=a_0 + a_1 z + \cdots + a_p z^p</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>b</mi><mn>0</mn></msub><mo>+</mo><msub><mi>b</mi><mn>1</mn></msub><mi>z</mi><mo>+</mo><mi>⋯</mi><mo>+</mo><msub><mi>b</mi><mi>q</mi></msub><msup><mi>z</mi><mi>q</mi></msup></mrow><annotation encoding="application/x-tex">b(z)=b_0 + b_1 z + \cdots + b_q z^q</annotation></semantics></math>
then</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msub><mi>k</mi><mn>0</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>b</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>k</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">
a(z)(k(z)-k_0) = b(z) - a(z)k_0
</annotation></semantics></math> implies that</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><msub><mi>k</mi><mi>l</mi></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><msub><mi>k</mi><mrow><mi>l</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>⋯</mi><mo>+</mo><msub><mi>a</mi><mi>p</mi></msub><msub><mi>k</mi><mrow><mi>l</mi><mo>−</mo><mi>p</mi></mrow></msub><mo>=</mo><mn>0</mn><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> for </mtext><mspace width="0.333em"></mspace></mrow><mi>l</mi><mo>&gt;</mo><mo>max</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>p</mi><mo>,</mo><mi>q</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
a_0 k_l + a_1 k_{l-1} + \cdots + a_p k_{l-p} = 0 \mbox{ for } l&gt;\max(p,q)
</annotation></semantics></math></p>
<p>This implies that the Hankel matrix indeed has finite rank and
furthermore that we can construct the matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">a(z)</annotation></semantics></math>
from the left kernel of the Hankel matrix. For given
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">a()</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">k()</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">b(z)</annotation></semantics></math>
follows from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>k</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">b(z)=a(z)k(z)</annotation></semantics></math>.</p>
<p>In order to describe the linear dependence structure of the rows of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math>
it is convenient to use a “double” index for the rows: Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∈</mo><msup><mi>ℝ</mi><mrow><mn>1</mn><mo>×</mo><mi>∞</mi></mrow></msup></mrow><annotation encoding="application/x-tex">h(i,j)\in \mathbb{R}^{1\times \infty}</annotation></semantics></math>
denote the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>-th
row in the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>-th
block row of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math>,
i.e. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">h(i,j)</annotation></semantics></math>
is the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>m</mi><mo>+</mo><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">((i-1)m+j)</annotation></semantics></math>-th
row of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math>.</p>
<p>A selection
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒮</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>i</mi><mi>k</mi></msub><mo>,</mo><msub><mi>j</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><mo stretchy="false" form="prefix">|</mo><mspace width="0.167em"></mspace><mi>k</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>s</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\mathcal{S}=\{h(i_k,j_k) \,|\, k=1,\ldots ,s\}</annotation></semantics></math>
of rows of the Hankel matrix is called a <em>nice</em> selection, if
there are no “holes” in the sense that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∈</mo><mi>𝒮</mi></mrow><annotation encoding="application/x-tex">h(i,j)\in \mathcal{S}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i&gt;1</annotation></semantics></math>
implies that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∈</mo><mi>𝒮</mi></mrow><annotation encoding="application/x-tex">h(i-1,j)\in \mathcal{S}</annotation></semantics></math>.
Nice selections may be described by a multi-index
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ν</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ν</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>ν</mi><mi>m</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\nu = (\nu_1, \ldots, \nu_m)</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ν</mi><mi>j</mi></msub><mo>=</mo><mo>max</mo><mo stretchy="false" form="prefix">{</mo><mi>i</mi><mspace width="0.167em"></mspace><mo stretchy="false" form="prefix">|</mo><mspace width="0.167em"></mspace><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∈</mo><mi>𝒮</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\nu_j=\max \{i\,|\,h(i,j)\in \mathcal{S}\}</annotation></semantics></math>.</p>
<p>Suppose that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math>
has rank
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>.
In general there are many different selections of rows of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math>
which form a basis for the row space of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math>.
In the following we choose the <em>first</em>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>
rows of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math>
which form a basis of the row space and denote the corresponding
selection with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒮</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>i</mi><mi>k</mi></msub><mo>,</mo><msub><mi>j</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><mo stretchy="false" form="prefix">|</mo><mspace width="0.167em"></mspace><mi>k</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>s</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\mathcal{S}=\{h(i_k,j_k) \,|\, k=1,\ldots ,s\}</annotation></semantics></math>.
Due to the Hankel structure of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math>
this is a nice selection in the above sense. The corresponding
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ν</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\nu_j</annotation></semantics></math>’s
are called <em>Kronecker indices</em> of the Hankel matrix (respectively
of the rational matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>⋅</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">k(\cdot)</annotation></semantics></math>).
Note that the sum of the Kronecker indices is equal to the rank of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></msubsup><msub><mi>ν</mi><mi>j</mi></msub><mo>=</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">\sum_{j=1}^m \nu _j = s</annotation></semantics></math>.</p>
<p>For a given (nice) selection of basis rows, one may construct a
unique LMFD representation of the rational matrix. In particular, if we
choose the above described “canonical” basis then one obtains the so
called <em>echelon form</em> left matrix fraction description of the
rational matrix. This procedure is implemented in the tool
<code><a href="../reference/pseries2lmfd.html">pseries2lmfd()</a></code>. The <code>S3</code> method
<code><a href="../reference/as.lmfd.html">as.lmfd.pseries()</a></code> is just a wrapper function, which calls
<code><a href="../reference/pseries2lmfd.html">pseries2lmfd()</a></code> with some default parameters.</p>
<p>Quite analogously one may also construct a statespace realization of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>⋅</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">k(\cdot)</annotation></semantics></math>
with the <em>Ho-Kalman</em> algorithm. See the tools
<code><a href="../reference/pseries2stsp.html">pseries2stsp()</a></code> and <code><a href="../reference/as.stsp.html">as.stsp.pseries()</a></code>.</p>
<p>For a more detailed discussion on Kronecker indices and echelon
canonical forms, see <span class="citation">Hannan and Deistler
(2012)</span>.</p>
</div>
<div class="section level4">
<h4 id="examples">Examples<a class="anchor" aria-label="anchor" href="#examples"></a>
</h4>
<p>We first create a random
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mo>×</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(2 \times 2)</annotation></semantics></math>
rational matrix in statespace form with a state dimension
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">s=5</annotation></semantics></math>.
Generically the first
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>
rows of the Hankel matrix form a basis and hence the Kronecker indices
are
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ν</mi><mn>1</mn></msub><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">\nu_1 = 3</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ν</mi><mn>2</mn></msub><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\nu_2=2</annotation></semantics></math>:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># create a random rational matrix in statespace form</span></span>
<span><span class="va">X</span> <span class="op">=</span> <span class="fu"><a href="../reference/test_stsp.html">test_stsp</a></span><span class="op">(</span>dim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span>, s <span class="op">=</span> <span class="fl">5</span>, digits <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="va">X</span></span>
<span><span class="co">#&gt; statespace realization [2,2] with s = 5 states</span></span>
<span><span class="co">#&gt;       s[1]  s[2]  s[3]  s[4]  s[5]  u[1]  u[2]</span></span>
<span><span class="co">#&gt; s[1] -1.40 -0.25  0.51  0.36 -0.83 -0.13  0.07</span></span>
<span><span class="co">#&gt; s[2]  0.26 -0.24 -1.86 -1.30 -1.51 -1.91 -0.64</span></span>
<span><span class="co">#&gt; s[3] -2.44 -0.28 -0.52  0.74  0.94 -0.28 -0.05</span></span>
<span><span class="co">#&gt; s[4] -0.01 -0.55 -0.05  1.89  0.18 -0.31 -0.25</span></span>
<span><span class="co">#&gt; s[5]  0.62  0.63  0.54 -0.10  0.24  1.07  0.44</span></span>
<span><span class="co">#&gt; x[1]  1.15  2.07 -0.91 -0.94  1.62  1.00  0.00</span></span>
<span><span class="co">#&gt; x[2] -1.82 -1.63  0.47 -0.02  0.11  0.00  1.00</span></span>
<span></span>
<span><span class="co"># compute the impulse response function,</span></span>
<span><span class="co"># the Kornecker indices and the corresponding indices of the "basis" rows.</span></span>
<span><span class="va">K</span> <span class="op">=</span> <span class="fu"><a href="../reference/pseries.html">pseries</a></span><span class="op">(</span><span class="va">X</span>, lag.max <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span>
<span><span class="va">nu</span> <span class="op">=</span> <span class="fu"><a href="../reference/Kronecker-Indices.html">pseries2nu</a></span><span class="op">(</span><span class="va">K</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="st">'Kronecker indices: '</span>, <span class="va">nu</span>,<span class="st">'\n'</span>,</span>
<span>    <span class="st">'      basis rows: '</span>, <span class="fu"><a href="../reference/Kronecker-Indices.html">nu2basis</a></span><span class="op">(</span><span class="va">nu</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; Kronecker indices:  3 2 </span></span>
<span><span class="co">#&gt;        basis rows:  1 2 3 4 5</span></span></code></pre></div>
<p>Next we take the impulse response function and compute a statespace
realization of this rational matrix in echelon form:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">X</span> <span class="op">=</span> <span class="fu"><a href="../reference/pseries2stsp.html">pseries2stsp</a></span><span class="op">(</span><span class="va">K</span>, method <span class="op">=</span> <span class="st">'echelon'</span><span class="op">)</span><span class="op">$</span><span class="va">Xs</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">X</span>, digits <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="co">#&gt; statespace realization [2,2] with s = 5 states</span></span>
<span><span class="co">#&gt;       s[1]  s[2]  s[3]  s[4] s[5]  u[1]  u[2]</span></span>
<span><span class="co">#&gt; s[1]  0.00  0.00  1.00  0.00 0.00 -1.82 -0.25</span></span>
<span><span class="co">#&gt; s[2]  0.00  0.00  0.00  1.00 0.00  3.34  0.95</span></span>
<span><span class="co">#&gt; s[3]  0.00  0.00  0.00  0.00 1.00 -5.21 -1.25</span></span>
<span><span class="co">#&gt; s[4] -0.95 -5.48 -4.19 -1.43 1.43  2.01  0.98</span></span>
<span><span class="co">#&gt; s[5]  1.74  2.58  1.75  2.52 1.40 -2.51 -0.07</span></span>
<span><span class="co">#&gt; x[1]  1.00  0.00  0.00  0.00 0.00  1.00  0.00</span></span>
<span><span class="co">#&gt; x[2]  0.00  1.00  0.00  0.00 0.00  0.00  1.00</span></span>
<span></span>
<span><span class="co"># check the result</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="fu"><a href="../reference/pseries.html">pseries</a></span><span class="op">(</span><span class="va">X</span>, lag.max <span class="op">=</span> <span class="fl">10</span><span class="op">)</span>, <span class="va">K</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<p>We may also create a rational matrix with prescribed Kronecker
indices. Here we generate a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>3</mn><mo>×</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(3\times 2)</annotation></semantics></math>
matrix with Kronecker indices
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ν</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\nu =(2,3,1)</annotation></semantics></math>
and in addition we demand that the matrix is stable. i.e. the matrix no
poles inside the unit circle:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">nu</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">3</span>,<span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">X</span> <span class="op">=</span> <span class="fu"><a href="../reference/test_stsp.html">test_stsp</a></span><span class="op">(</span>dim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">3</span>,<span class="fl">2</span><span class="op">)</span>, nu <span class="op">=</span> <span class="va">nu</span>, D <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="cn">NA</span>,<span class="cn">NA</span>, <span class="fl">0</span>, <span class="fl">1</span>, <span class="cn">NA</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">3</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span>,</span>
<span>              digits <span class="op">=</span> <span class="fl">2</span>, bpoles <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">X</span></span>
<span><span class="co">#&gt; statespace realization [3,2] with s = 6 states</span></span>
<span><span class="co">#&gt;       s[1]  s[2] s[3]  s[4]  s[5] s[6]  u[1]  u[2]</span></span>
<span><span class="co">#&gt; s[1]  0.00  0.00 0.00  1.00  0.00 0.00 -0.27  0.47</span></span>
<span><span class="co">#&gt; s[2]  0.00  0.00 0.00  0.00  1.00 0.00 -0.37  0.13</span></span>
<span><span class="co">#&gt; s[3]  0.59 -0.21 0.41 -0.04 -0.32 0.00 -0.38 -0.13</span></span>
<span><span class="co">#&gt; s[4] -0.15 -0.33 0.31  0.38  0.42 0.00 -0.13 -0.04</span></span>
<span><span class="co">#&gt; s[5]  0.00  0.00 0.00  0.00  0.00 1.00  0.44  0.01</span></span>
<span><span class="co">#&gt; s[6]  0.70 -0.13 0.70 -0.66 -0.07 0.07  0.16  0.15</span></span>
<span><span class="co">#&gt; x[1]  1.00  0.00 0.00  0.00  0.00 0.00  1.00  0.00</span></span>
<span><span class="co">#&gt; x[2]  0.00  1.00 0.00  0.00  0.00 0.00 -0.18  1.00</span></span>
<span><span class="co">#&gt; x[3]  0.00  0.00 1.00  0.00  0.00 0.00 -0.05  0.01</span></span>
<span></span>
<span><span class="co"># compute impulse response</span></span>
<span><span class="va">K</span> <span class="op">=</span> <span class="fu"><a href="../reference/pseries.html">pseries</a></span><span class="op">(</span><span class="va">X</span>, lag.max <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span>
<span><span class="co"># and check the Kronecker indices</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="fu"><a href="../reference/Kronecker-Indices.html">pseries2nu</a></span><span class="op">(</span><span class="va">K</span><span class="op">)</span>, <span class="va">nu</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<p>An LMFD realization of this matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
is obtained a s follows</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">X</span> <span class="op">=</span> <span class="fu"><a href="../reference/pseries2lmfd.html">pseries2lmfd</a></span><span class="op">(</span><span class="va">K</span><span class="op">)</span><span class="op">$</span><span class="va">Xl</span></span>
<span><span class="va">X</span></span>
<span><span class="co">#&gt; ( 3 x 2 ) left matrix fraction description a^(-1)(z) b(z) with degrees (p = 3, q = 3)</span></span>
<span><span class="co">#&gt; left factor a(z):</span></span>
<span><span class="co">#&gt;      z^0 [,1]  [,2]  [,3] z^1 [,1]  [,2]  [,3] z^2 [,1]  [,2]  [,3] z^3 [,1]</span></span>
<span><span class="co">#&gt; [1,]     1.00  0.00     0    -0.38 -0.42  0.00     0.15  0.33 -0.31      0.0</span></span>
<span><span class="co">#&gt; [2,]     0.00  1.00     0     0.00 -0.07  0.00     0.66  0.07  0.00     -0.7</span></span>
<span><span class="co">#&gt; [3,]     0.04  0.32     1    -0.59  0.21 -0.41     0.00  0.00  0.00      0.0</span></span>
<span><span class="co">#&gt;       [,2]  [,3]</span></span>
<span><span class="co">#&gt; [1,]  0.00   0.0</span></span>
<span><span class="co">#&gt; [2,]  0.13  -0.7</span></span>
<span><span class="co">#&gt; [3,]  0.00   0.0</span></span>
<span><span class="co">#&gt; right factor b(z):</span></span>
<span><span class="co">#&gt;      z^0 [,1]  [,2] z^1 [,1]   [,2] z^2 [,1]   [,2] z^3 [,1]   [,2]</span></span>
<span><span class="co">#&gt; [1,]   1.0000  0.00  -0.5744 0.0500   0.2341 0.0537   0.0000 0.0000</span></span>
<span><span class="co">#&gt; [2,]  -0.1800  1.00  -0.3574 0.0600   1.1133 0.0709  -0.7633 0.5916</span></span>
<span><span class="co">#&gt; [3,]  -0.0676  0.33  -1.1165 0.1363   0.0000 0.0000   0.0000 0.0000</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="fu"><a href="../reference/pseries.html">pseries</a></span><span class="op">(</span><span class="va">X</span>, lag.max <span class="op">=</span> <span class="fl">10</span><span class="op">)</span>, <span class="va">K</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<p>The set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>5</mn><mo>,</mo><mn>6</mn><mo>,</mo><mn>7</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(1,2,3,5,6,7)</annotation></semantics></math>
does <em>not</em> correspond to a nice selection of rows of a Hankel
matrix (with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">m=3</annotation></semantics></math>).
The corresponding set of rows (using the above described “double
indices”) is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒮</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>3</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mo>,</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>3</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\mathcal{S}=\{h(1,1),h(1,2),h(1,3),h(2,2),h(2,3),h(3,1)\}</annotation></semantics></math>.
The set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒮</mi><annotation encoding="application/x-tex">\mathcal{S}</annotation></semantics></math>
contains the row
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>3</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">h(3,1)</annotation></semantics></math>
but not the row
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">h(2,1)</annotation></semantics></math>
and hence it is not a nice selection. Therefore the function
<code>basis2nu</code> throws an error, if we try to compute the
correponding Kronecker indices:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">basis</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">3</span>,<span class="fl">5</span>,<span class="fl">6</span>,<span class="fl">7</span><span class="op">)</span></span>
<span><span class="va">nu</span> <span class="op">=</span> <span class="kw"><a href="https://rdrr.io/r/base/try.html" class="external-link">try</a></span><span class="op">(</span><span class="fu"><a href="../reference/Kronecker-Indices.html">basis2nu</a></span><span class="op">(</span><span class="va">basis</span>, m<span class="op">=</span> <span class="fl">3</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; Error in basis2nu(basis, m = 3) : </span></span>
<span><span class="co">#&gt;   This is not a nice basis, i.e. there are holes.</span></span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="arithmetics">Arithmetics<a class="anchor" aria-label="anchor" href="#arithmetics"></a>
</h3>
<p>The group method function <code><a href="../reference/Ops.ratm.html">Ops.ratm()</a></code> allows to perform
arithmetic operations on rational matrices using ordinary arithmetic
operators.</p>
<div class="section level4 unnumbered">
<h4 class="unnumbered" id="the-unary-operators-a-and--a">The Unary Operators <code>+a</code> and
<code>-a</code><a class="anchor" aria-label="anchor" href="#the-unary-operators-a-and--a"></a>
</h4>
<p>These operators have the usual meaning and are implemented for all
rational matrix classes.</p>
</div>
<div class="section level4 unnumbered">
<h4 class="unnumbered" id="the-power-operator-ak">The Power Operator <code>a^k</code><a class="anchor" aria-label="anchor" href="#the-power-operator-ak"></a>
</h4>
<p>The power operator <code>a^k</code> is only implemented for square,
rational matrices
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">a(z)</annotation></semantics></math>
and integers
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>∈</mo><mi>ℤ</mi></mrow><annotation encoding="application/x-tex">k \in \mathbb{Z}</annotation></semantics></math>.</p>
<ul>
<li>
<code>a^0</code> works for all classes and returns the identity
matrix, represented by an object of the same class as the input argument
<code>a</code>. <strong>Note:</strong> This means
e.g. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>0</mn><mn>0</mn></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0^0 = 1</annotation></semantics></math>!</li>
<li>
<code>a^1</code> works for all classes and simply returns the input
argument <code>a</code>.</li>
<li>
<code>a^k</code> for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k&gt;1</annotation></semantics></math>
is implemented for all classes. However <code>lmfd</code> objects are
first coerced to statespace realizations. Thus the result in this case
is an object of class <code>stsp</code>. In all other cases, the result
is of the same class as the input argument <code>a</code>.</li>
<li>
<code>a^k</code> for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">k&lt;0</annotation></semantics></math>
is implemented for all classes. However,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>
must be non empty and objects of class <code>polm</code> and
<code>lmfd</code> are first coerced to <code>stsp</code> objects. This
means that the result has class <code>stsp</code> if the input is a
<code>polm</code>, <code>lmfd</code> or <code>stsp</code> object and it
has class <code>pseries</code> or <code>zvalues</code> if the input is
an <code>pseries</code> respectively <code>zvalues</code> object.</li>
</ul>
</div>
<div class="section level4 unnumbered">
<h4 class="unnumbered" id="binary-operators">Binary Operators<a class="anchor" aria-label="anchor" href="#binary-operators"></a>
</h4>
<p>For the binary operators (like ‘a + b’) the two arguments are first
coerced to a common class. To this end we use the following pseudo
ordering of classes:</p>
<p><code>matrix</code>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="0.278em"></mspace><mo>≺</mo><mspace width="0.278em"></mspace></mrow><annotation encoding="application/x-tex">\;\prec\;</annotation></semantics></math><code>polm</code>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="0.278em"></mspace><mo>≺</mo><mspace width="0.278em"></mspace></mrow><annotation encoding="application/x-tex">\;\prec\;</annotation></semantics></math><code>lmfd</code>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="0.278em"></mspace><mo>≺</mo><mspace width="0.278em"></mspace></mrow><annotation encoding="application/x-tex">\;\prec\;</annotation></semantics></math><code>stsp</code>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="0.278em"></mspace><mo>≺</mo><mspace width="0.278em"></mspace></mrow><annotation encoding="application/x-tex">\;\prec\;</annotation></semantics></math><code>pseries</code>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="0.278em"></mspace><mo>≺</mo><mspace width="0.278em"></mspace></mrow><annotation encoding="application/x-tex">\;\prec\;</annotation></semantics></math><code>zvalues</code></p>
<p>The following table shows how the class of the result depends on the
classes of <code>a</code> and <code>b</code>:</p>
<p><img src="a_rational_matrices_files/figure-html/unnamed-chunk-13-1.png" class="r-plt" alt="Type coercion matrix showing binary operation results between different rational matrix types" width="480"></p>
<p><strong>Note:</strong></p>
<ul>
<li>Objects which are not “rational matrices” are first coerced to
<code>polm</code> objects. If this fails an error is thrown. In the
above table this case is represented by the label
<code>matrix</code>.</li>
<li>
<code>lmfd</code> objects are first coerced to <code>stsp</code>
objects.</li>
<li>If two <code>pseries</code> objects are combined then they are
truncated to the minimum of the respective number of “lags”.</li>
<li>Two <code>zvalues</code> objects are only combined if the “z” values
are identical. Otherwise an error is thrown.</li>
<li>The statespace realizations computed are in general <em>not
minimal</em>. This remark also applies to other operations, like the
power <code>a^k</code>.</li>
<li>Of course the two arguments must be compatible, e.g. for elementwise
operations they must have the same number of rows and columns. However
for elementwise operations one of the arguments may be a scalar, i.e. a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>×</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(1 \times 1)</annotation></semantics></math>
matrix. Such arguments are “expanded” to matrices (of compatible
dimension) with identical elements.</li>
<li>There is no automatic coercion of <code>pseries</code> objects to
<code>zvalues</code> objects, since there is no guarantee that the
<code>pseries</code> object has sufficiently many lags. Of course the
user may perform this coercion manually.</li>
</ul>
<p>The above table applies for</p>
<ul>
<li>addition <code>a+b</code>
</li>
<li>substraction <code>a-b</code>
</li>
<li>elementwise multiplication <code>a * b</code>
</li>
<li>matrix multiplication <code>a %r% b</code>
</li>
<li>bind operations <code>rbind(a,b,...)</code> and
<code>cbind(a,b,...)</code>
</li>
</ul>
<p>The polynomial division and remainder operators <code>a %/% b</code>
and <code>a %% b</code> are only implemented for <code>polm</code>
objects or objects which may coerced to <code>polm</code> objects. These
operations are also elementwise operations and hence the above remark on
scalar arguments applies here.</p>
</div>
</div>
<div class="section level3">
<h3 id="transposition-of-rational-matrices">Transposition of Rational Matrices<a class="anchor" aria-label="anchor" href="#transposition-of-rational-matrices"></a>
</h3>
<div class="section level4 unnumbered">
<h4 class="unnumbered" id="ordinary-transpose-xz">“Ordinary” transpose
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>′</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">x'(z)</annotation></semantics></math><a class="anchor" aria-label="anchor" href="#ordinary-transpose-xz"></a>
</h4>
<p>The transposition operator (function) <code>t(x)</code> is
implemented for all classes, except for <code>lmfd</code> objects,
i.e. rational matrices in LMFD form (and should work as expected).</p>
<p>As an example consider the construction of a <em>Right Matrix
Fraction Description</em> of a rational matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>b</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><msup><mi>a</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">x(z) = b(z)a^{-1}(z)</annotation></semantics></math>.
The trick is simply to construct an LMFD of the transpose
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>′</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mover><mi>a</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mover><mi>b</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">x'(z) = \hat{a}^{-1}(z) \hat{b}(z)</annotation></semantics></math>,
then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>b</mi><mo accent="true">̂</mo></mover><mi>′</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><msup><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>a</mi><mo accent="true">̂</mo></mover><mi>′</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>x</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{b}'(z)(\hat{a}')^{-1}(z) = x(z)</annotation></semantics></math>
is the desired RMFD of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">x(z)</annotation></semantics></math>:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># create random rational, stable, (3 x 2) matrix in statespace form</span></span>
<span><span class="va">x</span> <span class="op">=</span> <span class="fu"><a href="../reference/test_stsp.html">test_stsp</a></span><span class="op">(</span>dim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">3</span>,<span class="fl">2</span><span class="op">)</span>, s <span class="op">=</span> <span class="fl">2</span>, bpoles <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># compute the impulse response</span></span>
<span><span class="va">k</span> <span class="op">=</span> <span class="fu"><a href="../reference/pseries.html">pseries</a></span><span class="op">(</span><span class="va">x</span>, lag.max <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Compute an LMFD realization of the transpose</span></span>
<span><span class="va">tx</span> <span class="op">=</span> <span class="fu"><a href="../reference/as.lmfd.html">as.lmfd</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">k</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">a</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">tx</span><span class="op">$</span><span class="va">a</span><span class="op">)</span></span>
<span><span class="va">b</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">tx</span><span class="op">$</span><span class="va">b</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># check</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="fu"><a href="../reference/zvalues.html">zvalues</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span>, <span class="fu"><a href="../reference/zvalues.html">zvalues</a></span><span class="op">(</span><span class="va">b</span><span class="op">)</span> <span class="op"><a href="../reference/ratm_mult.html">%r%</a></span> <span class="op">(</span><span class="fu"><a href="../reference/zvalues.html">zvalues</a></span><span class="op">(</span><span class="va">a</span><span class="op">)</span><span class="op">^</span><span class="op">{</span><span class="op">-</span><span class="fl">1</span><span class="op">}</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
</div>
<div class="section level4 unnumbered">
<h4 class="unnumbered" id="hermitean-transpose-xz">Hermitean transpose
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mo>*</mo></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">x^*(z)</annotation></semantics></math><a class="anchor" aria-label="anchor" href="#hermitean-transpose-xz"></a>
</h4>
<ul>
<li>
<p>The Hermitean transpose <code>Ht(x)</code> is only implemented
for frequency response objects and statespace realizations with a
regular state transition matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>.<br>
The Hermitean transpose of a rational matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">a(z)</annotation></semantics></math>
is defined as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mo>*</mo></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mover><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mover><mi>z</mi><mo accent="true">‾</mo></mover><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mo accent="true">¯</mo></mover><mi>′</mi></mrow><annotation encoding="application/x-tex">
a^*(z) = \overline{a(\bar{z}^{-1})}'
</annotation></semantics></math> If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">a(z)</annotation></semantics></math>
has real coefficients and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">|</mo><mi>z</mi><mo stretchy="true" form="postfix">|</mo></mrow><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|z|=1</annotation></semantics></math>
then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mo>*</mo></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mover><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mo accent="true">¯</mo></mover><mi>′</mi></mrow><annotation encoding="application/x-tex">a^*(z)=\overline{a(z)}'</annotation></semantics></math>.</p>
<p>As an example consider
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mrow><mn>1</mn><mo>+</mo><mn>0.5</mn><mi>z</mi></mrow><mrow><mn>1</mn><mo>+</mo><mn>0.1</mn><mi>z</mi><mo>+</mo><mn>0.1</mn><msup><mi>z</mi><mn>2</mn></msup><mo>+</mo><mn>0.1</mn><msup><mi>z</mi><mn>3</mn></msup><mo>−</mo><mn>0.8</mn><msup><mi>z</mi><mn>4</mn></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">
a(z) = \frac{1+0.5z}{1+0.1z+0.1z^2+0.1z^3-0.8z^4}
</annotation></semantics></math></p>
</li>
</ul>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">(</span><span class="va">a</span> <span class="op">=</span> <span class="fu"><a href="../reference/as.stsp.html">as.stsp</a></span><span class="op">(</span><span class="fu"><a href="../reference/lmfd.html">lmfd</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">0.1</span>,<span class="fl">0.1</span>,<span class="fl">0.1</span>,<span class="op">-</span><span class="fl">0.8</span><span class="op">)</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">0.5</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; statespace realization [1,1] with s = 4 states</span></span>
<span><span class="co">#&gt;      s[1] s[2] s[3] s[4]    u[1]</span></span>
<span><span class="co">#&gt; s[1] -0.1 -0.1 -0.1  0.8  0.7866</span></span>
<span><span class="co">#&gt; s[2]  1.0  0.0  0.0  0.0 -0.1260</span></span>
<span><span class="co">#&gt; s[3]  0.0  1.0  0.0  0.0 -0.1400</span></span>
<span><span class="co">#&gt; s[4]  0.0  0.0  1.0  0.0  0.4000</span></span>
<span><span class="co">#&gt; x[1]  0.0  0.0  0.0  1.0  1.0000</span></span>
<span></span>
<span><span class="va">fr</span> <span class="op">=</span> <span class="fu"><a href="../reference/zvalues.html">zvalues</a></span><span class="op">(</span><span class="va">a</span>, n.f <span class="op">=</span> <span class="fl">101</span><span class="op">)</span></span>
<span><span class="va">sp</span> <span class="op">=</span> <span class="va">fr</span> <span class="op"><a href="../reference/ratm_mult.html">%r%</a></span> <span class="fu"><a href="../reference/Ht.html">Ht</a></span><span class="op">(</span><span class="va">fr</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">abs</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/complex.html" class="external-link">Im</a></span><span class="op">(</span><span class="va">sp</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="va">sp</span>, <span class="fu"><a href="../reference/zvalues.html">zvalues</a></span><span class="op">(</span><span class="va">a</span> <span class="op"><a href="../reference/ratm_mult.html">%r%</a></span> <span class="fu"><a href="../reference/Ht.html">Ht</a></span><span class="op">(</span><span class="va">a</span><span class="op">)</span>, n.f <span class="op">=</span> <span class="fl">101</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">sp</span><span class="op">)</span></span></code></pre></div>
<p><img src="a_rational_matrices_files/figure-html/unnamed-chunk-16-1.png" class="r-plt" alt="Spectral density plot of state-space rational function showing Hermitian transpose properties" width="700"></p>
<p>The Hermitean transpose plays an important role for the <em>spectral
density</em> of VARMA processes and processes which are defined via
statespace models.</p>
</div>
</div>
<div class="section level3">
<h3 id="bind-rational-matrices-by-rows-and-columns">Bind Rational Matrices by Rows and Columns<a class="anchor" aria-label="anchor" href="#bind-rational-matrices-by-rows-and-columns"></a>
</h3>
<p>The methods</p>
<ul>
<li>
<code>rbind(...)</code> and</li>
<li><code>cbind(...)</code></li>
</ul>
<p>have their usual meaning, i.e. they take a list of rational matrix
objects and combine them by rows or columns. Before the matrices are
combined they are coerced to objects of the same class, as described in
the section on arithmetic operations. In particular note that
<code>lmfd</code> objects are coerced to <code>stsp</code> objects!
Howver, if only one argument is given then no coercion is performed,
i.e. if <code>x</code> is an <code>lmfd</code> object then
<code>bind(x)</code> returns an <code>lmfd</code> object.</p>
<p>Note that the statespace realizations in general are
<strong>not</strong> minimal. The number of lags for
<code>pseries</code> objects is the minimum of the number of lags of
each of them. Objects of class <code>zvalues</code> are only combined if
their <code>z</code> attributes (the complex points where the rational
function(s) have been evaluated) are identical.</p>
</div>
<div class="section level3">
<h3 id="extract-parts-replace-parts">Extract Parts, Replace Parts<a class="anchor" aria-label="anchor" href="#extract-parts-replace-parts"></a>
</h3>
<p>The subsetting operation <code>x[,]</code> for rational matrices
works analogously to the subsetting of ordinary matrices. The result is
an object of the same class. However, this operator is not implemented
for <code>lmfd</code> objects. Hence <code>x[i,j]</code> throws an error
if <code>x</code> is an <code>lmfd</code> object!</p>
<ul>
<li>
<code>x[]</code> and <code>x[,]</code> simply return the object
<code>x</code>.</li>
<li>
<code>x[i]</code> returns an
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(s,1)</annotation></semantics></math>
dimensional matrix with elements selected by the index
<code>i</code>.</li>
<li>
<code>x[i,j]</code> returns a matrix with rows selected by
<code>i</code> and columns selected by <code>j</code>.</li>
</ul>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">x</span> <span class="op">=</span> <span class="fu"><a href="../reference/test_polm.html">test_polm</a></span><span class="op">(</span>dim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">3</span><span class="op">)</span>, degree <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="va">x</span></span>
<span><span class="co">#&gt; ( 2 x 3 ) matrix polynomial with degree &lt;= 2 </span></span>
<span><span class="co">#&gt;      z^0 [,1]  [,2]  [,3] z^1 [,1]  [,2]  [,3] z^2 [,1]  [,2]  [,3]</span></span>
<span><span class="co">#&gt; [1,]      110   120   130      111   121   131      112   122   132</span></span>
<span><span class="co">#&gt; [2,]      210   220   230      211   221   231      212   222   232</span></span>
<span><span class="va">x</span><span class="op">[</span>,<span class="op">]</span></span>
<span><span class="co">#&gt; ( 2 x 3 ) matrix polynomial with degree &lt;= 2 </span></span>
<span><span class="co">#&gt;      z^0 [,1]  [,2]  [,3] z^1 [,1]  [,2]  [,3] z^2 [,1]  [,2]  [,3]</span></span>
<span><span class="co">#&gt; [1,]      110   120   130      111   121   131      112   122   132</span></span>
<span><span class="co">#&gt; [2,]      210   220   230      211   221   231      212   222   232</span></span>
<span><span class="va">x</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">6</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="co">#&gt; ( 3 x 1 ) matrix polynomial with degree &lt;= 2 </span></span>
<span><span class="co">#&gt;      z^0 [,1] z^1 [,1] z^2 [,1]</span></span>
<span><span class="co">#&gt; [1,]      110      111      112</span></span>
<span><span class="co">#&gt; [2,]      210      211      212</span></span>
<span><span class="co">#&gt; [3,]      230      231      232</span></span>
<span><span class="va">x</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="co">#&gt; ( 2 x 3 ) matrix polynomial with degree &lt;= 2 </span></span>
<span><span class="co">#&gt;      z^0 [,1]  [,2]  [,3] z^1 [,1]  [,2]  [,3] z^2 [,1]  [,2]  [,3]</span></span>
<span><span class="co">#&gt; [1,]      220   220   220      221   221   221      222   222   222</span></span>
<span><span class="co">#&gt; [2,]      120   120   120      121   121   121      122   122   122</span></span>
<span></span>
<span><span class="va">x</span> <span class="op">=</span> <span class="fu"><a href="../reference/test_stsp.html">test_stsp</a></span><span class="op">(</span>dim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span><span class="op">)</span>, s <span class="op">=</span> <span class="fl">6</span><span class="op">)</span></span>
<span><span class="co"># the statements pseries(x[c(2,4)]) and pseries(x)[c(2,4)] are equivalent</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="fu"><a href="../reference/pseries.html">pseries</a></span><span class="op">(</span><span class="va">x</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">4</span><span class="op">)</span><span class="op">]</span><span class="op">)</span>, <span class="fu"><a href="../reference/pseries.html">pseries</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">4</span><span class="op">)</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span>
<span></span>
<span><span class="va">x</span> <span class="op">=</span> <span class="fu"><a href="../reference/test_lmfd.html">test_lmfd</a></span><span class="op">(</span>dim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">3</span><span class="op">)</span>, degrees <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/try.html" class="external-link">try</a></span><span class="op">(</span><span class="va">x</span><span class="op">[</span>,<span class="op">]</span><span class="op">)</span>  <span class="co"># throws an error</span></span>
<span><span class="co">#&gt; ( 2 x 3 ) left matrix fraction description a^(-1)(z) b(z) with degrees (p = 1, q = 1)</span></span>
<span><span class="co">#&gt; left factor a(z):</span></span>
<span><span class="co">#&gt;      z^0 [,1]  [,2]   z^1 [,1]       [,2]</span></span>
<span><span class="co">#&gt; [1,]        1     0  0.1056647  1.6418480</span></span>
<span><span class="co">#&gt; [2,]        0     1 -0.3335997 -0.6439059</span></span>
<span><span class="co">#&gt; right factor b(z):</span></span>
<span><span class="co">#&gt;        z^0 [,1]      [,2]      [,3]   z^1 [,1]       [,2]       [,3]</span></span>
<span><span class="co">#&gt; [1,]  0.5870206 -1.710822 -2.645212 -0.7074664  0.5378854 -0.8396228</span></span>
<span><span class="co">#&gt; [2,] -0.1504031  1.431033 -1.032457 -0.7005600 -0.3163322 -1.3549281</span></span></code></pre></div>
<p>The <code>$</code> operator may be used to extract the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>
polynomial of a left matrix fraction description (<code>lmfd</code>
object) and the matrices
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi><mo>,</mo><mi>C</mi><mo>,</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">A,B,C,D</annotation></semantics></math>
of a state space representation (<code>stsp</code> object).</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># extract a(z) polynomial</span></span>
<span><span class="va">x</span><span class="op">$</span><span class="va">a</span></span>
<span><span class="co">#&gt; ( 2 x 2 ) matrix polynomial with degree &lt;= 1 </span></span>
<span><span class="co">#&gt;      z^0 [,1]  [,2]   z^1 [,1]       [,2]</span></span>
<span><span class="co">#&gt; [1,]        1     0  0.1056647  1.6418480</span></span>
<span><span class="co">#&gt; [2,]        0     1 -0.3335997 -0.6439059</span></span></code></pre></div>
<p>The assigment operation <code>x[,] &lt;- value</code> is only
implemented for polynomial matrices and works quite analogously to the
assigment operation of “ordinary” matrices.</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">=</span> <span class="fu"><a href="../reference/test_polm.html">test_polm</a></span><span class="op">(</span>dim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">3</span>,<span class="fl">2</span><span class="op">)</span>, degree <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">a</span>, format <span class="op">=</span> <span class="st">'c'</span><span class="op">)</span></span>
<span><span class="co">#&gt; ( 3 x 2 ) matrix polynomial with degree &lt;= 1 </span></span>
<span><span class="co">#&gt;             [,1]        [,2]</span></span>
<span><span class="co">#&gt; [1,]  110 + 111z  120 + 121z</span></span>
<span><span class="co">#&gt; [2,]  210 + 211z  220 + 221z</span></span>
<span><span class="co">#&gt; [3,]  310 + 311z  320 + 321z</span></span>
<span></span>
<span><span class="co"># no items to replace, a is not changed</span></span>
<span><span class="va">a</span><span class="op">[</span><span class="cn">FALSE</span><span class="op">]</span> <span class="op">=</span> <span class="fl">0</span>   </span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">a</span>, format <span class="op">=</span> <span class="st">'c'</span><span class="op">)</span></span>
<span><span class="co">#&gt; ( 3 x 2 ) matrix polynomial with degree &lt;= 1 </span></span>
<span><span class="co">#&gt;             [,1]        [,2]</span></span>
<span><span class="co">#&gt; [1,]  110 + 111z  120 + 121z</span></span>
<span><span class="co">#&gt; [2,]  210 + 211z  220 + 221z</span></span>
<span><span class="co">#&gt; [3,]  310 + 311z  320 + 321z</span></span>
<span></span>
<span><span class="co"># set elements below the diagonal equal to zero</span></span>
<span><span class="va">a</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/lower.tri.html" class="external-link">lower.tri</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fl">0</span>, nrow <span class="op">=</span> <span class="fl">3</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span><span class="op">)</span><span class="op">]</span> <span class="op">=</span> <span class="fl">0</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">a</span>, format <span class="op">=</span> <span class="st">'c'</span><span class="op">)</span></span>
<span><span class="co">#&gt; ( 3 x 2 ) matrix polynomial with degree &lt;= 1 </span></span>
<span><span class="co">#&gt;             [,1]        [,2]</span></span>
<span><span class="co">#&gt; [1,]  110 + 111z  120 + 121z</span></span>
<span><span class="co">#&gt; [2,]           0  220 + 221z</span></span>
<span><span class="co">#&gt; [3,]           0           0</span></span>
<span></span>
<span><span class="co"># set (3,1) element</span></span>
<span><span class="va">a</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="op">-</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">a</span>, format <span class="op">=</span> <span class="st">'c'</span><span class="op">)</span></span>
<span><span class="co">#&gt; ( 3 x 2 ) matrix polynomial with degree &lt;= 1 </span></span>
<span><span class="co">#&gt;             [,1]        [,2]</span></span>
<span><span class="co">#&gt; [1,]  110 + 111z  120 + 121z</span></span>
<span><span class="co">#&gt; [2,]           0  220 + 221z</span></span>
<span><span class="co">#&gt; [3,]       1 - z           0</span></span>
<span></span>
<span><span class="co"># set the elements in the first two rows and columns</span></span>
<span><span class="va">a</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span>, <span class="fl">2</span><span class="op">:</span><span class="fl">1</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/array.html" class="external-link">array</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">1</span><span class="op">)</span>,</span>
<span>                    dim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">2</span>,<span class="fl">4</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">a</span>, format <span class="op">=</span> <span class="st">'c'</span><span class="op">)</span></span>
<span><span class="co">#&gt; ( 3 x 2 ) matrix polynomial with degree &lt;= 3 </span></span>
<span><span class="co">#&gt;        [,1]  [,2]</span></span>
<span><span class="co">#&gt; [1,]    z^2     1</span></span>
<span><span class="co">#&gt; [2,]    z^3     z</span></span>
<span><span class="co">#&gt; [3,]  1 - z     0</span></span>
<span></span>
<span><span class="co"># this produces a warning,  </span></span>
<span><span class="co"># left hand side refers to 3 elements but</span></span>
<span><span class="co"># the right hand side has 2 elements!</span></span>
<span><span class="va">a</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="../reference/test_polm.html">test_polm</a></span><span class="op">(</span>dim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">)</span>, degree <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span><span class="co">#&gt; Warning in `[&lt;-.polm`(`*tmp*`, , 1, value = structure(c(110, 210, 111, 211, :</span></span>
<span><span class="co">#&gt; number of items to replace is not a multiple of replacement length</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">a</span>, format <span class="op">=</span> <span class="st">'c'</span><span class="op">)</span></span>
<span><span class="co">#&gt; ( 3 x 2 ) matrix polynomial with degree &lt;= 4 </span></span>
<span><span class="co">#&gt;                                        [,1]  [,2]</span></span>
<span><span class="co">#&gt; [1,]  110 + 111z + 112z^2 + 113z^3 + 114z^4     1</span></span>
<span><span class="co">#&gt; [2,]  210 + 211z + 212z^2 + 213z^3 + 214z^4     z</span></span>
<span><span class="co">#&gt; [3,]  110 + 111z + 112z^2 + 113z^3 + 114z^4     0</span></span></code></pre></div>
<p><strong>Note:</strong> The subsetting and the assigment operators do
not allow “named” arguments. Therefore the following statements throw an
error</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/try.html" class="external-link">try</a></span><span class="op">(</span><span class="va">a</span><span class="op">[</span>i<span class="op">=</span><span class="fl">1</span>, j<span class="op">=</span><span class="fl">2</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="co">#&gt; Error in `[.polm`(a, i = 1, j = 2) : named dimensions are not supported</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/try.html" class="external-link">try</a></span><span class="op">(</span><span class="va">a</span><span class="op">[</span>i<span class="op">=</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="co">#&gt; Error in `[&lt;-.polm`(`*tmp*`, i = 1, value = 1) : </span></span>
<span><span class="co">#&gt;   named dimensions are not supported</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="poles-and-zeroes">Poles and Zeroes<a class="anchor" aria-label="anchor" href="#poles-and-zeroes"></a>
</h3>
<div class="section level4 unnumbered">
<h4 class="unnumbered" id="polynomials">Polynomials<a class="anchor" aria-label="anchor" href="#polynomials"></a>
</h4>
<p>The zeroes of a square
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">m\times m</annotation></semantics></math>)-dimensional,
non singular polynomial matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mi>z</mi><mo>+</mo><mi>⋯</mi><msub><mi>a</mi><mi>p</mi></msub><msup><mi>z</mi><mi>p</mi></msup></mrow><annotation encoding="application/x-tex">a(z)=a_0+a_1z+\cdots a_p z^p</annotation></semantics></math>,
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>det</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>a</mi><mn>0</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\det(a_0)\neq 0</annotation></semantics></math>
are the reciprocals of the non zero eigenvalues of the companion
matrix</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mo>−</mo><msubsup><mi>a</mi><mn>0</mn><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><msub><mi>a</mi><mn>1</mn></msub></mtd><mtd columnalign="center" style="text-align: center"><mi>⋯</mi></mtd><mtd columnalign="center" style="text-align: center"><mo>−</mo><msubsup><mi>a</mi><mn>0</mn><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><msub><mi>a</mi><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><mo>−</mo><msubsup><mi>a</mi><mn>0</mn><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><msub><mi>a</mi><mi>p</mi></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>I</mi><mi>m</mi></msub></mtd><mtd columnalign="center" style="text-align: center"><mi>⋯</mi></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd><mtd columnalign="center" style="text-align: center"><mo>⋱</mo></mtd><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mi>⋯</mi></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>I</mi><mi>m</mi></msub></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mo>∈</mo><msup><mi>ℝ</mi><mrow><mi>m</mi><mi>p</mi><mo>×</mo><mi>m</mi><mi>p</mi></mrow></msup></mrow><annotation encoding="application/x-tex">
A = \begin{pmatrix}
-a_0^{-1}a_1 &amp; \cdots &amp; -a_0^{-1} a_{p-1} &amp; -a_0^{-1} a_p \\
I_m          &amp; \cdots &amp; 0                 &amp;          0    \\
\vdots       &amp; \ddots &amp; \vdots            &amp;     \vdots    \\
0            &amp; \cdots &amp; I_m               &amp;           0
\end{pmatrix} \in \mathbb{R}^{mp\times mp}
</annotation></semantics></math></p>
<p>This fact is used by <code>zeroes.polm</code>. However, there are
some problems with this (simple) approach.</p>
<ul>
<li>It does not work for polynomials with a zero at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">z=0</annotation></semantics></math>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mn>0</mn></msub><annotation encoding="application/x-tex">a_0</annotation></semantics></math>
is singular). An alternative is to use the function
<code>is.coprime</code> which uses a (singular) pencil. See the examples
below.</li>
<li>Due to numerical errors the function <code>eigen</code> (which is
used to compute the eigenvalues of the companion matrix) may return some
(very small) eigenvalues instead of exact zeroes. The function
<code>zeroes.polm</code> therefore skips all eigenvalues which are
smaller than a certain threshold. If the option
<code>print_message</code> is set to <code>TRUE</code> then a
corresponding message is printed. Clearly, choosing a too small
tolerance bound may result in some very large “spurious”” zeroes. On the
other hand if the bound is too large, then some of the “true” zeroes may
be skipped.</li>
</ul>
<p>To summarize. There are numerical problems if the coefficient
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mn>0</mn></msub><annotation encoding="application/x-tex">a_0</annotation></semantics></math>
is ill conditioned or if the companion matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
is (close to) singular.</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># polynomial with degree p = 0 ##############################</span></span>
<span><span class="fu"><a href="../reference/poles_and_zeroes.html">zeroes</a></span><span class="op">(</span><span class="fu"><a href="../reference/polm.html">polm</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/diag.html" class="external-link">diag</a></span><span class="op">(</span><span class="fl">3</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>  <span class="co"># returns empty vector</span></span>
<span><span class="co">#&gt; numeric(0)</span></span>
<span></span>
<span><span class="co"># (2 x 2) polynomial with degree 2 ##########################</span></span>
<span><span class="va">a</span> <span class="op">=</span> <span class="fu"><a href="../reference/test_polm.html">test_polm</a></span><span class="op">(</span>dim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span>, degree <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="op">(</span><span class="va">z</span> <span class="op">=</span> <span class="fu"><a href="../reference/poles_and_zeroes.html">zeroes</a></span><span class="op">(</span><span class="va">a</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] -0.5-0.8660254i -0.5+0.8660254i -0.5-0.8660254i -0.5+0.8660254i</span></span>
<span></span>
<span><span class="co"># check the rank of a(z) at the computed zeroes</span></span>
<span><span class="va">az</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/class.html" class="external-link">unclass</a></span><span class="op">(</span><span class="fu"><a href="../reference/zvalues.html">zvalues</a></span><span class="op">(</span><span class="va">a</span>, <span class="va">z</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/apply.html" class="external-link">apply</a></span><span class="op">(</span><span class="va">az</span>, MARGIN <span class="op">=</span> <span class="fl">3</span>, FUN <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">{</span><span class="va">d</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/svd.html" class="external-link">svd</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">$</span><span class="va">d</span>; <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="va">d</span><span class="op">)</span><span class="op">/</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="va">d</span><span class="op">)</span><span class="op">}</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 5.368273e-14 5.368273e-14 5.364620e-14 5.364620e-14</span></span>
<span></span>
<span><span class="co"># (2 x 2) polynomial with degree 2 ##########################</span></span>
<span><span class="co"># and singular coefficient matrix a[2]</span></span>
<span><span class="va">a</span> <span class="op">=</span> <span class="fu"><a href="../reference/test_polm.html">test_polm</a></span><span class="op">(</span>dim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span>, degree <span class="op">=</span> <span class="fl">2</span>,</span>
<span>               col_end_matrix <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fl">1</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span><span class="fl">2</span><span class="op">)</span> <span class="op">)</span></span>
<span><span class="op">(</span><span class="va">z</span> <span class="op">=</span> <span class="fu"><a href="../reference/poles_and_zeroes.html">zeroes</a></span><span class="op">(</span><span class="va">a</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] -0.5-0.8660254i -0.5+0.8660254i -0.5-0.8660254i -0.5+0.8660254i</span></span>
<span></span>
<span><span class="co"># alternatively, we may also use is.coprime()</span></span>
<span><span class="fu"><a href="../reference/is.coprime.html">is.coprime</a></span><span class="op">(</span><span class="va">a</span>, only.answer <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span><span class="op">$</span><span class="va">zeroes</span></span>
<span><span class="co">#&gt; [1] -0.5+0.8660254i -0.5-0.8660254i -0.5+0.8660254i -0.5-0.8660254i</span></span>
<span></span>
<span><span class="co"># (2x2) polynomial matrix with degree 2 #####################</span></span>
<span><span class="co"># and singular coefficient matrix a[0]</span></span>
<span><span class="va">a</span> <span class="op">=</span> <span class="fu"><a href="../reference/polm.html">polm</a></span><span class="op">(</span><span class="fu"><a href="../reference/dbind.html">dbind</a></span><span class="op">(</span>d <span class="op">=</span> <span class="fl">3</span>, <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fl">1</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span>,</span>
<span>                      <span class="fu"><a href="../reference/test_array.html">test_array</a></span><span class="op">(</span>dim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># zeroes(a) throws an error!</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/try.html" class="external-link">try</a></span><span class="op">(</span><span class="fu"><a href="../reference/poles_and_zeroes.html">zeroes</a></span><span class="op">(</span><span class="va">a</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; Error in zeroes.polm(a) : </span></span>
<span><span class="co">#&gt;   Could not generate companion matrix. Coefficient pertaining to smallest degree might be singular.</span></span>
<span></span>
<span><span class="co"># However, we may use is.coprime() in this case</span></span>
<span><span class="fu"><a href="../reference/is.coprime.html">is.coprime</a></span><span class="op">(</span><span class="va">a</span>, only.answer <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span><span class="op">$</span><span class="va">zeroes</span></span>
<span><span class="co">#&gt; [1] -1.000000e+00+1.28135e-08i -1.000000e+00-1.28135e-08i</span></span>
<span><span class="co">#&gt; [3] -4.163125e-10+0.00000e+00i  4.163124e-10+0.00000e+00i</span></span></code></pre></div>
</div>
<div class="section level4 unnumbered">
<h4 class="unnumbered" id="left-matrix-fraction-descriptions">Left Matrix Fraction Descriptions<a class="anchor" aria-label="anchor" href="#left-matrix-fraction-descriptions"></a>
</h4>
<p>Suppose
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>a</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>b</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">c(z)= a^{-1}(z) b(z)</annotation></semantics></math>
is an
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(m \times n)</annotation></semantics></math>
dimensional rational matrix
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>
are polynomials). If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a,b)</annotation></semantics></math>
are left coprime then the poles of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
are the zeroes of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>.
Furthermore if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
is square, then the zeroes of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
are the zeroes of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>.</p>
<p>Therefore the methods <code>poles.lmfd</code> and
<code>zeroes.lmfd</code> simply use <code>zeroes.polm</code> in order to
compute poles and zeroes of a rational matrix given in LMFD form. This
implies that all the above caveats also apply here. E.g. the methods
only work for the case that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mn>0</mn></msub><annotation encoding="application/x-tex">a_0</annotation></semantics></math>
(respectively
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>b</mi><mn>0</mn></msub><annotation encoding="application/x-tex">b_0</annotation></semantics></math>)
is non singular.</p>
<p>In addition the routines do not provide the correct answers in the
case that the pair
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a,b)</annotation></semantics></math>
is <em>not</em> left coprime. Here a pole/zero cancellation may occur,
which is not taken into account by the methods <code>poles.lmfd</code>
and <code>zeroes.lmfd</code>. This means that the functions may return
some <em>spurious</em> poles and zeroes.</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># create a random rational (2 x 2) matrix in LMFD form with p = 1, q = 2</span></span>
<span><span class="co"># note that two random polynomials are "generically" left coprime</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">8924</span><span class="op">)</span></span>
<span><span class="va">a</span> <span class="op">=</span> <span class="fu"><a href="../reference/test_polm.html">test_polm</a></span><span class="op">(</span>dim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span>, degree <span class="op">=</span> <span class="fl">1</span>, random <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">b</span> <span class="op">=</span> <span class="fu"><a href="../reference/test_polm.html">test_polm</a></span><span class="op">(</span>dim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span>, degree <span class="op">=</span> <span class="fl">2</span>, random <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">c</span> <span class="op">=</span> <span class="fu"><a href="../reference/lmfd.html">lmfd</a></span><span class="op">(</span><span class="va">a</span>,<span class="va">b</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># poles of c=a^{-1}b  are the zeroes of a</span></span>
<span><span class="fu"><a href="../reference/poles_and_zeroes.html">poles</a></span><span class="op">(</span><span class="va">c</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1]  0.4136219 -0.9481900</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sort.html" class="external-link">sort</a></span><span class="op">(</span><span class="fu"><a href="../reference/poles_and_zeroes.html">poles</a></span><span class="op">(</span><span class="va">c</span><span class="op">)</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/sort.html" class="external-link">sort</a></span><span class="op">(</span><span class="fu"><a href="../reference/poles_and_zeroes.html">zeroes</a></span><span class="op">(</span><span class="va">a</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span>
<span></span>
<span><span class="co"># zeroes of c=a^{-1}b  are the zeroes of b</span></span>
<span><span class="fu"><a href="../reference/poles_and_zeroes.html">zeroes</a></span><span class="op">(</span><span class="va">c</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1]  0.01188418+0.0000000i -0.44699481+0.0000000i -0.07539272-0.8587459i</span></span>
<span><span class="co">#&gt; [4] -0.07539272+0.8587459i</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sort.html" class="external-link">sort</a></span><span class="op">(</span><span class="fu"><a href="../reference/poles_and_zeroes.html">zeroes</a></span><span class="op">(</span><span class="va">c</span><span class="op">)</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/sort.html" class="external-link">sort</a></span><span class="op">(</span><span class="fu"><a href="../reference/poles_and_zeroes.html">zeroes</a></span><span class="op">(</span><span class="va">b</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<p>Now we construct an LMFD where a,b are not coprime. We simply simply
multiply the above matrices
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a,b</annotation></semantics></math>
with a common factor
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>r</mi><annotation encoding="application/x-tex">r</annotation></semantics></math>
and note that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>a</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>b</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">(r a)^{-1} (r b) = a^{-1} b = c</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># generate random common factor</span></span>
<span><span class="va">r</span> <span class="op">=</span> <span class="fu"><a href="../reference/test_polm.html">test_polm</a></span><span class="op">(</span>dim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span>, degree <span class="op">=</span> <span class="fl">1</span>, random <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">ra</span> <span class="op">=</span> <span class="va">r</span> <span class="op"><a href="../reference/ratm_mult.html">%r%</a></span> <span class="va">a</span></span>
<span><span class="va">rb</span> <span class="op">=</span> <span class="va">r</span> <span class="op"><a href="../reference/ratm_mult.html">%r%</a></span> <span class="va">b</span></span>
<span><span class="va">cc</span> <span class="op">=</span> <span class="fu"><a href="../reference/lmfd.html">lmfd</a></span><span class="op">(</span><span class="va">ra</span>,<span class="va">rb</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># here we get two "spurious" poles/zeroes</span></span>
<span><span class="op">(</span><span class="va">pz</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="fu"><a href="../reference/poles_and_zeroes.html">poles</a></span><span class="op">(</span><span class="va">cc</span><span class="op">)</span>, <span class="fl">6</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1]  0.413622 -0.817746 -0.948190  2.707221</span></span>
<span><span class="op">(</span><span class="va">zz</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="fu"><a href="../reference/poles_and_zeroes.html">zeroes</a></span><span class="op">(</span><span class="va">cc</span><span class="op">)</span>, <span class="fl">6</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1]  0.011884+0.000000i -0.446995+0.000000i -0.817746+0.000000i</span></span>
<span><span class="co">#&gt; [4] -0.075393-0.858746i -0.075393+0.858746i  2.707221+0.000000i</span></span>
<span></span>
<span><span class="co"># the zeroes of r pop up as poles and zeroes of cc</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/sort.html" class="external-link">sort</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="fu"><a href="../reference/poles_and_zeroes.html">zeroes</a></span><span class="op">(</span><span class="va">r</span><span class="op">)</span>, <span class="fl">6</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] -0.817746  2.707221</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/sort.html" class="external-link">sort</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sets.html" class="external-link">intersect</a></span><span class="op">(</span><span class="va">pz</span>, <span class="va">zz</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] -0.817746+0i  2.707221+0i</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="cn">NULL</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level4 unnumbered">
<h4 class="unnumbered" id="statespace-representation-1">Statespace Representation<a class="anchor" aria-label="anchor" href="#statespace-representation-1"></a>
</h4>
<p>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>C</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>z</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>I</mi><mo>−</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>B</mi><mo>+</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">k(z) = C(z^{-1}I - A)^{-1}B + D</annotation></semantics></math>
be a rational matrix, given in state space form. If the statespace
representation is <em>minimal</em> then the poles of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
are the reciprocals of the non zero eigenvalues of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>.
Furthermore if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
is square and if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>
is regular (i.e. if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">k(0)=D</annotation></semantics></math>
is regular) then the zeroes of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
are the reciprocals of the eigenvalues of the matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo>−</mo><mi>B</mi><msup><mi>D</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>C</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(A-BD^{-1}C)</annotation></semantics></math>.</p>
<p>The methods <code>poles.stsp</code> and <code>zeroes.stsp</code>
therefore compute the poles (and zeroes) of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
via the eigenvalues of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
(respectively of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo>−</mo><mi>B</mi><msup><mi>D</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>C</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(A-BD^{-1}C)</annotation></semantics></math>).
However, they do not check whether the statespace realization is
minimal.</p>
<p>Here analogous warnings are in place as for the polynomial and the
LMFD case:</p>
<ul>
<li>The procedures may return “spurious” poles or zeroes if the
representation is not minimal.</li>
<li>The procedures use a threshold (<code>tol</code>) in order to decide
whether a small eigenvalue returned by <code>eigen</code> is due to a
“true zero” eigenvalue or not.</li>
<li>The computation of zeroes is only implemented for the case that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
has no zero at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">z=0</annotation></semantics></math>.
If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>
is ill conditioned then the results may be unreliable.</li>
</ul>
</div>
</div>
<div class="section level3">
<h3 id="checks">Checks<a class="anchor" aria-label="anchor" href="#checks"></a>
</h3>
<ul>
<li>
<code><a href="../reference/check.html">is.stable()</a></code> checks whether the rational matrix has no
poles on or withing the unit circle.</li>
<li>
<code><a href="../reference/check.html">is.miniphase()</a></code> checks whether the rational matrix has
no zeroes on or within the unit circle.</li>
</ul>
<p>These test function just return <code>TRUE</code> or
<code>FALSE</code>. The poles and zeroes of the rational matrix are
computed via the functions <code>poles</code> and <code>zeroes</code>
respectively. Hence the above caveats also apply here.</p>
<p>For <code>pseries</code> and <code>zvalues</code> objects the
functions return <code>NA</code>.</p>
<div class="section level4 unnumbered">
<h4 class="unnumbered" id="is-coprime">is.coprime()<a class="anchor" aria-label="anchor" href="#is-coprime"></a>
</h4>
<p>A polynomial matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
is called <em>left prime</em>, if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">c(z)</annotation></semantics></math>
has full row rank everywhere in the complex plane. Clearly this implies
that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
is square or “wide”, i.e. if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(m \times n)</annotation></semantics></math>-dimensional
then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m \leq n</annotation></semantics></math>
must hold.</p>
<p>A pair
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a,b)</annotation></semantics></math>
of (compatible) polynomial matrices is called <em>left coprime</em> if
the matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">c=[a,b]</annotation></semantics></math>
is left prime. This case is important for the structure of left matrix
fraction descriptions. Suppose
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>a</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>b</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">c(z)=a^{-1} b(z)</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>
is a square, non singular polynomial matrix. If the pair is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a,b)</annotation></semantics></math>
is <em>not</em> left coprime, then we may cancel a common, non
unimodular, factor and thus obtain a “simpler” representation for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">c(z)</annotation></semantics></math>.</p>
<p>The function <code>is.coprime</code> may be called with the following
syntax:</p>
<ul>
<li>
<code>test_coprime(c)</code> where <code>c</code> is an
<code>lmfd</code> object, which represents a rational matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>a</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>b</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">c(z)=a^{-1}(z)b(z)</annotation></semantics></math>,
checks whether the pair
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a,b)</annotation></semantics></math>
is left coprime.<br>
</li>
<li>
<code>test_coprime(a)</code> where <code>a</code> is an
<code>polm</code> object, which represents a polynomial matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">a(z)</annotation></semantics></math>,
checks whether
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>
is left prime.<br>
</li>
<li>
<code>test_coprime(a,b)</code> where <code>a</code>, <code>b</code>
are <code>polm</code> objects, which represent the polynomial matrices
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>,
checks whether the pair
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a,b)</annotation></semantics></math>
is left coprime.</li>
</ul>
<p>For implementation details see the vignette .</p>
</div>
<div class="section level4 unnumbered">
<h4 class="unnumbered" id="is-minimal">is.minimal()<a class="anchor" aria-label="anchor" href="#is-minimal"></a>
</h4>
<p>A statespace realization
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo>,</mo><mi>C</mi><mo>,</mo><mi>D</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(A,B,C,D)</annotation></semantics></math>
is minimal if and only if the Hankel matrix of the impulse response
coefficients
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>i</mi></msub><mo>=</mo><mi>C</mi><msup><mi>A</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup><mi>B</mi></mrow><annotation encoding="application/x-tex">k_i = CA^{i-1}B</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i\geq 1</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>k</mi><mn>1</mn></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>k</mi><mn>2</mn></msub></mtd><mtd columnalign="center" style="text-align: center"><mi>⋯</mi></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>k</mi><mi>s</mi></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>k</mi><mn>2</mn></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>k</mi><mn>3</mn></msub></mtd><mtd columnalign="center" style="text-align: center"><mi>⋯</mi></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>k</mi><mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd><mtd columnalign="center" style="text-align: center"></mtd><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>k</mi><mi>s</mi></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>k</mi><mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><mi>⋯</mi></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>k</mi><mrow><mn>2</mn><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mo>∈</mo><msup><mi>ℝ</mi><mrow><mi>m</mi><mi>s</mi><mo>×</mo><mi>n</mi><mi>s</mi></mrow></msup></mrow><annotation encoding="application/x-tex">
\begin{pmatrix}
k_1 &amp; k_2     &amp; \cdots &amp; k_s \\
k_2 &amp; k_3     &amp; \cdots &amp; k_{s+1} \\
\vdots &amp; \vdots &amp;      &amp; \vdots  \\
k_s &amp; k_{s+1} &amp; \cdots &amp; k_{2s-1}                   
\end{pmatrix} \in \mathbb{R}^{ms\times ns}
</annotation></semantics></math> has rank
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>.
Therefore the procedure <code><a href="../reference/is.minimal.html">is.minimal()</a></code> computes the SVD of
this matrix and returns <code>TRUE</code> if the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>-th
singular value is larger than a given threshold <code>tol</code>.</p>
<p>In order to check whether the statespace realization is observable
and/or controllable one may consider the observability and
controllability matrices (which may be computed with
<code>obs_matrix</code> and <code>ctr_matrix</code>) or the
corresponding Grammians (see <code>grammians</code>).</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">x</span> <span class="op">=</span> <span class="fu"><a href="../reference/test_stsp.html">test_stsp</a></span><span class="op">(</span>dim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span>, s <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/is.minimal.html">is.minimal</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<p>Note that operations on <code>stsp</code> objects may return non
minimal realizations. E.g.:</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/is.minimal.html">is.minimal</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">rbind</a></span><span class="op">(</span><span class="va">x</span>, <span class="va">x</span><span class="op">)</span>, only.answer <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">'answer'</span>,<span class="st">'sv'</span>,<span class="st">'s0'</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="co">#&gt; $answer</span></span>
<span><span class="co">#&gt; [1] FALSE</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $sv</span></span>
<span><span class="co">#&gt; [1] 6.300395e+01 5.292349e+01 7.700432e-15 3.743904e-15 2.753267e-15</span></span>
<span><span class="co">#&gt; [6] 1.399977e-15 1.046407e-15 4.476098e-16</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $s0</span></span>
<span><span class="co">#&gt; [1] 2</span></span>
<span><span class="fu"><a href="../reference/is.minimal.html">is.minimal</a></span><span class="op">(</span><span class="va">x</span> <span class="op"><a href="../reference/ratm_mult.html">%r%</a></span> <span class="op">(</span><span class="va">x</span><span class="op">^</span><span class="op">(</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span>, only.answer <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">'answer'</span>,<span class="st">'sv'</span>,<span class="st">'s0'</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="co">#&gt; $answer</span></span>
<span><span class="co">#&gt; [1] FALSE</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $sv</span></span>
<span><span class="co">#&gt; [1] 1.136170e-12 1.900404e-13 7.902990e-14 2.577351e-14 3.080105e-15</span></span>
<span><span class="co">#&gt; [6] 1.323681e-15 3.842298e-16 3.872231e-17</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $s0</span></span>
<span><span class="co">#&gt; [1] 0</span></span></code></pre></div>
<p>Here <code>s0</code> is an estimate of the minimal statespace
dimension.</p>
<p>In order to construct a minimal realization one may use the procedure
<a href="#balance"><code>balance</code></a>.</p>
</div>
</div>
<div class="section level3">
<h3 id="derivatives">Derivatives<a class="anchor" aria-label="anchor" href="#derivatives"></a>
</h3>
<p>The derivative of a rational function (with respect to the argument
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>)
may be computed with the <code>S3</code> method <code>derivative</code>.
However, <code>lmfd</code> and <code>zvalues</code> objects are not
supported.</p>
<p>As a simply example consider a polynomial of degree
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>4</mn><annotation encoding="application/x-tex">4</annotation></semantics></math>
and its derivatives:</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">=</span> <span class="fu"><a href="../reference/polm.html">polm</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">x</span> <span class="kw">in</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">2</span>,<span class="op">-</span><span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">a</span> <span class="op">=</span> <span class="va">a</span> <span class="op">*</span> <span class="fu"><a href="../reference/polm.html">polm</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="op">-</span><span class="fl">1</span><span class="op">/</span><span class="va">x</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">a</span>, format <span class="op">=</span> <span class="st">'c'</span><span class="op">)</span></span>
<span><span class="co">#&gt; ( 1 x 1 ) matrix polynomial with degree &lt;= 4 </span></span>
<span><span class="co">#&gt;                        [,1]</span></span>
<span><span class="co">#&gt; [1,]  1 - 1.25z^2 + 0.25z^4</span></span></code></pre></div>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">z</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span>from <span class="op">=</span> <span class="op">-</span><span class="fl">2.25</span>, to <span class="op">=</span> <span class="fl">2.25</span>, length.out <span class="op">=</span> <span class="fl">201</span><span class="op">)</span></span>
<span><span class="va">out</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="fu"><a href="../reference/zvalues.html">zvalues</a></span><span class="op">(</span><span class="va">a</span>, z <span class="op">=</span> <span class="va">z</span><span class="op">)</span>, x_list <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="fu"><a href="../reference/zvalues.html">zvalues</a></span><span class="op">(</span><span class="fu"><a href="../reference/derivative.html">derivative</a></span><span class="op">(</span><span class="va">a</span><span class="op">)</span><span class="op">*</span><span class="op">(</span><span class="fl">1</span><span class="op">/</span><span class="fl">4</span><span class="op">)</span>, z <span class="op">=</span> <span class="va">z</span><span class="op">)</span>,</span>
<span>                                      <span class="fu"><a href="../reference/zvalues.html">zvalues</a></span><span class="op">(</span><span class="fu"><a href="../reference/derivative.html">derivative</a></span><span class="op">(</span><span class="fu"><a href="../reference/derivative.html">derivative</a></span><span class="op">(</span><span class="va">a</span><span class="op">)</span><span class="op">)</span><span class="op">*</span><span class="op">(</span><span class="fl">1</span><span class="op">/</span><span class="fl">12</span><span class="op">)</span>, z <span class="op">=</span> <span class="va">z</span><span class="op">)</span>,</span>
<span>                                      <span class="fu"><a href="../reference/zvalues.html">zvalues</a></span><span class="op">(</span><span class="fu"><a href="../reference/derivative.html">derivative</a></span><span class="op">(</span><span class="fu"><a href="../reference/derivative.html">derivative</a></span><span class="op">(</span><span class="fu"><a href="../reference/derivative.html">derivative</a></span><span class="op">(</span><span class="va">a</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">*</span><span class="op">(</span><span class="fl">1</span><span class="op">/</span><span class="fl">24</span><span class="op">)</span>, z <span class="op">=</span> <span class="va">z</span><span class="op">)</span><span class="op">)</span>,</span>
<span>     which <span class="op">=</span> <span class="st">'real'</span>, legend <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/expression.html" class="external-link">expression</a></span><span class="op">(</span><span class="fu">a</span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/expression.html" class="external-link">expression</a></span><span class="op">(</span><span class="fu">frac</span><span class="op">(</span><span class="fl">1</span>,<span class="fl">4</span><span class="op">)</span><span class="op">~</span><span class="fu">frac</span><span class="op">(</span><span class="va">d</span><span class="op">*</span><span class="va">a</span>,<span class="va">d</span><span class="op">*</span><span class="va">x</span><span class="op">)</span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span>,</span>
<span>                                <span class="fu"><a href="https://rdrr.io/r/base/expression.html" class="external-link">expression</a></span><span class="op">(</span><span class="fu">frac</span><span class="op">(</span><span class="fl">1</span>,<span class="fl">12</span><span class="op">)</span><span class="op">~</span><span class="fu">frac</span><span class="op">(</span><span class="va">d</span><span class="op">^</span><span class="fl">2</span><span class="op">*</span><span class="va">a</span>,<span class="va">d</span><span class="op">^</span><span class="fl">2</span><span class="op">*</span><span class="va">x</span><span class="op">)</span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span>,</span>
<span>                                <span class="fu"><a href="https://rdrr.io/r/base/expression.html" class="external-link">expression</a></span><span class="op">(</span><span class="fu">frac</span><span class="op">(</span><span class="fl">1</span>,<span class="fl">24</span><span class="op">)</span><span class="op">~</span><span class="fu">frac</span><span class="op">(</span><span class="va">d</span><span class="op">^</span><span class="fl">3</span><span class="op">*</span><span class="va">a</span>,<span class="va">d</span><span class="op">^</span><span class="fl">3</span><span class="op">*</span><span class="va">x</span><span class="op">)</span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">opar</span> <span class="op">=</span> <span class="fu">out</span><span class="op">(</span><span class="fl">1</span>,<span class="fl">1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span>h<span class="op">=</span><span class="fl">0</span>, col <span class="op">=</span> <span class="st">'darkgray'</span><span class="op">)</span></span></code></pre></div>
<p><img src="a_rational_matrices_files/figure-html/unnamed-chunk-27-1.png" class="r-plt" alt="Polynomial and its first three derivatives plotted over real axis showing critical points" width="700"></p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span><span class="va">opar</span><span class="op">)</span></span></code></pre></div>
<p>Note that computing the derivative for an impulse response object
decreases the number of lags by one!</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">x</span> <span class="op">=</span> <span class="fu"><a href="../reference/test_stsp.html">test_stsp</a></span><span class="op">(</span>dim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span>, s <span class="op">=</span> <span class="fl">12</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="fu"><a href="../reference/pseries.html">pseries</a></span><span class="op">(</span><span class="fu"><a href="../reference/derivative.html">derivative</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span>, lag.max <span class="op">=</span> <span class="fl">10</span><span class="op">)</span>,</span>
<span>          <span class="fu"><a href="../reference/derivative.html">derivative</a></span><span class="op">(</span><span class="fu"><a href="../reference/pseries.html">pseries</a></span><span class="op">(</span><span class="va">x</span>, lag.max <span class="op">=</span> <span class="fl">11</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="polynomial-methods">Methods for Polynomials<a class="anchor" aria-label="anchor" href="#polynomial-methods"></a>
</h2>
<p>This section implements <strong>Polynomial Manipulation</strong> (#4
in CLAUDE.md) and related analysis tools.</p>
<div class="section level3">
<h3 id="normal-forms">Normal Forms<a class="anchor" aria-label="anchor" href="#normal-forms"></a>
</h3>
<p>The package contains functions which compute some of the most
important “normal forms” of polynomial matrices, e.g. the Smith normal
form. However, we should note that the computation of such normal form
is numerically quite tricky and that the implementation here is rather
simple minded. Therefore these functions may fail for large, complex
polynomial matrices.</p>
<div class="section level4 unnumbered">
<h4 class="unnumbered" id="hermite-normal-form">Hermite Normal Form<a class="anchor" aria-label="anchor" href="#hermite-normal-form"></a>
</h4>
<p>Any polynomial matrix can be transformed to a
“quasi-upper-triangular” matrix by elementary row operations, i.e. by
multiplication with a unimodular matrix from the left. Suppose that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">a(z)</annotation></semantics></math>
is an
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m \times n</annotation></semantics></math>
dimensional matrix with rank
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>≤</mo><mo>min</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>,</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">r \leq \min(m,n)</annotation></semantics></math>.
Then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>u</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">h(z) = u^{-1}(z) a(z)</annotation></semantics></math>
is the <em>column Hermite form</em> of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">a(z)</annotation></semantics></math>,
if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">u(z)</annotation></semantics></math>
is unimodular and if there exist integers
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>j</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>&lt;</mo><mi>j</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>&lt;</mo><mi>⋯</mi><mo>&lt;</mo><mi>j</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1\leq j(i) &lt;j(2) &lt; \cdots &lt; j(r)\leq n</annotation></semantics></math>
such that</p>
<ul>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">h_{i,j(i)}(z)</annotation></semantics></math>
is monic (the coefficient pertaining to the highest degree is equal to
one),</li>
<li>the elements above
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">h_{i,j(i)}(z)</annotation></semantics></math>
have lower polynomial degree than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">h_{i,j(i)}(z)</annotation></semantics></math>
and</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">h_{i,j}(z) = 0</annotation></semantics></math>
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&gt;</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">i&gt;r</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>&lt;</mo><mi>j</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">j &lt; j(i)</annotation></semantics></math>.</li>
</ul>
<p>See also <span class="citation">Kailath (1980)</span>.</p>
<p>Quite analogously one may transform the matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">a(z)</annotation></semantics></math>
by elementary column operations into “quasi-lower-triangular” form
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><msup><mi>u</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">h(z) = a(z)u^{-1}(z)</annotation></semantics></math>.
The corresponding normal form is called <em>row Hermite form</em>.</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">=</span> <span class="fu"><a href="../reference/polm.html">polm</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/array.html" class="external-link">array</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">0.4</span>, <span class="op">-</span><span class="fl">1.3</span>, <span class="op">-</span><span class="fl">0.3</span>,  <span class="fl">0.6</span>, <span class="fl">1.1</span>,  <span class="fl">1</span>,</span>
<span>                 <span class="op">-</span><span class="fl">1.7</span>,  <span class="fl">0</span>,   <span class="op">-</span><span class="fl">0.8</span>, <span class="op">-</span><span class="fl">0.3</span>, <span class="fl">3.2</span>, <span class="op">-</span><span class="fl">0.4</span><span class="op">)</span>, dim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">3</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">a</span>, format <span class="op">=</span> <span class="st">'c'</span><span class="op">)</span></span>
<span><span class="co">#&gt; ( 2 x 3 ) matrix polynomial with degree &lt;= 1 </span></span>
<span><span class="co">#&gt;              [,1]         [,2]        [,3]</span></span>
<span><span class="co">#&gt; [1,]  -0.4 - 1.7z  -0.3 - 0.8z  1.1 + 3.2z</span></span>
<span><span class="co">#&gt; [2,]         -1.3   0.6 - 0.3z    1 - 0.4z</span></span>
<span></span>
<span><span class="va">out</span> <span class="op">=</span> <span class="fu"><a href="../reference/hnf.html">hnf</a></span><span class="op">(</span><span class="va">a</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">h</span>, format <span class="op">=</span> <span class="st">'c'</span>, digits <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="co">#&gt; ( 2 x 3 ) matrix polynomial with degree &lt;= 2 </span></span>
<span><span class="co">#&gt;       [,1]               [,2]               [,3]</span></span>
<span><span class="co">#&gt; [1,]     1        -0.5 + 0.2z        -0.8 + 0.3z</span></span>
<span><span class="co">#&gt; [2,]     0  -1.2 - 3.8z + z^2  2 + 5.1z + 1.3z^2</span></span>
<span><span class="co"># check the result(s)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="va">a</span>, <span class="fu"><a href="../reference/prune.html">prune</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">u</span> <span class="op"><a href="../reference/ratm_mult.html">%r%</a></span> <span class="va">out</span><span class="op">$</span><span class="va">h</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="fu"><a href="../reference/polm.html">polm</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/diag.html" class="external-link">diag</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span><span class="op">)</span>, <span class="fu"><a href="../reference/prune.html">prune</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">u</span> <span class="op"><a href="../reference/ratm_mult.html">%r%</a></span> <span class="va">out</span><span class="op">$</span><span class="va">u_inv</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<p>The <em>row Hermite form</em> may be obtained by calling the function
<code><a href="../reference/hnf.html">hnf()</a></code> with the options <code>from_left=FALSE</code>.</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">out</span> <span class="op">=</span> <span class="fu"><a href="../reference/hnf.html">hnf</a></span><span class="op">(</span><span class="va">a</span>, from_left <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">h</span>, format <span class="op">=</span> <span class="st">'c'</span>, digits <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="co">#&gt; ( 2 x 3 ) matrix polynomial with degree &lt;= 0 </span></span>
<span><span class="co">#&gt;       [,1]  [,2]  [,3]</span></span>
<span><span class="co">#&gt; [1,]     1     0     0</span></span>
<span><span class="co">#&gt; [2,]     0     1     0</span></span>
<span><span class="co"># check the result(s)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="va">a</span>, <span class="fu"><a href="../reference/prune.html">prune</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">h</span> <span class="op"><a href="../reference/ratm_mult.html">%r%</a></span> <span class="va">out</span><span class="op">$</span><span class="va">u</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="fu"><a href="../reference/polm.html">polm</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/diag.html" class="external-link">diag</a></span><span class="op">(</span><span class="fl">3</span><span class="op">)</span><span class="op">)</span>, <span class="fu"><a href="../reference/prune.html">prune</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">u</span> <span class="op"><a href="../reference/ratm_mult.html">%r%</a></span> <span class="va">out</span><span class="op">$</span><span class="va">u_inv</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<p>Note that for the polynomial
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">a(z)</annotation></semantics></math>
considered in the above <code>R</code> demonstration(s), the row Hermite
form is particularly simple, since
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">a(z)</annotation></semantics></math>
is left prime. See also the discussion about <em>left (co)prime</em>
matrices in the vignette “Technical Details”.</p>
<p>The following example is a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>3</mn><mo>,</mo><mn>5</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(3,5)</annotation></semantics></math>
dimensional polynomial matrix with rank
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>.
The function <code><a href="../reference/hnf.html">hnf()</a></code> returns an “estimate” of the rank and
the “pivots”
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>j</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>…</mi><mo>,</mo><mi>j</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">j(1),j(2),\ldots, j(r)</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">=</span> <span class="fu"><a href="../reference/polm.html">polm</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/array.html" class="external-link">array</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">2</span>,<span class="op">-</span><span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">2</span>,<span class="op">-</span><span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">6</span>,<span class="op">-</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="fl">3</span>,<span class="fl">0</span>,<span class="fl">2</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">2</span>,<span class="op">-</span><span class="fl">1</span>,</span>
<span>                 <span class="fl">1</span>,<span class="op">-</span><span class="fl">2</span>,<span class="fl">1</span>,<span class="op">-</span><span class="fl">1</span>,<span class="fl">3</span>,<span class="fl">0</span>,<span class="fl">2</span>,<span class="op">-</span><span class="fl">8</span>,<span class="fl">1</span>,<span class="op">-</span><span class="fl">5</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span><span class="op">)</span>, dim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">3</span>,<span class="fl">5</span>,<span class="fl">3</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">a</span>, format <span class="op">=</span> <span class="st">'c'</span><span class="op">)</span></span>
<span><span class="co">#&gt; ( 3 x 5 ) matrix polynomial with degree &lt;= 2 </span></span>
<span><span class="co">#&gt;       [,1]    [,2]    [,3]          [,4]          [,5]</span></span>
<span><span class="co">#&gt; [1,]     0  2 + 2z  2 - 2z  6 + 3z + z^2  3 - 8z + z^2</span></span>
<span><span class="co">#&gt; [2,]     0  -1 - z  -1 + z      -3 + z^2       z + z^2</span></span>
<span><span class="co">#&gt; [3,]     0   1 + z   1 - z  3 + 2z + z^2  2 - 5z + z^2</span></span>
<span></span>
<span><span class="va">out</span> <span class="op">=</span> <span class="fu"><a href="../reference/hnf.html">hnf</a></span><span class="op">(</span><span class="va">a</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">h</span>, format <span class="op">=</span> <span class="st">'c'</span>, digits <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="co">#&gt; ( 3 x 5 ) matrix polynomial with degree &lt;= 2 </span></span>
<span><span class="co">#&gt;       [,1]   [,2]   [,3]     [,4]          [,5]</span></span>
<span><span class="co">#&gt; [1,]     0  1 + z  1 - z    3 + z        1 - 3z</span></span>
<span><span class="co">#&gt; [2,]     0      0      0  z + z^2  1 - 2z + z^2</span></span>
<span><span class="co">#&gt; [3,]     0      0      0        0             0</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">rank</span><span class="op">)</span>    <span class="co"># the rank of a(z) is 2</span></span>
<span><span class="co">#&gt; [1] 2</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">pivots</span><span class="op">)</span>  <span class="co"># the columns 2 and 4 are linearly independent.</span></span>
<span><span class="co">#&gt; [1] 2 4</span></span>
<span></span>
<span><span class="co"># check the result(s)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="va">a</span>, <span class="fu"><a href="../reference/prune.html">prune</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">u</span> <span class="op"><a href="../reference/ratm_mult.html">%r%</a></span> <span class="va">out</span><span class="op">$</span><span class="va">h</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="fu"><a href="../reference/polm.html">polm</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/diag.html" class="external-link">diag</a></span><span class="op">(</span><span class="fl">3</span><span class="op">)</span><span class="op">)</span>, <span class="fu"><a href="../reference/prune.html">prune</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">u</span> <span class="op"><a href="../reference/ratm_mult.html">%r%</a></span> <span class="va">out</span><span class="op">$</span><span class="va">u_inv</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
</div>
<div class="section level4 unnumbered">
<h4 class="unnumbered" id="smith-normal-form">Smith Normal Form<a class="anchor" aria-label="anchor" href="#smith-normal-form"></a>
</h4>
<p>For any
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(m \times n)</annotation></semantics></math>
dimensional polynomial matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">a(z)</annotation></semantics></math>
with rank
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>≤</mo><mo>min</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>,</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">r\leq \min(m,n)</annotation></semantics></math>
there exists a factorization</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>u</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>s</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
a(z) = u(z) s(z) v(z)
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">u(z)</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">v(z)</annotation></semantics></math>
are two unimodular matrices and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">s(z)</annotation></semantics></math>
is an
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m \times n</annotation></semantics></math>
dimensional quasi-diagonal matrix with diagonal entries
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">d_i(z)</annotation></semantics></math>
which satisfy</p>
<ul>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>d</mi><mi>i</mi></msub><annotation encoding="application/x-tex">d_i</annotation></semantics></math>
is monic for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>≤</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">i \leq r</annotation></semantics></math>
and zero for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&gt;</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">i&gt;r</annotation></semantics></math>,
and</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>d</mi><mi>i</mi></msub><annotation encoding="application/x-tex">d_i</annotation></semantics></math>
divides
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>d</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">d_{i+1}</annotation></semantics></math>
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">i&lt;r</annotation></semantics></math>.</li>
</ul>
<p>The above factorization may be constructed by using elementary
column- and row- operations.</p>
<p>For more details, see e.g. <span class="citation">Kailath
(1980)</span>.</p>
<p>As a simple example consider the following
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>×</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">4 \times 5</annotation></semantics></math>
dimensional polynomial matrix</p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">1234</span><span class="op">)</span> <span class="co"># set seed for random number generation</span></span>
<span></span>
<span><span class="va">z</span> <span class="op">=</span> <span class="fu"><a href="../reference/polm.html">polm</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">a</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span> <span class="fl">3</span>, <span class="fl">2</span>, <span class="fl">1</span>,<span class="op">-</span><span class="fl">3</span>,<span class="op">-</span><span class="fl">2</span>,<span class="op">-</span><span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">3</span>, ncol <span class="op">=</span> <span class="fl">3</span><span class="op">)</span> <span class="op">-</span> <span class="va">z</span><span class="op">*</span><span class="fu"><a href="../reference/polm.html">polm</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/diag.html" class="external-link">diag</a></span><span class="op">(</span><span class="fl">3</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co"># inflate this 3x3 matrix to a 4x5 matrix</span></span>
<span><span class="va">a</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">1</span><span class="op">:</span><span class="fl">1</span><span class="op">)</span>, <span class="fl">4</span><span class="op">*</span><span class="fl">3</span>, replace <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">4</span>, ncol <span class="op">=</span> <span class="fl">3</span><span class="op">)</span> <span class="op"><a href="../reference/ratm_mult.html">%r%</a></span> <span class="va">a</span></span>
<span><span class="va">a</span> <span class="op">=</span> <span class="va">a</span> <span class="op"><a href="../reference/ratm_mult.html">%r%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">1</span><span class="op">:</span><span class="fl">1</span><span class="op">)</span>, <span class="fl">3</span><span class="op">*</span><span class="fl">5</span>, replace <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">3</span>, ncol <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">a</span>, format<span class="op">=</span><span class="st">'c'</span><span class="op">)</span></span>
<span><span class="co">#&gt; ( 4 x 5 ) matrix polynomial with degree &lt;= 1 </span></span>
<span><span class="co">#&gt;         [,1]  [,2]  [,3]    [,4]  [,5]</span></span>
<span><span class="co">#&gt; [1,]      -1     z     0   1 + z    -z</span></span>
<span><span class="co">#&gt; [2,]      -2     0     z       2     0</span></span>
<span><span class="co">#&gt; [3,]  -3 + z     0     z   3 - z     0</span></span>
<span><span class="co">#&gt; [4,]   3 - z     0    -z  -3 + z     0</span></span>
<span></span>
<span><span class="va">out</span> <span class="op">=</span> <span class="fu"><a href="../reference/snf.html">snf</a></span><span class="op">(</span><span class="va">a</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">s</span>, digits <span class="op">=</span> <span class="fl">2</span>, format <span class="op">=</span> <span class="st">'c'</span><span class="op">)</span></span>
<span><span class="co">#&gt; ( 4 x 5 ) matrix polynomial with degree &lt;= 2 </span></span>
<span><span class="co">#&gt;       [,1]  [,2]      [,3]  [,4]  [,5]</span></span>
<span><span class="co">#&gt; [1,]     1     0         0     0     0</span></span>
<span><span class="co">#&gt; [2,]     0     z         0     0     0</span></span>
<span><span class="co">#&gt; [3,]     0     0  -z + z^2     0     0</span></span>
<span><span class="co">#&gt; [4,]     0     0         0     0     0</span></span>
<span></span>
<span><span class="co"># check result(s)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="va">a</span>, <span class="fu"><a href="../reference/prune.html">prune</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">u</span> <span class="op"><a href="../reference/ratm_mult.html">%r%</a></span> <span class="va">out</span><span class="op">$</span><span class="va">s</span> <span class="op"><a href="../reference/ratm_mult.html">%r%</a></span> <span class="va">out</span><span class="op">$</span><span class="va">v</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span>
<span></span>
<span><span class="co"># reset seed</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="cn">NULL</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level4 unnumbered">
<h4 class="unnumbered" id="column-reduced-form">Column Reduced Form<a class="anchor" aria-label="anchor" href="#column-reduced-form"></a>
</h4>
<p>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mi>z</mi><mo>+</mo><mi>⋯</mi><mo>+</mo><msub><mi>a</mi><mi>p</mi></msub><msup><mi>z</mi><mi>p</mi></msup></mrow><annotation encoding="application/x-tex">a(z)=a_0 + a_1 z + \cdots + a_p z^p</annotation></semantics></math>
be
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(m \times n)</annotation></semantics></math>,
polynomial matrix with column degrees
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>i</mi></msub><annotation encoding="application/x-tex">p_i</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">i=1,\ldots ,n</annotation></semantics></math>.
The column end matrix of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">a(z)</annotation></semantics></math>
is the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(m \times n)</annotation></semantics></math>
matrix with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>-th
column equal to the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>-th
column of the coefficient matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><msub><mi>p</mi><mi>i</mi></msub></msub><annotation encoding="application/x-tex">a_{p_i}</annotation></semantics></math>.</p>
<p>If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">a(z)</annotation></semantics></math>
is square and if the column end matrix is regular, then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>
is called <em>column reduced</em>.</p>
<p>Any non singular, square polynomial matrix may be transformed to a
column reduced matrix by a sequence of elementary column operations.
This means there exists a unimodular matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">v(z)</annotation></semantics></math>
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><msup><mi>v</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">a(z) v^{-1}(z)</annotation></semantics></math>
is column reduced.</p>
<p>This task is accomplished by the helper function
<code>col_reduce(a, ...)</code>.</p>
<p>As an example consider a random
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>3</mn><mo>×</mo><mn>3</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(3 \times 3)</annotation></semantics></math>,
polynomial matrix whose column end matrix has rank 1:</p>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># create a random (3 x 3) polynmial matrix with a column end matrix of rank 1</span></span>
<span><span class="va">col_end_matrix</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="fl">3</span><span class="op">)</span>,<span class="fl">1</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">3</span>, ncol <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span></span>
<span>                 <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="fl">3</span><span class="op">)</span>,<span class="fl">1</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">1</span>, ncol <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span>
<span><span class="va">a</span> <span class="op">=</span> <span class="fu"><a href="../reference/test_polm.html">test_polm</a></span><span class="op">(</span>dim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span><span class="op">)</span>, degree <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">1</span>,<span class="fl">1</span><span class="op">)</span>, random <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>               digits <span class="op">=</span> <span class="fl">2</span>, col_end_matrix <span class="op">=</span> <span class="va">col_end_matrix</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">a</span>, format <span class="op">=</span> <span class="st">'c'</span><span class="op">)</span></span>
<span><span class="co">#&gt; ( 3 x 3 ) matrix polynomial with degree &lt;= 2 </span></span>
<span><span class="co">#&gt;                         [,1]          [,2]          [,3]</span></span>
<span><span class="co">#&gt; [1,]  -0.63 + 1.77z + 0.4z^2  -0.88 + 0.5z  -0.48 + 0.4z</span></span>
<span><span class="co">#&gt; [2,]  0.69 - 0.01z - 0.08z^2  -0.89 - 0.1z  1.05 - 0.08z</span></span>
<span><span class="co">#&gt; [3,]  -1.31 - 0.31z - 0.8z^2      0.26 - z   0.54 - 0.8z</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/svd.html" class="external-link">svd</a></span><span class="op">(</span><span class="fu"><a href="../reference/col_end_matrix.html">col_end_matrix</a></span><span class="op">(</span><span class="va">a</span><span class="op">)</span><span class="op">)</span><span class="op">$</span><span class="va">d</span><span class="op">)</span>       <span class="co"># column end matrix has rank 1</span></span>
<span><span class="co">#&gt; [1] 1.694934e+00 1.695651e-16 9.628233e-18</span></span>
<span></span>
<span><span class="va">out</span> <span class="op">=</span> <span class="fu"><a href="../reference/col_reduce.html">col_reduce</a></span><span class="op">(</span><span class="va">a</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">a</span>, format <span class="op">=</span> <span class="st">'c'</span>, digits <span class="op">=</span> <span class="fl">2</span><span class="op">)</span>   <span class="co"># column reduced matrix</span></span>
<span><span class="co">#&gt; ( 3 x 3 ) matrix polynomial with degree &lt;= 1 </span></span>
<span><span class="co">#&gt;               [,1]           [,2]  [,3]</span></span>
<span><span class="co">#&gt; [1,]  -0.88 + 0.5z  -0.63 + 2.25z  0.22</span></span>
<span><span class="co">#&gt; [2,]  -0.89 - 0.1z   0.69 - 1.06z  1.76</span></span>
<span><span class="co">#&gt; [3,]      0.26 - z  -1.31 - 0.85z  0.33</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">col_degrees</span><span class="op">)</span>                   <span class="co"># column degrees</span></span>
<span><span class="co">#&gt; [1] 1 1 0</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">col_end_matrix</span><span class="op">)</span>                <span class="co"># column end matrix</span></span>
<span><span class="co">#&gt;      [,1]  [,2]  [,3]</span></span>
<span><span class="co">#&gt; [1,]  0.5  2.25 0.224</span></span>
<span><span class="co">#&gt; [2,] -0.1 -1.06 1.762</span></span>
<span><span class="co">#&gt; [3,] -1.0 -0.85 0.332</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/svd.html" class="external-link">svd</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">col_end_matrix</span><span class="op">)</span><span class="op">$</span><span class="va">d</span><span class="op">)</span>         <span class="co"># column end matrix is non singular!</span></span>
<span><span class="co">#&gt; [1] 2.8588250 1.6409980 0.7535844</span></span>
<span></span>
<span><span class="co"># check reult(s)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="fu"><a href="../reference/polm.html">polm</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/diag.html" class="external-link">diag</a></span><span class="op">(</span><span class="fl">3</span><span class="op">)</span><span class="op">)</span>, <span class="fu"><a href="../reference/prune.html">prune</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">v</span> <span class="op"><a href="../reference/ratm_mult.html">%r%</a></span> <span class="va">out</span><span class="op">$</span><span class="va">v_inv</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="fu"><a href="../reference/prune.html">prune</a></span><span class="op">(</span><span class="va">a</span><span class="op">)</span>, <span class="fu"><a href="../reference/prune.html">prune</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">a</span> <span class="op"><a href="../reference/ratm_mult.html">%r%</a></span> <span class="va">out</span><span class="op">$</span><span class="va">v</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="fu"><a href="../reference/col_end_matrix.html">col_end_matrix</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">a</span><span class="op">)</span>, <span class="va">out</span><span class="op">$</span><span class="va">col_end_matrix</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
</div>
<div class="section level4 unnumbered">
<h4 class="unnumbered" id="wiener-hopf-factorisation">Wiener-Hopf Factorisation<a class="anchor" aria-label="anchor" href="#wiener-hopf-factorisation"></a>
</h4>
<p>A Wiener-Hopf factorization of a (square
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>,</mo><mi>m</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(m,m)</annotation></semantics></math>-dimensional,
non singular) polynomial matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">A(z)</annotation></semantics></math>
is a factorization of the form</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>A</mi><mi>f</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>z</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>A</mi><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>A</mi><mi>b</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>A</mi><mi>r</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>A</mi><mi>b</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
A(z) = A_f(z^{-1}) A_0(z) A_b(z) = A_r(z) A_b(z),
</annotation></semantics></math> where</p>
<ul>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>b</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">A_b(z)</annotation></semantics></math>
is a polynomial matrix which has zeroes outside the unit circle,</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>r</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">A_r(z)</annotation></semantics></math>
is a column reduced polynomial matrix with column degrees
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>κ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\kappa_i</annotation></semantics></math><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">i=1,\ldots,m</annotation></semantics></math>
and zeroes inside the unit circle,</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">A_0(z)</annotation></semantics></math>
is a diagonal matrix with diagonal entries
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>z</mi><msub><mi>κ</mi><mi>i</mi></msub></msup><annotation encoding="application/x-tex">z^{\kappa_i}</annotation></semantics></math>
and<br>
</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>f</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>z</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>A</mi><mi>r</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><msubsup><mi>A</mi><mn>0</mn><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">A_f(z^{-1}) = A_r(z)A_0^{-1}(z)</annotation></semantics></math>
is a polynomial in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>z</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><annotation encoding="application/x-tex">z^{-1}</annotation></semantics></math>!</li>
</ul>
<p>The factors
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>f</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>z</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">A_f(z^{-1})</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">A_0(z)</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>b</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">A_b(z)</annotation></semantics></math>
are called <em>forward</em>, <em>null</em> and <em>backward</em>
components of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">A(z)</annotation></semantics></math>,
and the integers
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>κ</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>κ</mi><mi>n</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\kappa_1,\ldots,\kappa_n)</annotation></semantics></math>
are the <em>partial indices</em> of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">A(z)</annotation></semantics></math>.</p>
<p>Note that zeroes on the unit circle are not allowed.</p>
<p>The Wiener-Hopf factorization plays an important role for the
analysis of linear, rational expectation models. See e.g. <span class="citation">Al-Sadoon (2017)</span>.</p>
<p>The WHF is constructed in three steps</p>
<ul>
<li>first compute the Smith form
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>u</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>s</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">A(z)= u(z) s(z) v(z)</annotation></semantics></math>
</li>
<li>each diagonal entry
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>d</mi><mi>i</mi></msub><annotation encoding="application/x-tex">d_i</annotation></semantics></math>
is factored into a polynomial with zeroes inside, respectivly outside
the unit circle. Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>s</mi><mi>r</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>s</mi><mi>b</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">s(z) = s_r(z) s_b (z)</annotation></semantics></math>
denote the corresponding factorization of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">s(z)</annotation></semantics></math>.
This gives
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>s</mi><mi>r</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>b</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">A(z) = (u(z) s_r(z)) (s_b(z) v(z))</annotation></semantics></math>.</li>
<li>compute the column reduced form of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>s</mi><mi>r</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>A</mi><mi>r</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>w</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(u(z) s_r(z)) = A_r(z) w(z)</annotation></semantics></math>
and set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>b</mi></msub><mo>=</mo><msup><mi>w</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>s</mi><mi>b</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">A_b = w^{-1}(z) s_b(z) v(z)</annotation></semantics></math>.</li>
<li>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>κ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\kappa_i</annotation></semantics></math>
denote the columnn degrees of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>r</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">A_r(z)</annotation></semantics></math>
and set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>f</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>z</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>A</mi><mi>r</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mtext mathvariant="normal">diag</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>z</mi><mrow><mo>−</mo><msub><mi>κ</mi><mi>i</mi></msub></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">A_f(z^{-1}) = A_r(z) \mbox{diag}(z^{-\kappa_i})</annotation></semantics></math>.
Note that by construction
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>f</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>z</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">A_f(z^{-1})</annotation></semantics></math>
is a polynomial in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>z</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><annotation encoding="application/x-tex">z^{-1}</annotation></semantics></math>.</li>
</ul>
<p>Simulation example:</p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">54321</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># create test polynomial</span></span>
<span><span class="va">a</span> <span class="op">=</span> <span class="fu"><a href="../reference/test_polm.html">test_polm</a></span><span class="op">(</span>dim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">4</span>,<span class="fl">4</span><span class="op">)</span>, deg <span class="op">=</span> <span class="fl">2</span>, digits <span class="op">=</span> <span class="fl">2</span>, random <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># compute WHF and print the result</span></span>
<span><span class="va">out</span> <span class="op">=</span> <span class="fu"><a href="../reference/whf.html">whf</a></span><span class="op">(</span><span class="va">a</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">af</span>, digits <span class="op">=</span> <span class="fl">2</span>, format <span class="op">=</span> <span class="st">'c'</span><span class="op">)</span></span>
<span><span class="co">#&gt; ( 4 x 4 ) Laurent polynomial matrix with degree &lt;= 0, and minimal degree &gt;= -1</span></span>
<span><span class="co">#&gt;                 [,1]             [,2]              [,3]   [,4]</span></span>
<span><span class="co">#&gt; [1,]               0         0.76z^-1             -1.59   1.57</span></span>
<span><span class="co">#&gt; [2,]               0                0                 0  -0.62</span></span>
<span><span class="co">#&gt; [3,]  2.6z^-1 - 4.83  -3.6z^-1 + 3.51   0.04z^-1 + 3.58  -3.35</span></span>
<span><span class="co">#&gt; [4,]   -2.61z^-1 + 6  4.19z^-1 - 6.26  -2.29z^-1 - 0.31    2.5</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">a0</span>, digits <span class="op">=</span> <span class="fl">2</span>, format <span class="op">=</span> <span class="st">'c'</span><span class="op">)</span></span>
<span><span class="co">#&gt; ( 4 x 4 ) matrix polynomial with degree &lt;= 1 </span></span>
<span><span class="co">#&gt;       [,1]  [,2]  [,3]  [,4]</span></span>
<span><span class="co">#&gt; [1,]     z     0     0     0</span></span>
<span><span class="co">#&gt; [2,]     0     z     0     0</span></span>
<span><span class="co">#&gt; [3,]     0     0     z     0</span></span>
<span><span class="co">#&gt; [4,]     0     0     0     1</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">ab</span>, digits <span class="op">=</span> <span class="fl">2</span>, format <span class="op">=</span> <span class="st">'c'</span><span class="op">)</span></span>
<span><span class="co">#&gt; ( 4 x 4 ) matrix polynomial with degree &lt;= 2 </span></span>
<span><span class="co">#&gt;                         [,1]                    [,2]                     [,3]           [,4]</span></span>
<span><span class="co">#&gt; [1,]           -2.99 + 5.26z           -4.16 - 1.04z             2.63 + 0.28z       3.13 - z</span></span>
<span><span class="co">#&gt; [2,]           -3.35 + 5.61z           -4.22 - 1.11z             2.45 - 0.27z   3.69 - 1.06z</span></span>
<span><span class="co">#&gt; [3,]           -0.35 + 3.09z           -2.13 - 0.92z             0.61 - 0.79z   2.06 - 0.57z</span></span>
<span><span class="co">#&gt; [4,]  1.51 - 1.88z + 1.81z^2  1.78 - 0.79z - 0.86z^2  -0.29 - 0.08z - 1.26z^2  -0.84 + 2.07z</span></span>
<span></span>
<span><span class="co"># check the result</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="va">a</span>, <span class="fu"><a href="../reference/prune.html">prune</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">ar</span> <span class="op"><a href="../reference/ratm_mult.html">%r%</a></span> <span class="va">out</span><span class="op">$</span><span class="va">ab</span><span class="op">)</span><span class="op">)</span>           <span class="co"># A = Ar * Ab</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span>
<span></span>
<span><span class="co"># check A(z) = Ab(z^{-1}) A0(z) Ab(z)</span></span>
<span><span class="co"># generate random complex z's</span></span>
<span><span class="va">z</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/complex.html" class="external-link">complex</a></span><span class="op">(</span>real <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span>, imaginary <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">a_z</span>  <span class="op">=</span> <span class="fu"><a href="../reference/zvalues.html">zvalues</a></span><span class="op">(</span><span class="va">a</span>, <span class="va">z</span><span class="op">)</span>         <span class="co"># A(z)</span></span>
<span><span class="va">ab_z</span> <span class="op">=</span> <span class="fu"><a href="../reference/zvalues.html">zvalues</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">ab</span>, <span class="va">z</span><span class="op">)</span>    <span class="co"># Ab(z)</span></span>
<span><span class="va">a0_z</span> <span class="op">=</span> <span class="fu"><a href="../reference/zvalues.html">zvalues</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">a0</span>, <span class="va">z</span><span class="op">)</span>    <span class="co"># A0(z)</span></span>
<span><span class="va">af_z</span> <span class="op">=</span> <span class="fu"><a href="../reference/zvalues.html">zvalues</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">af</span>, <span class="fl">1</span><span class="op">/</span><span class="va">z</span><span class="op">)</span>  <span class="co"># Af(z^{-1})  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/attr.html" class="external-link">attr</a></span><span class="op">(</span><span class="va">af_z</span>, <span class="st">'z'</span><span class="op">)</span> <span class="op">=</span> <span class="va">z</span>           <span class="co"># in order to combine the 'zvalues' objects,</span></span>
<span>                              <span class="co"># the attribute 'z' must be identical</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="va">a_z</span>, <span class="va">af_z</span> <span class="op"><a href="../reference/ratm_mult.html">%r%</a></span> <span class="va">a0_z</span> <span class="op"><a href="../reference/ratm_mult.html">%r%</a></span> <span class="va">ab_z</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "Mean relative Mod difference: 3.086469"</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">idx</span>, <span class="fu"><a href="../reference/degree.html">degree</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">ar</span>, <span class="st">'columns'</span><span class="op">)</span><span class="op">)</span>    <span class="co"># idx = column degrees of Ar</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.html" class="external-link">all</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/svd.html" class="external-link">svd</a></span><span class="op">(</span><span class="fu"><a href="../reference/col_end_matrix.html">col_end_matrix</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">ar</span><span class="op">)</span><span class="op">)</span><span class="op">$</span><span class="va">d</span> <span class="op">&gt;</span> <span class="fl">1e-7</span><span class="op">)</span>     <span class="co"># Ar is column reduced</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.html" class="external-link">all</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">abs</a></span><span class="op">(</span><span class="fu"><a href="../reference/poles_and_zeroes.html">zeroes</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">ar</span>, print_message <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span><span class="op">)</span> <span class="op">&lt;</span> <span class="fl">1</span><span class="op">)</span>  <span class="co"># Ar has zeroes inside the unit circle</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.html" class="external-link">all</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">abs</a></span><span class="op">(</span><span class="fu"><a href="../reference/poles_and_zeroes.html">zeroes</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">ab</span>, print_message <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span><span class="op">)</span> <span class="op">&gt;</span> <span class="fl">1</span><span class="op">)</span>  <span class="co"># Ab zeroes outside the unit circle</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="cn">NULL</span><span class="op">)</span></span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="blaschke">Reflect Zeroes by Multiplication with All Pass Matrices<a class="anchor" aria-label="anchor" href="#blaschke"></a>
</h3>
<p>A <em>Blaschke factor</em> is a rational function of the form</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mrow><mn>1</mn><mo>−</mo><mover><mi>α</mi><mo accent="true">‾</mo></mover><mi>z</mi></mrow><mrow><mo>−</mo><mi>α</mi><mo>+</mo><mi>z</mi></mrow></mfrac><mfrac><mi>α</mi><mover><mi>α</mi><mo accent="true">‾</mo></mover></mfrac></mrow><annotation encoding="application/x-tex">
a(z) = \frac{1-\bar{\alpha}z}{-\alpha + z}\frac{\alpha}{\bar{\alpha}}
</annotation></semantics></math> This function is <em>all pass</em>,
i.e.
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><msup><mi>a</mi><mo>*</mo></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><mn>1</mn><mo>−</mo><mover><mi>α</mi><mo accent="true">‾</mo></mover><mi>z</mi></mrow><mrow><mo>−</mo><mi>α</mi><mo>+</mo><mi>z</mi></mrow></mfrac><mfrac><mi>α</mi><mover><mi>α</mi><mo accent="true">‾</mo></mover></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><mn>1</mn><mo>−</mo><mi>α</mi><msup><mi>z</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><mrow><mo>−</mo><mover><mi>α</mi><mo accent="true">‾</mo></mover><mo>+</mo><msup><mi>z</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow></mfrac><mfrac><mover><mi>α</mi><mo accent="true">‾</mo></mover><mi>α</mi></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><mn>1</mn><mo>−</mo><mover><mi>α</mi><mo accent="true">‾</mo></mover><mi>z</mi></mrow><mrow><mo>−</mo><mi>α</mi><mo>+</mo><mi>z</mi></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><mi>z</mi><mo>−</mo><mi>α</mi></mrow><mrow><mo>−</mo><mover><mi>α</mi><mo accent="true">‾</mo></mover><mi>z</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">
a(z) a^*(z) = \left(\frac{1-\bar{\alpha}z}{-\alpha + z}\frac{\alpha}{\bar{\alpha}}\right)
              \left(\frac{1-\alpha z^{-1}}{-\bar{\alpha} + z^{-1}}\frac{\bar{\alpha}}{\alpha}\right)
            =  \left(\frac{1-\bar{\alpha}z}{-\alpha + z}\right)
              \left(\frac{z-\alpha}{-\bar{\alpha}z + 1}\right) = 1
</annotation></semantics></math> If we multiply a (scalar) polynomial
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">p(z)</annotation></semantics></math>,
which is zero at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">z=\alpha</annotation></semantics></math>,
with such a Blascke factor then we obtain a new polynomial,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>p</mi><mo accent="true">̃</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>p</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\tilde{p}(z) = p(z)a(z)</annotation></semantics></math>
say, where the zero at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">z=\alpha</annotation></semantics></math>
is replaced by a zeroe at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mn>1</mn><mi>/</mi><mover><mi>α</mi><mo accent="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">z=1/\bar{\alpha}</annotation></semantics></math>.
Furthermore both polynomial generate the same spectral density, i.e.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>p</mi><mo accent="true">̃</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><msup><mover><mi>p</mi><mo accent="true">̃</mo></mover><mo>*</mo></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>p</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><msup><mi>a</mi><mo>*</mo></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><msup><mi>p</mi><mo>*</mo></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>p</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><msup><mi>p</mi><mo>*</mo></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\tilde{p}(z) \tilde{p}^*(z) = p(z) a(z) a^*(z) p^*(z) = p(z) p^*(z)
</annotation></semantics></math></p>
<p>If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">p(z)</annotation></semantics></math>
is a real polynomial and the root
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">z=\alpha</annotation></semantics></math>
is complex then the polynomial
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>p</mi><mo accent="true">̃</mo></mover><annotation encoding="application/x-tex">\tilde{p}</annotation></semantics></math>
has complex coefficients. However, if we also flip the conjugated root
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mover><mi>α</mi><mo accent="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">z=\bar{\alpha}</annotation></semantics></math>
then we obtain a polynomial with real coefficients. This means the
polynomial</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><mn>1</mn><mo>−</mo><mover><mi>α</mi><mo accent="true">‾</mo></mover><mi>z</mi></mrow><mrow><mo>−</mo><mi>α</mi><mo>+</mo><mi>z</mi></mrow></mfrac><mfrac><mi>α</mi><mover><mi>α</mi><mo accent="true">‾</mo></mover></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><mn>1</mn><mo>−</mo><mi>α</mi><mi>z</mi></mrow><mrow><mo>−</mo><mover><mi>α</mi><mo accent="true">‾</mo></mover><mo>+</mo><mi>z</mi></mrow></mfrac><mfrac><mover><mi>α</mi><mo accent="true">‾</mo></mover><mi>α</mi></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
p(z)\left(\frac{1-\bar{\alpha}z}{-\alpha + z}\frac{\alpha}{\bar{\alpha}}\right)
    \left(\frac{1-\alpha z}{-\bar{\alpha} + z}\frac{\bar{\alpha}}{\alpha}\right)
</annotation></semantics></math> has real coefficients (and the “flipped
roots”
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>/</mi><mover><mi>α</mi><mo accent="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">1/\bar{\alpha}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>/</mi><mi>α</mi></mrow><annotation encoding="application/x-tex">1/\alpha</annotation></semantics></math>).</p>
<p>The multiplication with a (univariate) Blaschke factor is implemented
in the routine <code>blaschke_univariate()</code>.</p>
<p>This procedure may be generalized to polynomial matrices, see
<code>blaschke_multivariate</code>. Suppose that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">p(z)</annotation></semantics></math>
is an
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(m \times n)</annotation></semantics></math>
dimensional polynomial matrix and that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>
is a root, i.e
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>α</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">p(\alpha)</annotation></semantics></math>
is singular. Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>α</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>U</mi><mi>Σ</mi><msup><mi>V</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">p(\alpha)=U\Sigma V^*</annotation></semantics></math>
denote the SVD of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>α</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">p(\alpha)</annotation></semantics></math>
then the last row of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>U</mi><mo>*</mo></msup><mi>p</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>α</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">U^* p(\alpha)</annotation></semantics></math>
is zero, i.e.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo>−</mo><mi>α</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(z-\alpha)</annotation></semantics></math>
divides all entries of the last row. If we multiply the last row with
the corresponding Blaschke factor, we obtain a matrix polynomial, where
the root
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>
is replaced by the root
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>/</mi><mover><mi>α</mi><mo accent="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">1/\bar{\alpha}</annotation></semantics></math>.
(At least the “multiplicity” of the root
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>
has been reduced by one.) If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>
is complex we have to “blaschkerize” also the conjugate root
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>α</mi><mo accent="true">‾</mo></mover><annotation encoding="application/x-tex">\bar{\alpha}</annotation></semantics></math>
and to multiply the result with a suitable unitary matrix (see the
helper function <code>transform_polar4real</code>) in order to obtain a
polynomial matrix with real coeffcients. This task is accomplished by
<code>blaschke_multivariate</code>.</p>
<p>If we want to flip a set of roots, the utility
<code>transform_allpass</code> may be used.</p>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">1719</span><span class="op">)</span></span>
<span><span class="va">m0</span> <span class="op">=</span> <span class="fu"><a href="../reference/test_polm.html">test_polm</a></span><span class="op">(</span>dim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span>, degree <span class="op">=</span> <span class="fl">2</span>, digits <span class="op">=</span> <span class="fl">2</span>, random <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="va">m</span> <span class="op">=</span> <span class="va">m0</span> <span class="op">*</span> <span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="fu"><a href="../reference/polm.html">polm</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">mz</span> <span class="op">=</span> <span class="fu"><a href="../reference/poles_and_zeroes.html">zeroes</a></span><span class="op">(</span><span class="va">m</span><span class="op">)</span></span>
<span><span class="va">mz</span></span>
<span><span class="co">#&gt; [1]  0.1255159+0.000000i  1.0000000+0.000000i  1.0000000+0.000000i</span></span>
<span><span class="co">#&gt; [4]  0.1371003-1.270166i  0.1371003+1.270166i -2.4509944+0.000000i</span></span>
<span></span>
<span><span class="va">bm</span> <span class="op">=</span> <span class="kw"><a href="https://rdrr.io/r/base/try.html" class="external-link">try</a></span><span class="op">(</span><span class="fu">blaschke_multivariate</span><span class="op">(</span><span class="va">m</span>, <span class="va">mz</span><span class="op">[</span><span class="fl">4</span><span class="op">]</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; Error in blaschke_multivariate(m, mz[4]) : </span></span>
<span><span class="co">#&gt;   could not find function "blaschke_multivariate"</span></span>
<span></span>
<span><span class="va">bm</span> <span class="op">=</span> <span class="kw"><a href="https://rdrr.io/r/base/try.html" class="external-link">try</a></span><span class="op">(</span><span class="fu">blaschke_multivariate</span><span class="op">(</span><span class="va">m</span>, <span class="va">mz</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; Error in blaschke_multivariate(m, mz[2]) : </span></span>
<span><span class="co">#&gt;   could not find function "blaschke_multivariate"</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="cn">NULL</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="misc-tools">Misc Tools<a class="anchor" aria-label="anchor" href="#misc-tools"></a>
</h3>
<div class="section level4 unnumbered">
<h4 class="unnumbered" id="companion-matrix">Companion Matrix<a class="anchor" aria-label="anchor" href="#companion-matrix"></a>
</h4>
<p>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mi>z</mi><mo>+</mo><mi>⋯</mi><msub><mi>a</mi><mi>p</mi></msub><msup><mi>z</mi><mi>p</mi></msup></mrow><annotation encoding="application/x-tex">a(z) = a_0+a_1z+\cdots a_p z^p</annotation></semantics></math>
be a square
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">m\times m</annotation></semantics></math>)-dimensional,
non singular polynomial matrix with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><mo>≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a_0\neq 0</annotation></semantics></math>.
The companion matrix</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mo>−</mo><msubsup><mi>a</mi><mn>0</mn><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><msub><mi>a</mi><mn>1</mn></msub></mtd><mtd columnalign="center" style="text-align: center"><mi>⋯</mi></mtd><mtd columnalign="center" style="text-align: center"><mo>−</mo><msubsup><mi>a</mi><mn>0</mn><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><msub><mi>a</mi><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><mo>−</mo><msubsup><mi>a</mi><mn>0</mn><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><msub><mi>a</mi><mi>p</mi></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>I</mi><mi>m</mi></msub></mtd><mtd columnalign="center" style="text-align: center"><mi>⋯</mi></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd><mtd columnalign="center" style="text-align: center"><mo>⋱</mo></mtd><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mi>⋯</mi></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>I</mi><mi>m</mi></msub></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mo>∈</mo><msup><mi>ℝ</mi><mrow><mi>m</mi><mi>p</mi><mo>×</mo><mi>m</mi><mi>p</mi></mrow></msup></mrow><annotation encoding="application/x-tex">
\begin{pmatrix}
-a_0^{-1}a_1 &amp; \cdots &amp; -a_0^{-1} a_{p-1} &amp; -a_0^{-1} a_p \\
I_m          &amp; \cdots &amp; 0                 &amp;          0    \\
\vdots       &amp; \ddots &amp; \vdots            &amp;     \vdots    \\
0            &amp; \cdots &amp; I_m               &amp;           0
\end{pmatrix} \in \mathbb{R}^{mp\times mp}
</annotation></semantics></math> may be computed with the helper
function <code><a href="../reference/companion_matrix.html">companion_matrix()</a></code>. This function throws an error
if the argument is not square, has degree
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math>
or if the constant term
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mn>0</mn></msub><annotation encoding="application/x-tex">a_0</annotation></semantics></math>
is not invertible.</p>
</div>
<div class="section level4 unnumbered">
<h4 class="unnumbered" id="polynomial-degree">Polynomial Degree<a class="anchor" aria-label="anchor" href="#polynomial-degree"></a>
</h4>
<p>The helper function <code><a href="../reference/degree.html">degree()</a></code> returns the polynomial
degrees of the elements of a polynomial matrix, the maximum degrees of
the elements of the columns or rows of the matrix and the maximum degree
of all elements of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">a(z)</annotation></semantics></math>.
Note that the degree of a zero polynomial is set to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math>.</p>
</div>
<div class="section level4 unnumbered">
<h4 class="unnumbered" id="some-workhorse-functions">Some Workhorse Functions<a class="anchor" aria-label="anchor" href="#some-workhorse-functions"></a>
</h4>
<p>The following helper functions are in particular used to construct
normal forms, like the Hermite normal form, of polynomial matrices.</p>
<ul>
<li>
<code><a href="../reference/col_end_matrix.html">col_end_matrix()</a></code> computes the <em>column end
matrix</em> of a polynomial matrix.</li>
<li>
<code><a href="../reference/prune.html">prune()</a></code> “simplifies” a polynomial object. In
particular, small leading coefficients are set to zero and then zero
leading coefficent matrices are dropped.</li>
<li>
<code>purge()</code> “purges” all elements below, above, to the
right or to the left of a pivot element by elementary row- or column-
operations. Here “purge” means that the elements are either reduced to
zero or that the degree of the elements is made smaller than the degree
of the pivot element.</li>
</ul>
</div>
</div>
</div>
<div class="section level2">
<h2 id="stsp-methods">Methods for State-Space Forms<a class="anchor" aria-label="anchor" href="#stsp-methods"></a>
</h2>
<p>This section implements <strong>State-Space Tools</strong> (#6),
<strong>Pole/Zero Reflection</strong> (#8), and
<strong>Utilities</strong> (#10) from CLAUDE.md.</p>
<div class="section level3">
<h3 id="balance">Grammians and Balanced Realizations<a class="anchor" aria-label="anchor" href="#balance"></a>
</h3>
<p>We consider a rational matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>C</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>z</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>I</mi><mi>s</mi></msub><mo>−</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>B</mi><mo>+</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">K(z) = C(z^{-1}I_s - A)^{-1} B +D</annotation></semantics></math>
in state space form and we assume that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>
is stable, i.e. the eigenvalues of the matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
have moduli less than one.</p>
<p>The <em>controllability</em> Grammian of this statespace realization
is defined as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><munder><mo>∑</mo><mrow><mi>j</mi><mo>≥</mo><mn>0</mn></mrow></munder><msup><mi>A</mi><mi>j</mi></msup><mi>B</mi><mi>B</mi><mi>′</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mi>′</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>j</mi></msup><mo>=</mo><mi>A</mi><mi>P</mi><mi>A</mi><mi>′</mi><mo>+</mo><mi>B</mi><mi>B</mi><mi>′</mi></mrow><annotation encoding="application/x-tex">
P = \sum_{j\geq 0} A^j BB' (A')^j = APA' + BB'
</annotation></semantics></math> and the <em>observability</em> Grammian
is
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>=</mo><munder><mo>∑</mo><mrow><mi>j</mi><mo>≥</mo><mn>0</mn></mrow></munder><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mi>′</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>j</mi></msup><mi>C</mi><mi>′</mi><mi>C</mi><msup><mi>A</mi><mi>j</mi></msup><mo>=</mo><mi>A</mi><mi>′</mi><mi>Q</mi><mi>A</mi><mo>+</mo><mi>C</mi><mi>′</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">
Q = \sum_{j\geq 0} (A')^j C'C A^j = A'QA + C'C
</annotation></semantics></math> These Grammians may be computed with
the routine <code>grammians(obj)</code>.</p>
<p>The statespace realization is <em>minimal</em> if and only if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>
are both positive definite. Furthermore it can by shown that the product
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>Q</mi></mrow><annotation encoding="application/x-tex">PQ</annotation></semantics></math>
is diagonalizable (with non negative (real) eigenvalues) and that the
rank of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>Q</mi></mrow><annotation encoding="application/x-tex">PQ</annotation></semantics></math>
is equal to the minimal statespace dimension of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">K(z)</annotation></semantics></math>,
i.e. there exists a statespace realization of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">K(z)</annotation></semantics></math>
which has a statespace dimension equal to the rank of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>Q</mi></mrow><annotation encoding="application/x-tex">PQ</annotation></semantics></math>
and for any statespace realization of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">K(z)</annotation></semantics></math>
the statespace dimension is larger than or equal to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">k</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>P</mi><mi>Q</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{rk}(PQ)</annotation></semantics></math>.</p>
<p>If we apply a state space transformation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
then the Grammians transform as follows</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>→</mo><mi>T</mi><mi>P</mi><mi>T</mi><mi>′</mi><mo>,</mo><mspace width="0.278em"></mspace><mi>Q</mi><mo>→</mo><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>T</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow><mi>′</mi><mi>Q</mi><msup><mi>T</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> and </mtext><mspace width="0.333em"></mspace></mrow><mi>P</mi><mi>Q</mi><mo>→</mo><mi>T</mi><mi>P</mi><mi>Q</mi><msup><mi>T</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">
P \longrightarrow TPT',\; Q \longrightarrow (T^{-1})' Q T^{-1} \text{ and } PQ \longrightarrow TPQT^{-1}
</annotation></semantics></math></p>
<p>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mn>1</mn><mn>2</mn></msubsup><mo>≥</mo><msubsup><mi>σ</mi><mn>2</mn><mn>2</mn></msubsup><mo>≥</mo><mi>⋯</mi><mo>≥</mo><msubsup><mi>σ</mi><mi>s</mi><mn>2</mn></msubsup><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sigma_1^2 \geq \sigma_2^2 \geq \cdots \geq \sigma_{s}^2 \geq 0</annotation></semantics></math>
denote the ordered eigenvalues of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>Q</mi></mrow><annotation encoding="application/x-tex">PQ</annotation></semantics></math>
and suppose that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>Q</mi></mrow><annotation encoding="application/x-tex">PQ</annotation></semantics></math>
has rank
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>0</mn></msub><mo>≤</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">s_0 \leq s</annotation></semantics></math>,
i.e. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>k</mi></msub><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sigma_k&gt;0</annotation></semantics></math>
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><msub><mi>s</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">1\leq k \leq s_0</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>k</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sigma_k=0</annotation></semantics></math>
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>&gt;</mo><msub><mi>s</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">k&gt;s_0</annotation></semantics></math>.
Then there exists a state transformation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
such that the two transformed Grammians are both diagonal and the first
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>s</mi><mn>0</mn></msub><annotation encoding="application/x-tex">s_0</annotation></semantics></math>
diagonal entries of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>
and of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>
are given by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>σ</mi><mi>k</mi></msub><annotation encoding="application/x-tex">\sigma_k</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>s</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">k=1,\ldots,s_0</annotation></semantics></math>.
Therefore</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mn>11</mn></msub></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mn>22</mn></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="0.278em"></mspace><mi>Q</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>Q</mi><mn>11</mn></msub></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>Q</mi><mn>22</mn></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> with </mtext><mspace width="0.333em"></mspace></mrow><msub><mi>P</mi><mn>11</mn></msub><mo>=</mo><msub><mi>Q</mi><mn>11</mn></msub><mo>=</mo><mtext mathvariant="normal">diag</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>σ</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>σ</mi><msub><mi>s</mi><mn>0</mn></msub></msub><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> and </mtext><mspace width="0.333em"></mspace></mrow><msub><mi>P</mi><mn>22</mn></msub><msub><mi>Q</mi><mn>22</mn></msub><mo>=</mo><mn>0</mn><mi>.</mi></mrow><annotation encoding="application/x-tex">
P = \begin{pmatrix}
    P_{11} &amp; 0 \\
    0      &amp; P_{22}
    \end{pmatrix},\;
Q = \begin{pmatrix}
    Q_{11} &amp; 0 \\
    0      &amp; Q_{22}
    \end{pmatrix}
\mbox{ with }
P_{11} = Q_{11} = \mbox{diag}(\sigma_1,\ldots,\sigma_{s_0})
\mbox{ and }
P_{22} Q_{22} = 0.
</annotation></semantics></math></p>
<p>The
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>σ</mi><mi>k</mi></msub><annotation encoding="application/x-tex">\sigma_k</annotation></semantics></math>’s
are called the <em>Hankel singular values</em> of the statespace
realization since they are the singular values of the Hankel matrix of
the impulse response coefficients.</p>
<p>A <em>minimal</em> statespace realization for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>
then may simply computed by truncating the transformed matrices
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi><mo>,</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A,B,C</annotation></semantics></math>.
If we partition the (transformed) state space matrices (conformingly to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>)
as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>A</mi><mn>11</mn></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>A</mi><mn>12</mn></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>A</mi><mn>21</mn></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>A</mi><mn>22</mn></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="0.278em"></mspace><mi>B</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>B</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>B</mi><mn>2</mn></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> and </mtext><mspace width="0.333em"></mspace></mrow><mi>C</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>C</mi><mn>1</mn></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>C</mi><mn>2</mn></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
A = \begin{pmatrix}
A_{11} &amp; A_{12} \\
A_{21} &amp; A_{22}
\end{pmatrix}, \;
B = \begin{pmatrix}
B_{1} \\
B_{2}
\end{pmatrix} \mbox{ and }
C = \begin{pmatrix}
C_{1} &amp; C_2
\end{pmatrix}
</annotation></semantics></math> then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>C</mi><mn>1</mn></msub><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>z</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>I</mi><msub><mi>s</mi><mn>0</mn></msub></msub><mo>−</mo><msub><mi>A</mi><mn>11</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>B</mi><mn>1</mn></msub><mo>+</mo><mi>D</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">K(z) = C_1(z^{-1}I_{s_0} -A_{11})^{-1} B_1 + D)</annotation></semantics></math>
is a minimal statespace realization of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>.</p>
<p><code>balance(obj, P,Q, s0, truncate = FALSE)</code> computes a
somewhat simplified balanced form, where the two blocks
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mn>22</mn></msub><annotation encoding="application/x-tex">P_{22}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Q</mi><mn>22</mn></msub><annotation encoding="application/x-tex">Q_{22}</annotation></semantics></math>
are <em>not</em> diagonal.</p>
<p>There are three possible scenarios</p>
<ul>
<li>the paramater <code>s0</code> is equal to the rank of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>Q</mi></mrow><annotation encoding="application/x-tex">PQ</annotation></semantics></math>.
In this case
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>22</mn></msub><msub><mi>Q</mi><mn>22</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">P_{22}Q_{22} = 0</annotation></semantics></math>
(up to numerical errors).</li>
<li>the paramater <code>s0</code> is less than the rank of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>Q</mi></mrow><annotation encoding="application/x-tex">PQ</annotation></semantics></math>.
In this case
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>22</mn></msub><msub><mi>Q</mi><mn>22</mn></msub></mrow><annotation encoding="application/x-tex">P_{22}Q_{22}</annotation></semantics></math>
is not equal to zero.</li>
<li>the paramater <code>s0</code> is larger than the rank of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>Q</mi></mrow><annotation encoding="application/x-tex">PQ</annotation></semantics></math>.
In this case the procedure may throw an error.</li>
</ul>
<p>If the optional parameter <code>truncate=TRUE</code> then a
correspondingly truncated statespace realization is returned. In the
case that the paramater <code>s0</code> is less than the rank of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>Q</mi></mrow><annotation encoding="application/x-tex">PQ</annotation></semantics></math>
this truncated realization is only an approximate realization of the
rational matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>.
The approximation error depends on the size of the “neglected” singular
values. Note also that in this case the statespace realization returned
is not in balanced form, i.e. the Grammians of this realization are not
equal to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mn>11</mn></msub><annotation encoding="application/x-tex">P_{11}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Q</mi><mn>11</mn></msub><annotation encoding="application/x-tex">Q_{11}</annotation></semantics></math>.</p>
<p>If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>T</mi><mn>1</mn></msub><mi>′</mi><mo>,</mo><msub><mi>T</mi><mn>2</mn></msub><mi>′</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>′</mi></mrow><annotation encoding="application/x-tex">T=(T_1',T_2')'</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><msup><mi>T</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>S</mi><mn>1</mn></msub><mo>,</mo><msub><mi>S</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">S=T^{-1}=(S_1,S_2)</annotation></semantics></math>
denotes the statespace transformation, which gives the balanced form,
then the trancated system is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>11</mn></msub><mo>=</mo><msub><mi>T</mi><mn>1</mn></msub><mi>A</mi><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">A_{11}=T_1 A S_1</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mn>1</mn></msub><mo>=</mo><msub><mi>T</mi><mn>1</mn></msub><mi>B</mi></mrow><annotation encoding="application/x-tex">B_1=T_1 B</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub><mo>=</mo><mi>C</mi><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">C_1=CS_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo>=</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">D=D</annotation></semantics></math>.
Note also that in this case (<code>truncate=TRUE</code>) the procedure
just returns
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>T</mi><mn>1</mn></msub><annotation encoding="application/x-tex">T_1</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>S</mi><mn>1</mn></msub><annotation encoding="application/x-tex">S_1</annotation></semantics></math>
and not the “whole” transformation matrices.</p>
<p>If we call <code>balance(obj, P, Q, s0=NULL, tol, truncate)</code>
then the procedure tries to determine the rank
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>Q</mi></mrow><annotation encoding="application/x-tex">PQ</annotation></semantics></math>
by inspecting the computed singular values
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>σ</mi><mi>k</mi></msub><annotation encoding="application/x-tex">\sigma_k</annotation></semantics></math>.
To be precise
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>s</mi><mn>0</mn></msub><annotation encoding="application/x-tex">s_0</annotation></semantics></math>
is set to the number of singular values
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>σ</mi><mi>k</mi></msub><annotation encoding="application/x-tex">\sigma_k</annotation></semantics></math>
which are larger than <code>tol</code> times the largest singular value
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>σ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">\sigma_1</annotation></semantics></math>.
This strategy fails if <em>all</em> singular values are equal to zero
(up to numerical errors).</p>
<p>Above we have discussed balancing and balanced truncation for the
case of the controllabaility and the observability Grammian. This scheme
is sometimes called <em>Lyapunov balancing</em>. There are other
possible choices for a pair of Grammians, e.g. one may use the
controllabaility matrix and the observability matrix of the statespace
realization of the inverse
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>K</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><annotation encoding="application/x-tex">K^{-1}</annotation></semantics></math>,
i.e.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo>−</mo><mi>B</mi><msup><mi>D</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>C</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>′</mi><mi>Q</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo>−</mo><mi>B</mi><msup><mi>D</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>C</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>C</mi><mi>′</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">
Q = (A-BD^{-1}C)' Q (A-BD^{-1}C) + C'C
</annotation></semantics></math></p>
<p>Of course for this choice the rational marix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>
must be <em>minimum phase</em>, i.e. the moduli of the eigenvalues of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>−</mo><mi>B</mi><msup><mi>D</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>C</mi></mrow><annotation encoding="application/x-tex">A-BD^{-1}C</annotation></semantics></math>
must be smaller than one. This balancing scheme is therefore called
<em>minimum phase balancing</em>.</p>
<p>Some details on how the balanced form is actually computed is given
in the vignette “Technical Details”.</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># example A ############################################################</span></span>
<span></span>
<span><span class="co"># "obj" is a (1 by 1) rational matrix in statespace form,</span></span>
<span><span class="co"># with stespace dimension s = 2.</span></span>
<span></span>
<span><span class="va">obj</span> <span class="op">=</span> <span class="fu"><a href="../reference/stsp.html">stsp</a></span><span class="op">(</span>A <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0.2</span>,<span class="fl">1</span>,<span class="op">-</span><span class="fl">0.5</span><span class="op">)</span>,</span>
<span>           B <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">1</span><span class="op">)</span>, C <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">0</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">gr</span> <span class="op">=</span> <span class="fu"><a href="../reference/grammians.html">grammians</a></span><span class="op">(</span><span class="va">obj</span>, <span class="st">'lyapunov'</span><span class="op">)</span></span>
<span><span class="va">bal</span> <span class="op">=</span> <span class="fu"><a href="../reference/balance.html">balance</a></span><span class="op">(</span><span class="va">obj</span>, <span class="va">gr</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="va">bal</span><span class="op">$</span><span class="va">P</span>, <span class="va">bal</span><span class="op">$</span><span class="va">Q</span>, <span class="fu"><a href="https://rdrr.io/r/base/diag.html" class="external-link">diag</a></span><span class="op">(</span><span class="va">bal</span><span class="op">$</span><span class="va">sigma</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;          [,1]     [,2]     [,3]     [,4]     [,5]     [,6]</span></span>
<span><span class="co">#&gt; [1,] 1.586904 0.000000 1.586904 0.000000 1.586904 0.000000</span></span>
<span><span class="co">#&gt; [2,] 0.000000 1.458699 0.000000 1.458699 0.000000 1.458699</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="fu"><a href="../reference/grammians.html">grammians</a></span><span class="op">(</span><span class="va">bal</span><span class="op">$</span><span class="va">obj</span><span class="op">)</span>, <span class="va">bal</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">'P'</span>,<span class="st">'Q'</span><span class="op">)</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span>
<span></span>
<span><span class="co"># example B (non minimal statespace realization #########################</span></span>
<span></span>
<span><span class="co"># The "rbind" operation below returns a statespace realization with</span></span>
<span><span class="co"># statespace dimension s = 4. However the minimal statespace dimensions</span></span>
<span><span class="co"># is s0 = 2.</span></span>
<span><span class="va">obj</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">rbind</a></span><span class="op">(</span><span class="va">obj</span>, <span class="va">obj</span><span class="op">)</span></span>
<span><span class="va">gr</span> <span class="op">=</span> <span class="fu"><a href="../reference/grammians.html">grammians</a></span><span class="op">(</span><span class="va">obj</span>, <span class="st">'lyapunov'</span><span class="op">)</span></span>
<span><span class="va">bal</span> <span class="op">=</span> <span class="fu"><a href="../reference/balance.html">balance</a></span><span class="op">(</span><span class="va">obj</span>, <span class="va">gr</span>, s0 <span class="op">=</span> <span class="fl">2</span>, truncate <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># the upper (2 by 2) block of the (transformed) controllability</span></span>
<span><span class="co"># Grammian is diagonal, the lower (2 by 2) block is "zero".</span></span>
<span><span class="co"># This shows that the (balanced) realization is not controllable.</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">bal</span><span class="op">$</span><span class="va">P</span><span class="op">)</span>  </span>
<span><span class="co">#&gt;          [,1]     [,2]         [,3]         [,4]</span></span>
<span><span class="co">#&gt; [1,] 2.244221 0.000000 0.000000e+00 0.000000e+00</span></span>
<span><span class="co">#&gt; [2,] 0.000000 2.062912 0.000000e+00 0.000000e+00</span></span>
<span><span class="co">#&gt; [3,] 0.000000 0.000000 2.535741e-33 6.600794e-33</span></span>
<span><span class="co">#&gt; [4,] 0.000000 0.000000 6.600794e-33 2.939217e-32</span></span>
<span></span>
<span><span class="co"># the upper (2 by 2) block of the (transformed) observability</span></span>
<span><span class="co"># Grammian is diagonal and equal to the upper block of bal$P.</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">bal</span><span class="op">$</span><span class="va">Q</span><span class="op">)</span></span>
<span><span class="co">#&gt;          [,1]     [,2]       [,3]       [,4]</span></span>
<span><span class="co">#&gt; [1,] 2.244221 0.000000  0.0000000  0.0000000</span></span>
<span><span class="co">#&gt; [2,] 0.000000 2.062912  0.0000000  0.0000000</span></span>
<span><span class="co">#&gt; [3,] 0.000000 0.000000  1.4464176 -0.3808884</span></span>
<span><span class="co">#&gt; [4,] 0.000000 0.000000 -0.3808884  1.3313601</span></span>
<span></span>
<span><span class="co"># the product of the (transformed) controllability and observability</span></span>
<span><span class="co"># Grammians is (approximately) diagonal and the diagonal entries are  </span></span>
<span><span class="co"># the squares of the Hankel singular values.</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">bal</span><span class="op">$</span><span class="va">P</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">bal</span><span class="op">$</span><span class="va">Q</span><span class="op">)</span></span>
<span><span class="co">#&gt;          [,1]     [,2]          [,3]         [,4]</span></span>
<span><span class="co">#&gt; [1,] 5.036528 0.000000  0.000000e+00 0.000000e+00</span></span>
<span><span class="co">#&gt; [2,] 0.000000 4.255604  0.000000e+00 0.000000e+00</span></span>
<span><span class="co">#&gt; [3,] 0.000000 0.000000  1.153575e-33 7.822199e-33</span></span>
<span><span class="co">#&gt; [4,] 0.000000 0.000000 -1.647632e-33 3.661739e-32</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">bal</span><span class="op">$</span><span class="va">sigma</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span>    </span>
<span><span class="co">#&gt; [1] 5.036528e+00 4.255604e+00 2.792358e-17 5.975078e-33</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="fu"><a href="../reference/grammians.html">grammians</a></span><span class="op">(</span><span class="va">bal</span><span class="op">$</span><span class="va">obj</span><span class="op">)</span>, <span class="va">bal</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">'P'</span>,<span class="st">'Q'</span><span class="op">)</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span>
<span></span>
<span><span class="co"># we may construct a minimal realization by 'balanced truncation'.</span></span>
<span><span class="co"># note that we let the procedure determine the minimal statespace dimension</span></span>
<span><span class="va">trunc</span> <span class="op">=</span> <span class="fu"><a href="../reference/balance.html">balance</a></span><span class="op">(</span><span class="va">obj</span>, <span class="va">gr</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">trunc</span><span class="op">$</span><span class="va">obj</span><span class="op">)</span></span>
<span><span class="co">#&gt; statespace realization [2,1] with s = 2 states</span></span>
<span><span class="co">#&gt;            s[1]       s[2]       u[1]</span></span>
<span><span class="co">#&gt; s[1]  0.3498560  0.3119731 -1.3299446</span></span>
<span><span class="co">#&gt; s[2] -0.3119731 -0.8498560 -0.5954318</span></span>
<span><span class="co">#&gt; x[1] -0.9404128  0.4210339  1.0000000</span></span>
<span><span class="co">#&gt; x[2] -0.9404128  0.4210339  1.0000000</span></span>
<span><span class="co"># compare with the above balanced realization</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">bal</span><span class="op">$</span><span class="va">obj</span><span class="op">)</span></span>
<span><span class="co">#&gt; statespace realization [2,1] with s = 4 states</span></span>
<span><span class="co">#&gt;               s[1]          s[2]          s[3]          s[4]          u[1]</span></span>
<span><span class="co">#&gt; s[1]  3.498560e-01  3.119731e-01  2.966202e-17 -2.542543e-17 -1.329945e+00</span></span>
<span><span class="co">#&gt; s[2] -3.119731e-01 -8.498560e-01 -6.729309e-17  1.299258e-17 -5.954318e-01</span></span>
<span><span class="co">#&gt; s[3] -9.041099e-19 -3.500935e-17 -6.872820e-01  8.809205e-01 -5.551115e-17</span></span>
<span><span class="co">#&gt; s[4]  8.747771e-17 -2.948488e-17  8.092046e-02  1.872820e-01 -1.665335e-16</span></span>
<span><span class="co">#&gt; x[1] -9.404128e-01  4.210339e-01 -5.967029e-01 -3.794017e-01  1.000000e+00</span></span>
<span><span class="co">#&gt; x[2] -9.404128e-01  4.210339e-01  5.967029e-01  3.794017e-01  1.000000e+00</span></span>
<span><span class="co"># check</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="fu"><a href="../reference/pseries.html">pseries</a></span><span class="op">(</span><span class="va">obj</span><span class="op">)</span>, <span class="fu"><a href="../reference/pseries.html">pseries</a></span><span class="op">(</span><span class="va">trunc</span><span class="op">$</span><span class="va">obj</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span>
<span></span>
<span><span class="co"># example C (balanced truncation) ##########################</span></span>
<span></span>
<span><span class="co"># construct a random rational matrix with statespace dimension s=10</span></span>
<span><span class="va">obj</span> <span class="op">=</span> <span class="fu"><a href="../reference/test_stsp.html">test_stsp</a></span><span class="op">(</span>dim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span>, s <span class="op">=</span> <span class="fl">10</span>, bpoles <span class="op">=</span> <span class="fl">1</span>, bzeroes <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="co"># compute an approximate realization with s0 = 8</span></span>
<span><span class="va">gr</span> <span class="op">=</span> <span class="fu"><a href="../reference/grammians.html">grammians</a></span><span class="op">(</span><span class="va">obj</span>, <span class="st">'minimum phase'</span><span class="op">)</span></span>
<span><span class="va">trunc</span> <span class="op">=</span> <span class="fu"><a href="../reference/balance.html">balance</a></span><span class="op">(</span><span class="va">obj</span>, <span class="va">gr</span>, s0 <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">trunc</span><span class="op">$</span><span class="va">sigma</span><span class="op">)</span></span>
<span><span class="co">#&gt;  [1] 0.580904673 0.492973132 0.426651235 0.310246516 0.195965988 0.099126844</span></span>
<span><span class="co">#&gt;  [7] 0.073988375 0.035596157 0.007667147 0.004493532</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">abs</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/class.html" class="external-link">unclass</a></span><span class="op">(</span><span class="fu"><a href="../reference/pseries.html">pseries</a></span><span class="op">(</span><span class="va">obj</span>, lag.max <span class="op">=</span> <span class="fl">25</span><span class="op">)</span><span class="op">)</span> <span class="op">-</span></span>
<span>        <span class="fu"><a href="https://rdrr.io/r/base/class.html" class="external-link">unclass</a></span><span class="op">(</span><span class="fu"><a href="../reference/pseries.html">pseries</a></span><span class="op">(</span><span class="va">trunc</span><span class="op">$</span><span class="va">ob</span>, lag.max <span class="op">=</span> <span class="fl">25</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.03225343</span></span></code></pre></div>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="fu"><a href="../reference/pseries.html">pseries</a></span><span class="op">(</span><span class="va">obj</span>, lag.max <span class="op">=</span> <span class="fl">25</span><span class="op">)</span>, x_list<span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="fu"><a href="../reference/pseries.html">pseries</a></span><span class="op">(</span><span class="va">trunc</span><span class="op">$</span><span class="va">obj</span>, lag.max <span class="op">=</span> <span class="fl">25</span><span class="op">)</span><span class="op">)</span>,</span>
<span>     type <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">'l'</span>,<span class="st">'p'</span><span class="op">)</span>, legend <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">'s=10'</span>, <span class="st">'s=5'</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="a_rational_matrices_files/figure-html/unnamed-chunk-37-1.png" class="r-plt" alt="Comparison of full impulse response and balanced truncated impulse response showing approximation quality" width="700"></p>
</div>
<div class="section level3">
<h3 id="reflect-poles-or-zeroes-by-multiplication-with-all-pass-matrices">Reflect Poles or Zeroes by Multiplication with All Pass
Matrices<a class="anchor" aria-label="anchor" href="#reflect-poles-or-zeroes-by-multiplication-with-all-pass-matrices"></a>
</h3>
<p>The algorithm outlined in “<a href="#blaschke">Reflect Zeroes by
Multiplication with All Pass Matrices</a>” to flip the zeroes of a
multivariate polynomial matrix has a statespace analogon. Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>C</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>z</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>I</mi><mo>−</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>B</mi><mo>+</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">K(z)=C(z^{-1}I-A)^{-1}B+D</annotation></semantics></math>
be a square, rational matrix in statespace form and suppose that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>α</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\alpha_1,\ldots,\alpha_k</annotation></semantics></math>
are zeroes of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">K(z)</annotation></semantics></math>.
There exists an allpass (rational) function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">U(z)</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><msup><mi>U</mi><mo>*</mo></msup><mo>=</mo><msup><mi>U</mi><mo>*</mo></msup><mi>U</mi><mo>=</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">UU^*=U^*U=I</annotation></semantics></math>
such that<br><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>U</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">K(z)U(z)</annotation></semantics></math>
is a rational matrix, where the roots
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\alpha_i</annotation></semantics></math>
have been replaced by the “flipped” roots
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>/</mi><msub><mover><mi>α</mi><mo accent="true">‾</mo></mover><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">1/\bar{\alpha}_i</annotation></semantics></math>.
Both
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi>U</mi></mrow><annotation encoding="application/x-tex">KU</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>
have a statespace realization, which is computed by the routine
<code><a href="../reference/reflect_zeroes.html">reflect_zeroes()</a></code>.</p>
<p>Quite analogously one may also mirror the poles of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>.</p>
<p>The construction of the allpass function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>
is outlined in the vignette “technical details”.</p>
</div>
<div class="section level3">
<h3 id="h2-norm-and-orthogonalization">H2 norm and orthogonalization<a class="anchor" aria-label="anchor" href="#h2-norm-and-orthogonalization"></a>
</h3>
<p>Create a vector of rational functions of the form
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>/</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mn>0.9</mn><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">1/(1-0.9z)^k</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">k=1,2,3,4</annotation></semantics></math>:</p>
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">K0</span> <span class="op">=</span> <span class="fu"><a href="../reference/polm.html">polm</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="op">-</span><span class="fl">0.9</span><span class="op">)</span><span class="op">)</span><span class="op">^</span><span class="op">(</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">K</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">rbind</a></span><span class="op">(</span><span class="va">K0</span>,</span>
<span>          <span class="va">K0</span><span class="op">^</span><span class="fl">2</span>,</span>
<span>          <span class="va">K0</span><span class="op">^</span><span class="fl">3</span>,</span>
<span>          <span class="va">K0</span><span class="op">^</span><span class="fl">4</span><span class="op">)</span></span></code></pre></div>
<p>The statespac realization (<code>K</code>) is not minimal. (Minimal
state dimension is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">s=4</annotation></semantics></math>.)
Use balance to construct a minimal realization:</p>
<div class="sourceCode" id="cb38"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># K is not minimal! minimal state dimension = 4</span></span>
<span><span class="va">gr</span> <span class="op">=</span> <span class="fu"><a href="../reference/grammians.html">grammians</a></span><span class="op">(</span><span class="va">K</span>, <span class="st">'lyapunov'</span><span class="op">)</span></span>
<span><span class="va">out</span> <span class="op">=</span> <span class="fu"><a href="../reference/balance.html">balance</a></span><span class="op">(</span><span class="va">K</span>, <span class="va">gr</span>, s <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">sigma</span><span class="op">)</span></span>
<span><span class="co">#&gt;  [1] 6.876057e+03 2.133678e+03 2.994808e+02 1.691065e+01 2.725611e-06</span></span>
<span><span class="co">#&gt;  [6] 9.858547e-07 2.501328e-07 1.723756e-07 1.190414e-13 6.719293e-14</span></span>
<span><span class="co"># check</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="fu"><a href="../reference/zvalues.html">zvalues</a></span><span class="op">(</span><span class="va">K</span>, n.f <span class="op">=</span> <span class="fl">2</span><span class="op">^</span><span class="fl">6</span><span class="op">)</span>, <span class="fu"><a href="../reference/zvalues.html">zvalues</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">obj</span>, n.f <span class="op">=</span> <span class="fl">2</span><span class="op">^</span><span class="fl">6</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span>
<span></span>
<span><span class="va">K</span> <span class="op">=</span> <span class="va">out</span><span class="op">$</span><span class="va">obj</span></span></code></pre></div>
<p>Orthormalize the components of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>
with respect to the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>2</mn></msub><annotation encoding="application/x-tex">H_2</annotation></semantics></math>
inner product.</p>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">P</span> <span class="op">=</span> <span class="fu"><a href="../reference/lyapunov.html">lyapunov</a></span><span class="op">(</span><span class="va">K</span><span class="op">$</span><span class="va">A</span>, <span class="va">K</span><span class="op">$</span><span class="va">B</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">K</span><span class="op">$</span><span class="va">B</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">Q</span> <span class="op">=</span> <span class="va">K</span><span class="op">$</span><span class="va">C</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">P</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">K</span><span class="op">$</span><span class="va">C</span><span class="op">)</span> <span class="op">+</span> <span class="va">K</span><span class="op">$</span><span class="va">D</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">K</span><span class="op">$</span><span class="va">D</span><span class="op">)</span></span>
<span></span>
<span><span class="va">K0</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/solve.html" class="external-link">solve</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/chol.html" class="external-link">chol</a></span><span class="op">(</span><span class="va">Q</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="op"><a href="../reference/ratm_mult.html">%r%</a></span> <span class="va">K</span></span>
<span><span class="va">K0</span></span>
<span><span class="co">#&gt; statespace realization [4,1] with s = 4 states</span></span>
<span><span class="co">#&gt;              s[1]         s[2]        s[3]         s[4]        u[1]</span></span>
<span><span class="co">#&gt; s[1]  0.987214209  0.040644523 -0.01291412  0.002910154 -13.0817697</span></span>
<span><span class="co">#&gt; s[2] -0.040708578  0.943474772  0.06640124 -0.011901623 -14.8888604</span></span>
<span><span class="co">#&gt; s[3] -0.013472533 -0.067431696  0.87486975  0.066882649  -7.6963271</span></span>
<span><span class="co">#&gt; s[4] -0.003765234 -0.014720809 -0.07238612  0.794441274  -2.0269817</span></span>
<span><span class="co">#&gt; x[1] -0.007922199 -0.012583407 -0.01155208 -0.006119112   0.4358899</span></span>
<span><span class="co">#&gt; x[2] -0.008403204  0.006876849  0.02867369  0.028174871  -0.3923009</span></span>
<span><span class="co">#&gt; x[3] -0.002982258  0.015426702 -0.02592047 -0.078870839   0.3530708</span></span>
<span><span class="co">#&gt; x[4] -0.001299696  0.001345163 -0.03521625  0.174025836  -0.3177637</span></span>
<span></span>
<span><span class="co"># check</span></span>
<span><span class="va">P</span> <span class="op">=</span> <span class="fu"><a href="../reference/lyapunov.html">lyapunov</a></span><span class="op">(</span><span class="va">K0</span><span class="op">$</span><span class="va">A</span>, <span class="va">K0</span><span class="op">$</span><span class="va">B</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">K0</span><span class="op">$</span><span class="va">B</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">Q</span> <span class="op">=</span> <span class="va">K0</span><span class="op">$</span><span class="va">C</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">P</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">K0</span><span class="op">$</span><span class="va">C</span><span class="op">)</span> <span class="op">+</span> <span class="va">K0</span><span class="op">$</span><span class="va">D</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">K0</span><span class="op">$</span><span class="va">D</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="va">Q</span>, <span class="fu"><a href="https://rdrr.io/r/base/diag.html" class="external-link">diag</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<p>Plot frequency response</p>
<div class="sourceCode" id="cb40"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fr</span> <span class="op">=</span> <span class="fu"><a href="../reference/zvalues.html">zvalues</a></span><span class="op">(</span><span class="va">K0</span>, n.f <span class="op">=</span> <span class="fl">2</span><span class="op">^</span><span class="fl">12</span><span class="op">)</span></span>
<span><span class="va">fr0</span> <span class="op">=</span> <span class="fu"><a href="../reference/zvalues.html">zvalues</a></span><span class="op">(</span><span class="va">K0</span>, n.f <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span>
<span><span class="va">legend</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/expression.html" class="external-link">expression</a></span><span class="op">(</span><span class="va">K</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/expression.html" class="external-link">expression</a></span><span class="op">(</span><span class="va">K</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/expression.html" class="external-link">expression</a></span><span class="op">(</span><span class="va">K</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/expression.html" class="external-link">expression</a></span><span class="op">(</span><span class="va">K</span><span class="op">[</span><span class="fl">4</span><span class="op">]</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fr</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">1</span><span class="op">]</span>, x_list <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">fr</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">]</span>, <span class="va">fr</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">1</span><span class="op">]</span>, <span class="va">fr</span><span class="op">[</span><span class="fl">4</span>,<span class="fl">1</span><span class="op">]</span><span class="op">)</span>, which <span class="op">=</span> <span class="st">'modulus'</span>,</span>
<span>     legend <span class="op">=</span> <span class="va">legend</span><span class="op">)</span></span></code></pre></div>
<p><img src="a_rational_matrices_files/figure-html/unnamed-chunk-41-1.png" class="r-plt" alt="Frequency response plots showing modulus, phase, and Nyquist diagrams for rational transfer functions" width="576"></p>
<div class="sourceCode" id="cb41"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fr</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">1</span><span class="op">]</span>, x_list <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">fr</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">]</span>, <span class="va">fr</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">1</span><span class="op">]</span>, <span class="va">fr</span><span class="op">[</span><span class="fl">4</span>,<span class="fl">1</span><span class="op">]</span><span class="op">)</span>, which <span class="op">=</span> <span class="st">'phase'</span>,</span>
<span>     legend <span class="op">=</span> <span class="va">legend</span><span class="op">)</span></span></code></pre></div>
<p><img src="a_rational_matrices_files/figure-html/unnamed-chunk-41-2.png" class="r-plt" alt="Frequency response plots showing modulus, phase, and Nyquist diagrams for rational transfer functions" width="576"></p>
<div class="sourceCode" id="cb42"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fr</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">1</span><span class="op">]</span>, x_list <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">fr</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">]</span>, <span class="va">fr</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">1</span><span class="op">]</span>, <span class="va">fr</span><span class="op">[</span><span class="fl">4</span>,<span class="fl">1</span><span class="op">]</span><span class="op">)</span>, which <span class="op">=</span> <span class="st">'nyquist'</span>,</span>
<span>     legend <span class="op">=</span> <span class="va">legend</span><span class="op">)</span></span></code></pre></div>
<p><img src="a_rational_matrices_files/figure-html/unnamed-chunk-41-3.png" class="r-plt" alt="Frequency response plots showing modulus, phase, and Nyquist diagrams for rational transfer functions" width="576"></p>
<div class="sourceCode" id="cb43"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span></span>
<span><span class="va">subfigures.main</span> <span class="op">=</span> <span class="va">legend</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/dim.html" class="external-link">dim</a></span><span class="op">(</span><span class="va">subfigures.main</span><span class="op">)</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="va">fr</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">]</span>, <span class="va">fr</span><span class="op">[</span><span class="fl">3</span><span class="op">:</span><span class="fl">4</span>,<span class="fl">1</span><span class="op">]</span><span class="op">)</span>,</span>
<span>     x_list <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="va">fr0</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">]</span>, <span class="va">fr0</span><span class="op">[</span><span class="fl">3</span><span class="op">:</span><span class="fl">4</span>,<span class="fl">1</span><span class="op">]</span><span class="op">)</span><span class="op">)</span>,</span>
<span>     type <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">'l'</span>,<span class="st">'p'</span><span class="op">)</span>, cex.points <span class="op">=</span> <span class="fl">0.1</span>, col <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">'red'</span>,<span class="st">'black'</span><span class="op">)</span>, pch <span class="op">=</span> <span class="fl">20</span>,</span>
<span>     which <span class="op">=</span> <span class="st">'nyquist'</span>, subfigures.main <span class="op">=</span> <span class="va">subfigures.main</span><span class="op">)</span></span></code></pre></div>
<p><img src="a_rational_matrices_files/figure-html/unnamed-chunk-41-4.png" class="r-plt" alt="Frequency response plots showing modulus, phase, and Nyquist diagrams for rational transfer functions" width="576"></p>
<p>Compute reduced order model (s = 3)</p>
<div class="sourceCode" id="cb44"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">gr</span> <span class="op">=</span> <span class="fu"><a href="../reference/grammians.html">grammians</a></span><span class="op">(</span><span class="va">K0</span>, <span class="st">'lyapunov'</span><span class="op">)</span></span>
<span><span class="va">out</span> <span class="op">=</span> <span class="fu"><a href="../reference/balance.html">balance</a></span><span class="op">(</span><span class="va">K0</span>, <span class="va">gr</span>, s <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">sigma</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 6.645557 4.594142 2.803345 1.040294</span></span>
<span><span class="va">Kh</span> <span class="op">=</span> <span class="va">out</span><span class="op">$</span><span class="va">obj</span></span>
<span><span class="va">frh</span> <span class="op">=</span> <span class="fu"><a href="../reference/zvalues.html">zvalues</a></span><span class="op">(</span><span class="va">Kh</span>, n.f <span class="op">=</span> <span class="fl">2</span><span class="op">^</span><span class="fl">12</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="va">fr</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">]</span>, <span class="va">fr</span><span class="op">[</span><span class="fl">3</span><span class="op">:</span><span class="fl">4</span>,<span class="fl">1</span><span class="op">]</span><span class="op">)</span>,</span>
<span>     x_list <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="va">frh</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">]</span>, <span class="va">frh</span><span class="op">[</span><span class="fl">3</span><span class="op">:</span><span class="fl">4</span>,<span class="fl">1</span><span class="op">]</span><span class="op">)</span><span class="op">)</span>,</span>
<span>     which <span class="op">=</span> <span class="st">'nyquist'</span>, subfigures.main <span class="op">=</span> <span class="va">subfigures.main</span>,</span>
<span>     legend <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/expression.html" class="external-link">expression</a></span><span class="op">(</span><span class="va">K</span><span class="op">[</span><span class="va">i</span><span class="op">]</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/expression.html" class="external-link">expression</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/influence.measures.html" class="external-link">hat</a></span><span class="op">(</span><span class="va">K</span><span class="op">)</span><span class="op">[</span><span class="va">i</span><span class="op">]</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="a_rational_matrices_files/figure-html/unnamed-chunk-42-1.png" class="r-plt" alt="Nyquist plot comparison of full frequency response and balanced truncated approximation" width="576"></p>
</div>
</div>
<div class="section level2">
<h2 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-Al-Sadoon2017" class="csl-entry">
Al-Sadoon, Majid M. 2017. <span>“<span class="nocase">The Linear Systems
Approach to Linear Rational Expectations Models</span>.”</span>
<em>Econometric Theory</em>, 1–31. <a href="https://doi.org/10.1017/S0266466617000160" class="external-link">https://doi.org/10.1017/S0266466617000160</a>.
</div>
<div id="ref-Hannan.Deistler12" class="csl-entry">
Hannan, Edward James, and Manfred Deistler. 2012. <em><span class="nocase">The Statistical Theory of Linear Systems</span></em>.
Classics in Applied Mathematics. Philadelphia: SIAM.
</div>
<div id="ref-Ho.Kalman66" class="csl-entry">
Ho, B., and R. E. Kalman. 1966. <span>“<span class="nocase">Efficient
Construction of Linear State Variable Models From Input/Output
Functions</span>.”</span> <em>Regelungstechnik</em> 14: 545–48.
</div>
<div id="ref-Kailath80" class="csl-entry">
Kailath, Thomas. 1980. <em><span>Linear Systems</span></em>. Englewood
Cliffs, New Jersey: Prentice Hall.
</div>
</div>
</div>

  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by <a href="https://scholar.google.com/citations?user=-Ytb9BYAAAAJ" class="external-link">Wolfgang Scherrer</a>, <a href="https://ch.linkedin.com/in/bernd-funovits-phd-cfa-a8215016" class="external-link">Bernd Funovits</a>.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.2.0.</p>
</div>

    </footer>
</div>





  </body>
</html>
