% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/reflect_poles_zeroes.R
\name{reflect_poles}
\alias{reflect_poles}
\alias{reflect_poles.stsp}
\alias{reflect_poles.rmfd}
\title{Reflect Poles of Rational Matrices}
\usage{
reflect_poles(x, poles, ...)

\method{reflect_poles}{stsp}(x, poles, tol = sqrt(.Machine$double.eps), ...)

\method{reflect_poles}{rmfd}(
  x,
  poles,
  tol = sqrt(.Machine$double.eps),
  check_poles = TRUE,
  ...
)
}
\arguments{
\item{x}{Square, rational matrix object (with real coefficients).}

\item{poles}{Complex or real vector of poles to be reflected. 
It is assumed that for complex conjugated pairs of poles, 
only \bold{one} is contained in this vector.}

\item{...}{Not used.}

\item{tol}{(double) Tolerance parameter used for the checks.}

\item{check_poles}{If \code{TRUE} then the procedure checks that the 
given poles are poles of the rational matrix x(z).}
}
\value{
Rational matrix object which represents the rational matrix 
        \eqn{x(z)U(z)} with the reflected poles. The object is of the 
        same class as the input object \code{x}.
}
\description{
Given a square, rational matrix \eqn{x(z)} and a set of poles of \eqn{x(z)}, 
the function \code{reflect_poles} constructs an allpass matrix \eqn{U(z)} 
such that \eqn{x(z)U(z)} has poles which are the reciprocals of the 
selected poles and the other poles are not changed. 
Also the zeroes are not changed, i.e. \eqn{x} and \eqn{xU} have the same zeroes.
}
\note{
The procedures are only implemented for rational matrices with real coefficients. 
Therefore complex poles occur in complex conjugated pairs and such pairs are
\bold{jointly} reflected to ensure that the result again has real coefficients. 
Note however, that the argument \code{poles} must only contain \bold{one} element 
of the pairs to be reflected.
 
In some degnerate cases the procedure(s) may run into numerical problems: 
For matrices in \code{rmfd} form, 
the procedure assumes that the matrix has no poles at \eqn{z=0}. 
For the matrices in statespace form, poles 
on (or close to) the unit circle are not allowed. In addition multiple 
poles may lead to unreliable results.
}
\examples{
# ###################################################################
# rational matrix in statespace form ('stsp' object)

set.seed(12345)
# create random (2,2) rational matrix in state space form 
# with state dimension s=5
( x = test_stsp(dim = c(2,2), s = 5) )
# poles of x(z)
( x_poles = poles(x) )

# reflect all unstable poles (inside the unit circle) ###########
# note: for complex zeroes, select only one of the complex conjugated pair!
x1 = reflect_poles(x, poles = x_poles[(abs(x_poles) < 1) & (Im(x_poles) >= 0)])

r_poles = x_poles
r_poles[abs(r_poles) < 1] = 1 / r_poles[abs(r_poles) < 1]
(x1_poles = poles(x1))
j = match_vectors(r_poles, x1_poles)
all.equal(r_poles, x1_poles[j]) 

# Check that the transformation matrix U (x1 = x \%r\% U) is all-pass
all.equal(zvalues(x) \%r\% Ht(zvalues(x)), zvalues(x1) \%r\% Ht(zvalues(x1)))

set.seed(NULL)


# ###################################################################
# rational matrix in RMFD form

set.seed(12345)
# create random (2 x 2) rational matrix in RMFD form with degrees (2,1)
( x = test_rmfd(dim = c(2,2), degree = c(2,1)) )
# poles of x(z)
( x_poles = poles(x) )

# reflect all unstable poles (inside the unit circle) ###########
# note: for complex zeroes, select only one of the complex conjugated pair!
x1 = reflect_poles(x, poles = x_poles[(abs(x_poles) < 1) & (Im(x_poles) >= 0)])

r_poles = x_poles
r_poles[abs(r_poles) < 1] = 1 / r_poles[abs(r_poles) < 1]
(x1_poles = poles(x1))
j = match_vectors(r_poles, x1_poles)
all.equal(r_poles, x1_poles[j]) 

# Check that the transformation matrix U (x1 = x \%r\% U) is all-pass
all.equal(zvalues(x) \%r\% Ht(zvalues(x)), zvalues(x1) \%r\% Ht(zvalues(x1)))

set.seed(NULL)
}
\seealso{
The procedure uses the helper functions \code{\link{blaschke}} 
         and \code{\link{make_allpass}}. For reflecting zeroes, 
         see \code{\link{reflect_zeroes}}.
}
