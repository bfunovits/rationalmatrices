% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/poles_and_zeroes.R
\name{poles and zeroes}
\alias{poles and zeroes}
\alias{poles}
\alias{zeroes}
\alias{zeroes.polm}
\alias{zeroes.lpolm}
\alias{zeroes.lmfd}
\alias{zeroes.rmfd}
\alias{zeroes.stsp}
\alias{poles.polm}
\alias{poles.lmfd}
\alias{poles.rmfd}
\alias{poles.stsp}
\title{Poles and Zeroes}
\usage{
poles(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)

zeroes(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)

\method{zeroes}{polm}(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)

\method{zeroes}{lpolm}(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)

\method{zeroes}{lmfd}(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)

\method{zeroes}{rmfd}(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)

\method{zeroes}{stsp}(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)

\method{poles}{polm}(x, ...)

\method{poles}{lmfd}(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)

\method{poles}{rmfd}(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)

\method{poles}{stsp}(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)
}
\arguments{
\item{x}{an object which represents a rational matrix 
(i.e. a \code{\link{polm}}, \code{\link{lmfd}} or \code{\link{stsp}} object).}

\item{tol}{Double. Default set to \code{sqrt(.Machine$double.eps)}.
Required to decide on when a root is to be considered "at infinity".}

\item{print_message}{Boolean. Default set to TRUE.
Prints a message if roots "at infinity " are discarded.}

\item{...}{not used.}
}
\value{
Vector of poles, respectively zeroes.
}
\description{
Compute the poles and zeroes of a rational matrix. For polynomial matrices and rational matrices 
in left matrix fraction form the poles (and zeroes) are computed via the (reciprocals of the) 
eigenvalues of the associated companion matrices, see also \code{\link{companion_matrix}}. 
For statespace realizations the poles are computed via (the reciprocals of) the 
eigenvalues of the state transition matrix \eqn{A} and for the zeroes 
the eigenvalues of the state transition matrix \eqn{A-BD^{-1}C} of the inverse are used.
}
\details{
The methods do not return numerically reliable and correct results in all cases. 
For some more details see the vignette \href{../doc/rational_matrices.html}{Rational Matrices}. 

\itemize{
\item Zeroes are only computed for square, non singular matrices which have no zero 
      at \eqn{z=0}. If the matrix evaluated at \eqn{z=0} is close to singular, 
      the results may be unreliable. 
\item The procedures use a threshold \code{tol} in order to decide whether 
      a small eigenvalue returned by \code{\link{eigen}} corresponds to 
      a "true zero" eigenvalue or not. 
\item If the pair \eqn{a,b} of polynomials of the LMFD is not left coprime then 
      a pole/zero cancellation occurs. This is not taken into account by the procedures. Hence, 
      in this case, the results also contain some spurious poles/zeroes. This happens 
      also for non minimal state space realizations.      
}
}
\examples{
 
# zeroes of polynomial matrices #############################################

# scalar polynomial ###
(a = polm(c(1, 0, 0, 0.5, 0)))
(z = zeroes(a))

# compare with the result of "polyroot"
all.equal(sort(z), sort(polyroot(as.vector(a))))

# zero degree polynomial (have no zeroes) ###
zeroes(polm(diag(3)))

# (2 x 2) polynomial of degree 2 ### 
a = polm(dbind(d = 3, diag(2), test_array(dim = c(2,2,2))))
(z = zeroes(a))

# check the rank of a(z) at the computed zeroes 
az = zvalues(a, z)
apply(az, MARGIN = 3, FUN = function(x) {d = svd(x)$d; min(d)/max(d)})

\dontrun{
# the following examples throw an error
zeroes(polm(c(0, 0, 0, 0.5))) # constant term is zero
zeroes(polm(test_array(dim = c(2, 1, 3)))) # non-square polynomial
zeroes(polm(test_array(dim = c(2, 2, 0)))) # zero polynomial
}
 
# zeroes of a Laurent polynomial #################################
(lp = lpolm(1:5, min_deg = -7))
(p = polm(1:5))
zeroes(p)
zeroes(lp)
 
# zeroes of a rational matrix in LMFD form #################################

c = lmfd(test_polm(dim = c(2,2), degree = 3, random = TRUE),
         test_polm(dim = c(2,2), degree = 1, random = TRUE))
(z = zeroes(c))
all.equal(z, zeroes(c$b))
 
# zeroes of a rational matrix in RMFD form #################################

k = rmfd(c = test_polm(dim = c(2,2), degree = 3, random = TRUE),
         d = test_polm(dim = c(2,2), degree = 1, random = TRUE))
(z = zeroes(k))
all.equal(z, zeroes(k$d))
 
# zeroes of a rational matrix in statespace form ###########################

k = stsp(A = matrix(rnorm(3*3), nrow = 3, ncol = 3),
         B = matrix(rnorm(3*2), nrow = 3, ncol = 2),
         C = matrix(rnorm(3*2), nrow = 2, ncol = 3),
         D = matrix(rnorm(2*2), nrow = 2, ncol = 2))
(z = zeroes(k, tol = 0))
all.equal(z, 1/(eigen(k$A - k$B \%*\% solve(k$D, k$C), only.values = TRUE)$values))

\dontrun{
k = stsp(k$A, k$B, k$C, 
         D = matrix(rnorm(2*1), nrow = 2, ncol = 1)[,c(1,1)])  # D is singular
zeroes(k)                                                      # zeroes() throws an error

k = stsp(k$A, k$B[,1,drop = FALSE], k$C, k$D[,1,drop = FALSE]) # (2 x 1) rational matrix
zeroes(k)                          # throws an error, since k is not square
}

# poles of polynomial matrices #############################################

# polynomials have no poles ###
poles(test_polm(dim = c(2,1), degree = 2, random = TRUE)) 

# poles of a rational matrix in LMFD form ##################################

(z = poles(c))
all.equal(z, zeroes(c$a))

# poles of a rational matrix in RMFD form ##################################

(z = poles(c))
all.equal(z, zeroes(c$a))

# poles of a rational matrix in statespace form ###########################

(z = poles(k, tol = 0))
all.equal(z, 1/(eigen(k$A, only.values = TRUE)$values))
}
