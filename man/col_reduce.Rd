% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/04_polynomial_methods.R
\name{col_reduce}
\alias{col_reduce}
\title{Construct a Column Reduced Polynomial Matrix}
\usage{
col_reduce(a, tol = sqrt(.Machine$double.eps), debug = FALSE)
}
\arguments{
\item{a}{\code{\link{polm}} object, which represents the square, polynomial matrix 
\eqn{a(z)}.}

\item{tol}{Double. Tolerance parameter. Default set to sqrt(.Machine$double.eps).}

\item{debug}{Logical, default to FALSE. If TRUE, then some diagnostic messages are printed.}
}
\value{
List with components 
\item{a}{(\code{\link{polm}} object) is the transformed (column reduced) matrix.}
\item{v,v_inv}{(\code{\link{polm}} objects) are the the unimodular matrices \eqn{v(z)} and \eqn{v^{-1}(z)} such that \eqn{a(z) v^{-1}(z)} is column reduced}.
\item{col_degrees}{vector of column degrees of the transformed matrix. 
    Note that the columns are permuted such that the transformed matrix has *non-increasing* column degrees.}
\item{col_end_matrix}{the column end matrix of the transformed matrix.}
}
\description{
Let \eqn{a(z)} be a square (non singular) polynomial matrix. 
This helper function constructs a unimodular transformation matrix \eqn{v(z)} such that \eqn{a(z) v^{-1}(z)} is column reduced (i.e. the column end matrix has full rank).
Algorithmic implementation are described e.g. in \insertCite{Wolovich1974}{rationalmatrices} Theorem 2.5.7, page 27, \insertCite{KrishnaraoChen84_colred}{rationalmatrices}, and \insertCite{geurtspraagman96}{rationalmatrices} who show that the KC implementations fails when the degree of the unimodular matrix \eqn{v^{-1}(z)} exceeds the degree of \eqn{a(z)} (page 4 in GP).
While all these implementations use elementary column operations to obtain zero columns in the column-end-matrix (in order to reduce the degree of the matrix polynomial), this implementation uses the \link{svd}.
The examples below are taken from \insertCite{geurtspraagman96}{rationalmatrices} and \insertCite{KrishnaraoChen84_colred}{rationalmatrices}.
}
\section{Possible "Improvements"}{

It is not clear whether the changes are improvements...
First: When a rank deficiency in the column-end-matrix is detected with the SVD, only one column is "reduced" to zero (even when the rank deficiency is larger than one). 
Fewer SVDs are calculated when both 
It might be better to reduce all columns to zero which pertain to (numerically) zero eigenvalues.
\cr
Second: The pivoting mechanism in the QR decomposition might be useful to single out the columns which should be set to zero.
It might be preferable to the SVD.
}

\examples{
# #############################################################################
# define a simple utility function for the computation of the rank of a matrix 
# compare e.g. Matrix::rankMatrix
rkM = function(x) {
  m = nrow(x)
  n = ncol(x)
  tol = max(m,n) * .Machine$double.eps
  
  if (min(m,n) == 0) return(0L)
  s = svd(x, 0, 0)$d
  return(sum(s >= tol*max(s)))
}
# #############################################################################

z = polm(c(0,1))

# Example 2.5.4 in W. A. Wolovich, Linear Multivariable Systems ###############
a = matrix(c(-3,2,0,1,2,3,0,0,2), nrow = 3, ncol = 3) +
    matrix(c(0,4,0,0,0,1,2,0,-3), nrow = 3, ncol = 3) * z + 
    matrix(c(1,0,-1,0,0,0,0,0,0), nrow = 3, ncol = 3) * z^2 
# Original Matrix:
print(a, format = 'c')
# Its column end matrix (and its rank) and column degrees
col_end_matrix(a)
col_end_matrix(a) \%>\% svd() \%>\% .$d
degree(a, "c")

# After column reduction:
out = col_reduce(a)
print(out$a, format = 'c', digits = 2)
print(out$col_degrees)
print(out$col_end_matrix)
print(out$col_end_matrix \%>\% svd() \%>\% .$d)

# Check correctness:
all.equal(polm(diag(3)), prune(out$v \%r\% out$v_inv))
all.equal(prune(a), prune(out$a \%r\% out$v))


  
# Random example: col degrees = (0,1,-1): throws an error #####################################
a = test_polm(dim = c(3,3), degree = c(0,1,-1), random = TRUE, digits = 2)
print(a, format = 'c')

\dontrun{
# this throws an error, since a(z) is singular
out = col_reduce(a)
}


# Random example: Generic matrices are row reduced ############################################
a = test_polm(dim = c(3,3), degree = c(2,1,0), random = TRUE, digits = 2)
print(a, format = 'c')

# Column reduction:
out = col_reduce(a) 
print(out$a, format = 'c', digits = 2)
print(out$col_degrees)
print(out$col_end_matrix)
print(out$col_end_matrix \%>\% svd() \%>\% .$d)

# Check:
all.equal(polm(diag(3)), prune(out$v \%r\% out$v_inv))
all.equal(prune(a), prune(out$a \%r\% out$v))


# Random example: Column end matrix has rank 2 ################################
col_end_matrix = matrix(round(rnorm(2*3),1), nrow = 3, ncol = 2) \%*\% 
                 matrix(round(rnorm(2*3),1), nrow = 2, ncol = 3)
a = test_polm(dim = c(3,3), degree = c(2,1,0), random = TRUE, 
               digits = 2, col_end_matrix = col_end_matrix)
print(a, format = 'c')
a \%>\% degree("c")
print(a \%>\% col_end_matrix)
print(a \%>\% col_end_matrix \%>\% svd() \%>\% .$d)

# Column reduction:
out = col_reduce(a) 
print(out$a, format = 'c', digits = 2)
print(out$col_degrees)
print(out$col_end_matrix)
print(out$col_end_matrix \%>\% svd() \%>\% .$d)

# Check:
all.equal(polm(diag(3)), prune(out$v \%r\% out$v_inv))
all.equal(prune(a), prune(out$a \%r\% out$v))


# Random example: Column end matrix has rank 1 ################################ 
col_end_matrix = matrix(round(rnorm(3),1), nrow = 3, ncol = 1) \%*\% 
                 matrix(round(rnorm(3),1), nrow = 1, ncol = 3)
a = test_polm(dim = c(3,3), degree = c(2,1,1), random = TRUE, 
               digits = 2, col_end_matrix = col_end_matrix)
print(a, format = 'c')
a \%>\% degree("c")
a \%>\% col_end_matrix() \%>\% svd() \%>\% .$d

# Column reduction:
out = col_reduce(a, debug = FALSE) 
print(out$a, format = 'c', digits = 2)
print(out$col_degrees)
print(out$col_end_matrix)
print(out$col_end_matrix \%>\% svd() \%>\% .$d)

# Check:
all.equal(polm(diag(3)), prune(out$v \%r\% out$v_inv))
all.equal(prune(a), prune(out$a \%r\% out$v))

#################################################################################

# PG, Ex 1: Jordan Normal Form type (Unimodular matrix) ##########
# Result: Works fine here (does not work with KC implementation)
m0 = diag(3)
m1 = matrix(c(0,1,0,   
              0,0,1,   
              0,0,0), nrow = 3, byrow = TRUE)

# Polymat:
(a = polm(array(c(m0,m1), dim = c(3,3,2))))
a \%>\% print(format = "c")
a \%>\% degree("c")

# Column reduced
a_red = col_reduce(a)
a_red$a
degree(a_red$a, "c")

#################################################################################

# PG, Ex 2: Nothing special ##########
# Result: Same as PG

a = test_polm(dim = c(2,2), degree = -1)
a[1,1] = polm(c(4,12,13,6,1))
a[1,2] = polm(c(-2,-5,-4,-1))
a[2,2] = polm(c(2,1))
a
a \%>\% print(format = "c")
col_end_matrix(a)
degree(a, "c")

# Column reduction:
a_red = col_reduce(a)
a_red$a
a_red$a \%>\% print(format = "c")
degree(a_red$a, "c")

#################################################################################

# PG, Ex 3: Unimodular matrix ##########
# Result: Works, but different matrices, v_inv (U(s) in PG notation is slightly "smaller" here)

a = test_polm(dim = c(3,3), degree = -1)
a[1,1] = polm(c(0,0,0,0,1))
a[1,2] = polm(c(0,0,1))
a[1,3] = polm(c(1,0,0,0,0,0,1))
a[2,1] = polm(c(0,0,1))
a[2,2] = polm(1)
a[2,3] = polm(c(0,0,0,0,1))
a[3,1] = polm(1)
a[3,3] = polm(1)
a
a \%>\% print(format = "c")
col_end_matrix(a)
degree(a, "c")

# Column reduction:
a_red = col_reduce(a)
a_red$a
a_red$a \%>\% print(format = "c")
degree(a_red$a, "c")

# Verify the column-reduced matrix time v(z) is equal to original one:
with(a_red, a \%r\% v) \%>\% print(format = "c")
a \%>\% print(format = "c")

# Unimodular matrix transforming the column-reduced matrix to original one:
a_red$v \%>\% print(format = "c")

# Verify that original matrix a(z) times v^{-1}(z) is column-reduced: PRUNING NECESSARY!
(a \%r\% a_red$v_inv) \%>\% print(format = "c")
prune(a \%r\% a_red$v_inv) \%>\% print(format = "c")
a_red$v_inv \%>\% print(format = "c") 

#################################################################################

# PG, Ex 4: PG's "singular case" ##########
# Result: Different results!
#   If eps = 10^(-9) is chosen, 
#   then this algorithm breaks down because the a[0] is recognized as singular! 
#   If eps = 10^(-4) is chosen (as is done in PG), 
#   we obtain a result which is different from the one in PG


# Original matrix (could be argued to be numerically singular at a[0], depending on tolerance!)
a = test_polm(dim = c(3,3), degree = -1)
eps = 10^(-4)
a[1,1] = polm(c(0,0,1,1))
a[1,2] = polm(c(1,eps))
a[1,3] = polm(1)
a[2,1] = polm(c(0,0,2))
a[2,2] = polm(-1)
a[2,3] = polm(-1)
a[3,1] = polm(c(0,0,3))
a[3,2] = polm(1)
a[3,3] = polm(1)
a
a \%>\% print(format = "c")
col_end_matrix(a)
col_end_matrix(a) \%>\% svd() \%>\% .$d
degree(a, "c")

# Column reduction: Note that there is a column with "small length". 
#   It depends on the tolerance whether this column is considered to be zero.
#   Also, note the singular values of the column-end-matrix of the reduced polymat!     
a_red = col_reduce(a)
a_red$a
a_red$a \%>\% print(format = "c")
a_red$a \%>\% print(format = "c", digits = 3)

a_red$a \%>\% col_end_matrix()
a_red$a \%>\% col_end_matrix() \%>\% svd() \%>\% .$d
a_red$a \%>\% degree("c")

# Col-reduced matrix time v(z) = original: 
# It works up to a small numerical issue in the (1,1) element 
with(a_red, a \%r\% v) \%>\% print(format = "c")
a \%>\% print(format = "c")

# Check unimodular matrix taking the col-reduced matrix back to original:
# Small (i.e. unproblematic) numerical issue in the (2,1)-element) which is also reflected above.
a_red$v \%>\% print(format = "c")

# Original times v^{-1}(z) = col-reduced:
# Works fine, up to small (non-problematic) issue in (1,3)-element
a_red$a \%>\% print(format = "c")
(a \%r\% a_red$v_inv) \%>\% print(format = "c")

# Matrix transforming the original to column-reduced:
# Small (unproblematic) issue in (2,3)-element
a_red$v_inv \%>\% print(format = "c")

# Algebraic result given in PG: Different from the one obtained here! ####
# The element (3,1) of matrix R(s) in PG seems to be incorrect. 
# Changing this element below results in a column-reduced matrix.
eta = 1/eps

r = test_polm(dim = c(3,3), degree = -1)
r[1,1] = polm(c(0,-3*eta))
r[1,2] = polm(c(1))
r[1,3] = polm(1)
r[2,1] = polm(c(0,3*eta))
r[2,2] = polm(c(-1, eps))
r[2,3] = polm(-1)
r[3,1] = polm(c(1,-3*eta,5))
r[3,2] = polm(c(1,-eps))
r[3,3] = polm(1)
r
# PG: Col-reduced
r \%>\% print(format = "c")
# Here: Col-reduced
a_red$a \%>\% print(format = "c")

u = test_polm(dim = c(3,3), degree = -1)
u[1,1] = polm(c(1))
u[1,2] = polm(c(0))
u[1,3] = polm(0)
u[2,1] = polm(c(0,-3*eta,-eta))
u[2,2] = polm(c(1))
u[2,3] = polm(0)
u[3,1] = polm(c(0,0,eta+2))
u[3,2] = polm(c(0,-eps))
u[3,3] = polm(1)
u
u \%>\% print(format = "c")

# Check whether their result makes sense:
# Column-reduced matrix r is different from a \%r\% u!!! 
# This mistake can be corrected by adjusting element (3,1) of r
a \%>\% print(format = "c")

a \%r\% u
(a \%r\% u) \%>\% print(format = "c")
(a \%r\% u) \%>\% col_end_matrix()
(a \%r\% u) \%>\% col_end_matrix() \%>\% svd() \%>\% .$d
(a \%r\% u) \%>\% degree("c")

r
r \%>\% print(format = "c")

#########################
# Change an element in r
r2 = r
r2[3,1] = polm(c(0,-3*eta,5))
r2 \%>\% print(format = "c")
r2 \%>\% col_end_matrix()
r2 \%>\% col_end_matrix() \%>\% svd() \%>\% .$d
r2 \%>\% col_end_matrix() \%>\% rkM()
r2 \%>\% degree("c")

(a \%r\% u) \%>\% print(format = "c")
 

#################################################################################

# PG, Ex 5: Breaks down in PG, but they give an algebraic solution ##########
# Result: Works here! 
#  Different result as algebraic solution indicated in PG (up to column permutation).
#  Of course, the obtained result is also column-reduced!
#  The unimodular matrix (which column-reduces the original polynomial matrix) is different 

a = test_polm(dim = c(4,4), degree = -1)
eps = 10^(-9)
a[1,1] = polm(c(1,1,1))
a[1,2] = polm(c(0,eps))
a[1,3] = polm(c(0,0,0,1))
a[1,4] = polm(c(1,0,0,1))
a[2,1] = polm(c(0,2))
a[2,2] = polm(0)
a[2,3] = polm(c(1,0,0,2))
a[2,4] = a[2,3]
a[3,1] = polm(c(1,3))
a[3,2] = polm(3)
a[3,3] = polm(c(3,0,3))
a[3,4] = a[3,3]
a[4,1] = polm(c(0,4))
a[4,2] = polm(c(0))
a[4,3] = polm(c(1,0,0,4))
a[4,4] = a[4,3]
a

# Original matrix, its column-end-matrix with its singular values, and its column degrees
a \%>\% print(format = "c")
col_end_matrix(a)
col_end_matrix(a) \%>\% svd() \%>\% .$d
col_end_matrix(a) \%>\% rkM()
degree(a, "c")

# Column-reduction:
a_red = col_reduce(a)
a_red$a
a_red$a \%>\% print(format = "c")
col_end_matrix(a_red$a)
col_end_matrix(a_red$a) \%>\% svd() \%>\% .$d
degree(a_red$a, "c")

# Check whether col-reduced matrix times unimodular v(z) = original:
# Works with small (non-problematic) numerical mistakes.
# Brutal pruning "solves" it
# Similar for the unimodular matrix v(z) itself
with(a_red, a \%r\% v) \%>\% print(format = "c")
with(a_red, a \%r\% v) \%>\% prune(brutal = TRUE) \%>\% print(format = "c")
a_red$v \%>\% print(format = "c")
a_red$v \%>\% prune(brutal = TRUE) \%>\% print(format = "c")

# Check whether original times v^{-1}(z) = col-reduced:
# Same as above: non-problematic numerical mistakes, "solved" by brutally pruning
# Same for unimodular v^{-1}(z)
(a \%r\% a_red$v_inv) \%>\% print(format = "c")
(a \%r\% a_red$v_inv) \%>\% prune(brutal = TRUE) \%>\% print(format = "c")
a_red$a \%>\% print(format = "c")
a_red$v_inv \%>\% print(format = "c")
a_red$v_inv \%>\% prune(brutal = TRUE) \%>\% print(format = "c")

# Krishnarao and Chen example #####################

(a = polm(array(c(4,0,-2,2,  
                  12, 0, -5, 1,    
                  13,0,1,0,   
                  2,0,0,0), dim = c(2,2,4))))
out = col_reduce(a)
out$a
a \%r\% out$v_inv
with(out, a \%r\% v)

# Majid: Ex 3 ################

(m0 = matrix(c(-3,1,0, 2,2,0,   0,3,2), nrow = 3, byrow = TRUE))
(m1 = matrix(c(0,0,2,   4,0,0,   0,1,-3), nrow = 3, byrow = TRUE))
(m2 = matrix(c(1,0,0,   0,0,0,   -1,0,0), nrow = 3, byrow = TRUE))
m = polm(array(c(m0,m1,m2), dim = c(3,3,3)))
m \%>\% print(format = "c")
m \%>\% col_end_matrix()
m \%>\% col_end_matrix() \%>\% svd() \%>\% .$d
m \%>\% degree("c")

(out = col_reduce(m))

 # Majid: Ex 4 ################3
(m0 = matrix(c(1,0,   0,1), nrow = 2, byrow = TRUE))
(m1 = matrix(c(0,0,   2,0), nrow = 2, byrow = TRUE))
(m2 = matrix(c(1,1,   0,0), nrow = 2, byrow = TRUE))
(m3 = matrix(c(2,0,   0,0), nrow = 2, byrow = TRUE))
m = polm(array(c(m0,m1,m2,m3), dim = c(2,2,4)))
m \%>\% print(format = "c")
m \%>\% col_end_matrix()
m \%>\% col_end_matrix() \%>\% svd() \%>\% .$d
m \%>\% degree("c")

(out = col_reduce(m))
}
\references{
\insertRef{Wolovich1974}{rationalmatrices}
\insertRef{KrishnaraoChen84_colred}{rationalmatrices}
\insertRef{geurtspraagman96}{rationalmatrices}
}
\seealso{
The column end matrix may be computed with \code{\link{col_end_matrix}}. 
The function \code{col_reduce} is mainly used to compute the Wiener-Hopf factorization of a polynomial matrix, see \code{\link{whf}}.
}
