% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/04_polynomial_methods.R
\name{purge_rc}
\alias{purge_rc}
\title{Purge Rows or Columns of a Polynomial Matrix}
\usage{
purge_rc(
  a,
  pivot = c(1, 1),
  direction = c("down", "up", "left", "right"),
  permute = TRUE,
  tol = sqrt(.Machine$double.eps),
  monic = FALSE,
  debug = FALSE
)
}
\arguments{
\item{a}{Polynomial matrix of dimension \eqn{(m,n)}, i.e. an object of class \code{\link{polm}}.}

\item{pivot}{Integer vector of length 2. Specifies the position of the "pivot" element.}

\item{direction}{Character string. 
\describe{
\item{down}{(default) "purge" all elements below the pivot element by elementary row-operations.}
\item{up}{"purge" all elements above the pivot element by elementary row-operations}
\item{right}{"purge" all elements to the right of the pivot element 
            by elementary column-operations}
\item{left}{"purge" all elements to the left of the pivot element 
            by elementary column-operations}
}}

\item{permute}{Logical, defaults to TRUE. See the details below.}

\item{tol}{Tolerance parameter, used for "pruning" the polynomial matrix (after each step). 
See \code{\link{prune}}.}

\item{monic}{Logical, defaults to FALSE.
If TRUE, the coefficient pertaining to the highest degree of the pivot element will 
be normalized to 1.}

\item{debug}{Logical, default to FALSE. If TRUE, then some diagnostic messages are printed.}
}
\value{
List with three slots
  \item{\code{h}}{Polynomial matrix of dimension \eqn{(m,n)}, i.e. an object of class \code{\link{polm}}. 
        This matrix is the result of the "purging" operation(s).}
  \item{\code{u}}{Unimodular polynomial matrix, i.e. a class \code{\link{polm}} object. 
       For \code{direction = 'down'} or  \code{direction = 'up'} the matrix 
       \eqn{u(z)} is \eqn{(m,m)} dimensional and satisfies \eqn{a(z) = u(z) h(z)}.
       For \code{direction = 'left'} or  \code{direction = 'right'} the matrix 
       \eqn{u(z)} is \eqn{(n,n)} dimensional and satisfies \eqn{a(z) = h(z) u(z)}.}
  \item{\code{u_inv}}{Unimodular polynomial matrix, i.e. a class \code{\link{polm}} object.  
       This matrix is the inverse of \eqn{u(z)}.}
}
\description{
This helper function is the main work horse for computing the Hermite normal form 
(see \code{\link{hnf}}) and the Smith normal form (see \code{\link{snf}}) of 
polynomial matrices. It "purges" all elements below, above, to the right or to the 
left of a pivot element by elementary row- or column- operations. Here 
"purge" means that the elements are either reduced to zero or that the degree of the 
elements is made smaller than the degree of the pivot element.
}
\details{
Suppose that the matrix \eqn{a(z)} has \eqn{m} rows, \eqn{n} columns and that the pivot is at 
position \eqn{(i,j)}. Furthermore, let us first consider the case \code{direction='down'} 
and \code{permute=FALSE}. In this case a suitable multiple - which is computed by the 
Euclidean polynomial division algorithm - of the \eqn{i}-th row is subtracted from all rows 
below the \eqn{i}-th row such that the respective degree of the elements below 
the pivot element have a degree which is smaller than the degree of the pivot. 

If the option \code{permute=TRUE} then first the rows \eqn{i:m} are permuted such that 
the \eqn{(i,j)}-th element has the smallest degree among all elements in the \eqn{j}-th 
column and the rows \eqn{i:m}. Next a suitable multiple of the \eqn{i}-th row is 
subtracted from all rows below the \eqn{i}-th row such that the respective degree 
of the elements below the pivot element have a degree which is smaller than the 
degree of the pivot. These two steps are repeated until all elements below the pivot element are zero. 

Quite analogously the cases \code{direction='up'},  \code{direction='left'} and  \code{direction='right'}
may be discussed. Note however, that for the cases  \code{direction='left'} and  \code{direction='right'} 
elementary column-operations are used. 

Finally, for \code{monic=TRUE} the pivot element is made monic, by multiplying the 
respective row (or column) by a suitable scalar.
}
\examples{
# Generate matrix polynomial
a = test_polm(dim = c(2,3), degree = 1)
print(a, format = 'c')

########################################################
# Purge first column downwards
out = purge_rc(a, pivot = c(1,1), monic = TRUE)

# First col zero except for (1,1) element
print(out$h, digits = 2, format = 'c')

# Check polynomial matrix products
all.equal(a, prune(out$u \%r\% out$h))
all.equal(out$h, prune(out$u_inv \%r\% a))
all.equal(polm(diag(2)), prune(out$u_inv \%r\% out$u))

########################################################
# Purge last column upwards
out = purge_rc(a, pivot = c(2,3), direction = "up", monic = TRUE)

# Last col zero except for (2,3) element
print(out$h, digits = 2, format = 'c')

# Check polynomial matrix products
all.equal(a, prune(out$u \%r\% out$h))
all.equal(out$h, prune(out$u_inv \%r\% a))
all.equal(polm(diag(2)), prune(out$u_inv \%r\% out$u))

########################################################
# Purge first row right
out = purge_rc(a, pivot = c(1,1), direction = "right", monic = TRUE)

# first row zero except for (1,1) element
print(out$h, digits = 2, format = 'c')

# Check polynomial matrix products
all.equal(a, prune(out$h \%r\% out$u))
all.equal(out$h, prune(a \%r\% out$u_inv))
all.equal(polm(diag(3)), prune(out$u_inv \%r\% out$u))

########################################################
# Purge last row left
out = purge_rc(a, pivot = c(2,3), direction = "left", monic = TRUE)

# last row zero except for (2,3) element
print(out$h, digits = 2, format = 'c')

# Check polynomial matrix products
all.equal(a, prune(out$h \%r\% out$u))
all.equal(out$h, prune(a \%r\% out$u_inv))
all.equal(polm(diag(3)), prune(out$u_inv \%r\% out$u))
}
