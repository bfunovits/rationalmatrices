% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tools.R
\name{match_vectors}
\alias{match_vectors}
\title{Match Two Vectors}
\usage{
match_vectors(x, y = Conj(x))
}
\arguments{
\item{x, y}{two vectors of length \eqn{p \leq q}{p \le q} respectively.}
}
\value{
The \eqn{p}-dimensional integer vector \code{j} (with unique elements).
}
\description{
Given two vectors \code{x,y} of length \eqn{p \leq q}{p \le q} respectively, 
the routine \code{match_vectors} returns an integer vector 
\code{j}, with unique elements, such that \code{x} matches \code{y[j]} 
as best as possible. The procedure uses the "Munkres" algorithm for 
solving this assignment problem. The procedure throws an error if the length of 
\code{x} is larger than the length of \code{y}.
}
\examples{
# Match the roots of two polynomials a1 and a2
p = 5
a1 = rnorm(p+1)
a2 = a1 + rnorm(p+1)*(1e-6) # a2 is a "noisy" copy of a1
z1 = polyroot(a1)
z2 = polyroot(a2)[order(stats::rnorm(p))] # reshuffle the roots of a2
j = match_vectors(z1, z2)
print(data.frame(z1 = z1, j = j, `z2[j]` = z2[j], d = z1-z2[j]))

# A polynomial with real coefficients has pairs of complex conjugate roots.
# However, the roots returned by "polyroot" in general do not have this 
# property!
# Match the roots and their complex conjugates
j = match_vectors(z1, Conj(z1))
print(data.frame(z = z1, j = j, `Conj(z[j])` = Conj(z1[j]), 
                 d = z1-Conj(z1[j])))

}
\keyword{internal}
