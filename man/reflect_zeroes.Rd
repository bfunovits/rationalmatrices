% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/08_reflection_poles_zeroes.R
\name{reflect_zeroes}
\alias{reflect_zeroes}
\alias{reflect_zeroes.polm}
\alias{reflect_zeroes.lmfd}
\alias{reflect_zeroes.stsp}
\title{Reflect Zeroes of Rational Matrices}
\usage{
reflect_zeroes(x, zeroes, ...)

\method{reflect_zeroes}{polm}(
  x,
  zeroes,
  tol = sqrt(.Machine$double.eps),
  check_zeroes = TRUE,
  ...
)

\method{reflect_zeroes}{lmfd}(
  x,
  zeroes,
  tol = sqrt(.Machine$double.eps),
  check_zeroes = TRUE,
  ...
)

\method{reflect_zeroes}{stsp}(x, zeroes, tol = sqrt(.Machine$double.eps), ...)
}
\arguments{
\item{x}{Square, rational matrix object (with real coefficients).}

\item{zeroes}{Complex or real vector of zeroes to be reflected. 
It is assumed that for complex conjugated pairs of roots, 
only \bold{one} is contained in this vector.}

\item{...}{Not used.}

\item{tol}{(double) Tolerance parameter used for the checks.}

\item{check_zeroes}{If \code{TRUE} then the procedure checks that the given 
zeroes are zeroes of the rational matrix \eqn{x(z)}.}
}
\value{
Rational matrix object which represents the rational matrix 
        \eqn{x(z)U(z)} with the reflected zeroes. The object is of 
        the same class as the input object \code{x}.
}
\description{
Given a square, rational matrix \eqn{x(z)} and a set of zeroes of \eqn{x(z)}, 
the function \code{reflect_zeroes} constructs a rational, allpass matrix 
\eqn{U(z)} such that \eqn{x(z)U(z)} has zeroes which are the reciprocals 
of the selected zeroes. The other zeroes of \eqn{x(z)} and the poles of 
\eqn{x(z)} are not changed.
}
\note{
The procedures are only implemented for rational matrices with real coefficients. 
Therefore complex zeroes occur in complex conjugated pairs and such pairs are **jointly** reflected to ensure that the result again has real coefficients. 
Note however, that the argument \code{zeroes} must only contain \bold{one} 
element of the pairs to be reflected.

In some degnerate cases the procedure(s) may run into numerical problems: 
For polynomial matrices and matrices in \code{lmfd} form, 
the procedure assumes that the value of the matrix evaluated at 
\eqn{z=0} is non singular. For the matrices in statespace form, zeroes 
on (or close to) the unit circle are not allowed. In addition multiple 
zeroes may lead to unreliable results.
}
\examples{
# ###################################################################
# polynomial matrix 

# construct a (2 x 2) polynomial matrix with degree 2
x = polm(array(c(1,0,
                 0,1,
                 -1,0,
                 0,0,
                 1,0.25,
                 0.75,-1), dim = c(2,2,3)))
x

# determine zeroes of x(z)
( x_zeroes = zeroes(x) )

# evaluate the polynomial at the (real) zeroe x_zeroes[1] 
( x_value = zvalue(x, x_zeroes[1]) )

# Verify that the matrix evaluated at z = x_zeroes[1] is rank deficient
d = svd(x_value)$d
(min(d) < (max(d) * sqrt(.Machine$double.eps)))

# Reflect this zeroe at the unit circle and check the zeroes of the result
x1 = reflect_zeroes(x, x_zeroes[1])

r_zeroes = x_zeroes
r_zeroes[1] = 1 / r_zeroes[1]
x1_zeroes = zeroes(x1)
j = match_vectors(r_zeroes, x1_zeroes)
all.equal(r_zeroes, x1_zeroes[j]) 

# x_zeroes[2] and x_zeroes[3] form a pair of complex conjugated zeroes
( x_value = zvalue(x, x_zeroes[2]) )

# Verify that the matrix evaluated at x_zeroes[2] is rank deficient
d = svd(x_value)$d
(min(d) < (max(d) * sqrt(.Machine$double.eps)))

# reflect the real zeroe x_zeroes[1] and this pair of 
# complex conjugated zeroes at the unit circle and verify the result
x1 = reflect_zeroes(x, x_zeroes[c(1,2)])

r_zeroes = x_zeroes
r_zeroes[1:3] = 1 / r_zeroes[1:3]
x1_zeroes = zeroes(x1)
j = match_vectors(r_zeroes, x1_zeroes)
all.equal(r_zeroes, x1_zeroes[j]) 

# Check that the transformation matrix U (x1 = x \%r\% U) is all-pass
all.equal(zvalues(x) \%r\% Ht(zvalues(x)), zvalues(x1) \%r\% Ht(zvalues(x1)))


# ###################################################################
# rational matrix in LMFD form

set.seed(12345)
(x = test_lmfd(dim = c(3,3), degrees = c(2,2), digits = 2))
(x_zeroes = zeroes(x))

# reflect all zeroes inside the unit circle
# note: for complex zeroes, select only one of the complex conjugated pair!
x1 = reflect_zeroes(x, x_zeroes[(abs(x_zeroes) <1) & (Im(x_zeroes) >=0 )])

r_zeroes = x_zeroes
r_zeroes[abs(r_zeroes) < 1] = 1 / r_zeroes[abs(r_zeroes) < 1]
(x1_zeroes = zeroes(x1))
j = match_vectors(r_zeroes, x1_zeroes)
all.equal(r_zeroes, x1_zeroes[j]) 

# Check that the transformation matrix U (x1 = x \%r\% U) is all-pass
all.equal(zvalues(x) \%r\% Ht(zvalues(x)), zvalues(x1) \%r\% Ht(zvalues(x1)))

set.seed(NULL)


# ###################################################################
# rational matrix in statespace form (stsp object)

# create a random (2,2) rational matrix in state space form with
# state dimension s=5
set.seed(12345)
(x = test_stsp(dim = c(2,2), s = 5))
# zeroes of x(z)
(x_zeroes = zeroes(x))

# reflect all unstable zeroes (inside the unit circle)
# note: for complex zeroes, select only one of the complex conjugated pair!
x1 = reflect_zeroes(x, x_zeroes[(abs(x_zeroes) <1) & (Im(x_zeroes) >=0 )])

r_zeroes = x_zeroes
r_zeroes[abs(r_zeroes) < 1] = 1 / r_zeroes[abs(r_zeroes) < 1]
(x1_zeroes = zeroes(x1))
j = match_vectors(r_zeroes, x1_zeroes)
all.equal(r_zeroes, x1_zeroes[j])

# Check that the transformation matrix U (x1 = x \%r\% U) is all-pass
all.equal(zvalues(x) \%r\% Ht(zvalues(x)), zvalues(x1) \%r\% Ht(zvalues(x1)))

set.seed(NULL)
}
\seealso{
The procedure uses the helper functions \code{\link{blaschke}} 
         and \code{\link{make_allpass}}. For reflecting poles, see 
         \code{\link{reflect_poles}}.
}
