% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/07_numerical_schur.R
\name{schur}
\alias{schur}
\title{Schur Decomposition}
\usage{
schur(A, select = NULL, tol = sqrt(.Machine$double.eps))
}
\arguments{
\item{A}{square, non-empty, real matrix.}

\item{select}{If non NULL, then the Schur decomposition is reordered such that 
the selected cluster of eigenvalues appear in the leading 
diagonal blocks of the quasi-triangular matrix \eqn{S}. See the details below.}

\item{tol}{tolerance used to decide whether the target eigenvalues match the 
eigenvalues of \eqn{A}. See the details below.}
}
\value{
List with components \code{U}, \code{S}, \code{lambda} and \code{k}, 
        where \code{lambda} contains the (computed) eigenvalues of \eqn{A} and 
        \code{k} indicates how many eigenvalues have been selected (put to the top).
}
\description{
The Schur decomposition of a (real, square) matrix \eqn{A} is 
\deqn{A = U S U'}
where \eqn{U} is an orthogonal matrix and \code{S} is 
upper quasi-triangular with 1-by-1 and 2-by-2 blocks on the diagonal. 
The 2-by-2 blocks correspond to the complex eigenvalues of \eqn{A}.
}
\details{
The optional parameter \code{select} determines which eigenvalues, respectively 
1-by-1 and 2-by-2 blocks, should be put to the top of the matrix \eqn{S}. 

\itemize{
\item{\code{select='iuc'}: Select the eigenvalues with moduli less than one 
      (inside the unit circle).}
\item{\code{select='ouc'}: Select the eigenvalues with moduli greater than one 
      (outside the unit circle).}
\item{\code{select='lhf'}: Select the eigenvalues with a negative imaginary part 
      (left half plane).}
\item{\code{select='rhf'}: Select the eigenvalues with a positive imaginary part 
      (right half plane).}
\item{\code{select='real'}: Select the real eigenvalues.}
\item{\code{select='cplx'}: Select the complex eigenvalues.}
\item{\code{select} is a (complex) vector of eigenvalues. The function checks whether
      the "target eigenvalues", i.e. the entries of \code{select},  match the eigenvalues 
      of the matrix \eqn{A}. In addition the procedure also makes sure 
      that complex eigenvalues are selected in complex conjugated pairs.} 
}

The function \code{schur} is simply a wrapper for \code{\link[QZ]{qz.dgees}} 
and \code{\link[QZ]{qz.dtrsen}}.
}
\examples{
# generate a "random" 6-by-6 matrix A
m = 6
set.seed(1532)
A = matrix(stats::rnorm(m*m, sd = 0.5), nrow = m, ncol = m)
set.seed(NULL)

# compute the Schur decomposition of A (and its eigenvalues)
out = schur(A)
lambda = out$lambda # eigenvalues of A

# check A = U S U' 
all.equal(A, out$U \%*\% out$S \%*\% t(out$U))
print(out$S)
print(lambda)

# compute an "ordered" Schur decomposition where the eigenvalues 
# inside the unit circle are put to the top of S:
out = schur(A, 'iuc')
print(out$S)
print(out$k) # three eigenvalues are inside the unit circle.
print(out$lambda) 

# compute an "ordered" Schur decomposition where the eigenvalues 
# lambda[5] and lambda[6] apear in the top. Note that 
# lambda[5] is complex and hence the procedure also selects 
# the conjugate of lambda[5]:  
out = schur(A, lambda[c(6,5)])
print(out$S)
print(out$k) # three eigenvalues have been selected
print(out$lambda) 

\dontrun{
# If the "target" eigenvalues do not match the eigenvalues of A 
# then "schur" throws an error:
out = schur(A, select = lambda[1:3]+ 1)
}
}
