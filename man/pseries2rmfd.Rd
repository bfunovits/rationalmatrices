% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/01_representation_conversions.R
\name{pseries2rmfd}
\alias{pseries2rmfd}
\title{Construct an RMFD Representation from Impulse Response}
\usage{
pseries2rmfd(obj, Hsize = NULL, mu = NULL, tol = sqrt(.Machine$double.eps))
}
\arguments{
\item{obj}{\code{\link{pseries}} object or 3-D array with dimension \eqn{(m,n,l+1)}.}

\item{Hsize}{integer vector \code{c(f,p)}, number of block rows and block columns of the Hankel matrix which is used to construct the RMFD.
If NULL a default choice is made.}

\item{mu}{integer vector with the right-Kronecker indices.
If \code{NULL} then the right-Kronecker indices are computed via a QR decomposition of the transpose of the Hankel matrix, see \code{\link{qr}}.}

\item{tol}{tolerance parameter, used by \code{\link{qr}}.}
}
\value{
List with components
\item{Xr}{\code{\link{rmfd}} object which contains the RMFD resresentation
         of the rational matrix (in echelon form).}
\item{mu}{integer vector with the right-Kronecker indices.}
}
\description{
This (helper) function constructs a right matrix fraction description of a rational matrix from its impulse response.
Of course, the impulse response must contain sufficently many lags.
The constructed RMFD is in canonical form.
}
\details{
There are a number of restrictions on the dimension \eqn{(m,n)} and number of lags \eqn{l} of the impulse response,
the number of block rows (\eqn{f}), block columns (\eqn{p}) of the Hankel matrix and the right-Kronecker indices \eqn{\mu_i}{\mu[i]}:

We require that:
\itemize{
\item \eqn{m>0}, \eqn{p>0}, \eqn{f>1},
\item \eqn{l \geq f+p-1}{l\ge f+p-1} and
\item \eqn{\nu_i <f}{\nu[i] < f}.
}
If these restrictions are not satisfied an error is thrown.
}
\examples{
# generate a random RMFD object
m = 3
n = 2
p = 1
q = 1
cc = test_polm(dim = c(n,n), degree = p, random = TRUE)
dd = test_polm(dim = c(m,n), degree = q, random = TRUE)
Xr = rmfd(cc,dd)

# compute impulse response of this matrix
Xi = pseries(Xr, lag.max = 2*(max(p,q)+1))

# reconstruct a matrix from this impulse response
out = pseries2rmfd(Xi)
out

# check that the lmfd object is a realization of the given impulse response
Xi1 = pseries(out$Xr, lag.max = 2*(max(p,q)+1))
all.equal(Xi, Xi1)
}
