[{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Rational Matrices","text":"rationalmatrices package collection classes, methods functions handling manipulating rational matrices, .e matrices whose entries rational functions entries. matrices particular useful linear dynamic time series models, like VARMA statespace models. package mainly designed written regard application. See also “companion” package RLDM. main goal implement classes rational matrices may handled similarly ordinary matrices. particular, arithmetic operations, like addition, look feel manipulations ordinary matrices. start basic examples. First create scalar polynomial \\((z)=1+0.9z+0.9z^2+0.9^3z^3\\), check object “valid” print : Create scalar rational matrix \\(c(z) = ^{-1}(z) b(z)\\) LMFD form, check object valid print : Compute poles zeroes \\(c(\\cdot)\\) Evaluate \\((z), b(z), c(z)\\) unit circle check \\(c=^{-1}b\\): Produce “Nyquist” plot, imaginary part plotted versus real part. order get “nice, smooth” path, evaluate rational function \\(c(z)\\) grid 1024 points unit circle:","code":"a = polm(c(1,0.9,0.9^2,0.9^3)) is.polm(a) #> [1] TRUE print(a, format = 'c') #> ( 1 x 1 ) matrix polynomial with degree <= 3  #>                                [,1] #> [1,]  1 + 0.9z + 0.81z^2 + 0.729z^3 c = lmfd(a, c(1, 0, 0.8^2)) is.lmfd(c) #> [1] TRUE print(c) #> ( 1 x 1 ) left matrix fraction description a^(-1)(z) b(z) with degrees (p = 3, q = 2) #> left factor a(z): #>      z^0 [,1] z^1 [,1] z^2 [,1] z^3 [,1] #> [1,]        1      0.9     0.81    0.729 #> right factor b(z): #>      z^0 [,1] z^1 [,1] z^2 [,1] #> [1,]        1        0     0.64 poles(c) #> [1]  0.000000-1.111111i  0.000000+1.111111i -1.111111+0.000000i zeroes(c) #> [1] 0-1.25i 0+1.25i ## evaluate af = zvalues(c$a, n.f = 10) bf = zvalues(c$b, n.f = 10) cf = zvalues(c, n.f = 10) all.equal(cf, af^(-1) %r% bf) #> [1] TRUE print(cf, format = 'iz|j', digits = 2) #> ( 1 x 1 ) frequency response #>                            [,1] #>          z=1+0i [1,] 0.48+0.00i #>  z=0.809-0.588i [1,] 0.47+0.19i #>  z=0.309-0.951i [1,] 0.44+0.52i #> z=-0.309-0.951i [1,] 0.77+0.52i #> z=-0.809-0.588i [1,] 0.81+1.31i #>         z=-1+0i [1,] 9.06+0.00i #> z=-0.809+0.588i [1,] 0.81-1.31i #> z=-0.309+0.951i [1,] 0.77-0.52i #>  z=0.309+0.951i [1,] 0.44-0.52i #>  z=0.809+0.588i [1,] 0.47-0.19i plot(zvalues(c, n.f = 1024), which = 'nyquist')"},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"classes","dir":"Articles","previous_headings":"","what":"Classes","title":"Rational Matrices","text":"several useful representations (realizations) rational matrices. , consider polynomial matrices rational matrices represented left matrix fraction description statespace realization. Furthermore, coefficients power series expansion (called impulse response function) (sufficently rich) set values rational matrix (called frequency response function) uniquely determine rational matrix hence may seen another way represent rational matrix. separate classes rational scalars rational vectors. scalar simply considered \\((1\\times 1)\\) matrix vector \\((m\\times 1)\\) (\\((1 \\times n)\\)) matrix.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"polynomial-matrices","dir":"Articles","previous_headings":"Classes","what":"Polynomial Matrices","title":"Rational Matrices","text":"Polynomial matrices \\[ (z) = a_0 + a_1 z + \\cdots + a_p z^p,\\; a_i\\\\mathbb{R}^{m\\times n} \\mbox{ } a_i \\\\mathbb{C}^{m\\times n} \\] represented objects class polm. polm object simply \\((m,n,p+1)\\)-dimensional array stores coefficients \\(a_i\\) together class attribute c('polm','ratm'). Note: allow complex coefficients, empty polynomials (\\(m=0\\) \\(n=0\\)) zero polynomials (\\((z)=0\\) \\(z\\\\mathbb{C}\\)). Zero polynomials may represented \\((m,n,0)\\)-dimensional array, .e. degree \\(p\\) equal \\(p=-1\\). constructor polynomial matrices polm(). testing purposes one may use test_polm() create (random) polynomial matrices.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"left-matrix-fraction-description","dir":"Articles","previous_headings":"Classes","what":"Left Matrix Fraction Description","title":"Rational Matrices","text":"rational \\((m \\times n)\\) matrix \\(c(z)\\) may represented \\(c(z) = ^{-1}(z) b(z)\\), \\[ (z)  = a_0 + a_1 z + \\cdots + a_p z^p \\] \\((m \\times m)\\) (non singular) polynomial matrix degree \\(p\\), \\[ b(z) = b_0 + b_1 z + \\cdots + b_q z^q \\] \\((m \\times n)\\) dimensional matrix polynomial degree \\(q\\). matrix \\(c(z)\\) thus described pair \\(((z), b(z))\\). Note “factors” \\((z), b(z)\\) means unique given \\(c(z)\\). Internally LMFDs stored matrix \\[ [a_0,a_1,\\ldots,a_p,b_0,\\ldots,b_q] \\\\mathbb{R}^{m \\times (m(p+1)+n(q+1))} \\] attribute order = c(m,n,p,q) class attribute c('lmfd','ratm'). Note: demand \\(m>0\\), since clear interpret inverse \\((0 \\times 0)\\)-dimensional matrix. Since \\((z)\\) non singular, \\(p\\geq 0\\) must hold. constructor lmfd objects lmfd(). testing purposes one may use test_lmfd() create (random) rational matrices LMFD form.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"statespace-representation","dir":"Articles","previous_headings":"Classes","what":"Statespace Representation","title":"Rational Matrices","text":"rational (\\((m \\times n)\\)-dimensional) matrix \\(c(z)\\) pole \\(z=0\\) may represented \\[ c(z) = C(z^{-1}I_s - )^{-1}B + D \\] \\(\\\\mathbb{R}^{s\\times s}\\), \\(B\\\\mathbb{R}^{s\\times n}\\), \\(C\\\\mathbb{R}^{m\\times s}\\) \\(D\\\\mathbb{R}^{m\\times n}\\). integer \\(s\\) called state dimension realization. Statespace representations means unique, even state dimension \\(s\\) unique. state dimension \\(s\\) minimal among possible realizations \\(c(z)\\) representation called minimal. Internally, statespace realizations stored matrix \\[ \\begin{bmatrix} & B \\\\ C & D \\end{bmatrix} \\\\mathbb{R}^{(s+m) \\times (s+n)} \\] attribute order = c(m,n,s) class attribute c('stsp','ratm'). Notes: E.g. elementary rational function \\(c(z)=z^{-1}\\) statespace realization form. integers \\(m,n,s\\) may zero. Many (algebraic) operations easy implement terms statespace representations. Therefore, package somewhat “biased” towards statespace representations. constructor stsp objects stsp(). testing purposes one may use test_stsp() create (random) rational matrices statespace form.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"power-series","dir":"Articles","previous_headings":"Classes","what":"Power Series","title":"Rational Matrices","text":"Impulse response function transfer function also used object. rational matrix \\(c(z)\\) pole \\(z=0\\), exists power series expansion \\[ c(z) = k_0 + k_1 z^1 + k_2 z^2 + \\cdots \\] converges (non-empty) circle around \\(z=0\\). sequence coefficients \\((k_j \\,|\\, j \\geq 0)\\) called impulse response function1. pseries object stores finite sequence \\((k_0,\\ldots,k_l)\\) \\((m,n,(l+1))\\) dimensional array class attribute c('stsp','ratm'). Note: Due rational structure, finite sequence coefficients sufficient reconstruct rational matrix \\(c(z)\\), see e.g. Ho-Kalman realization algorithm implemented pseries2stsp function pseries2lmfd. (course number coefficients large enough.) Hence, can interpret (finite) impulse response function another way represent rational matrices.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"frequency-response","dir":"Articles","previous_headings":"Classes","what":"Frequency Response","title":"Rational Matrices","text":"rational matrix also uniquely determined (finite) set function values. object class zvalues \\((m,n,k)\\) dimensional array (stores values \\(c(z_j)\\), \\(j=1,\\ldots,k\\) together attribute z (vector components \\(z_j\\), \\(j=1,\\ldots,k\\)) class attribute c('freqressp','ratm'). rational matrix represents transfer function (rational) filter, often matrix evaluated grid points unit circle \\[ f_j = (j-1)/k,\\qquad z_j = \\exp(-(2\\pi  f_j)),\\qquad j=1,\\ldots,k \\] Notes: stated rational function uniquely determined finite (sufficiently rich) set values. However, implemented algorithm computes “LMFD” “statespace” representation given frequency response.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"general-methods","dir":"Articles","previous_headings":"Operations and Methods","what":"General Methods","title":"Rational Matrices","text":".polm(x), .lmfd(x), .stsp(x), .pseries(x), .zvalues(x) test whether object x valid (rational matrix) object. dim(x) returns (named) vector dimensions rational matrix object. str methods produces one-line description rational matrix objects. print methods tries produce compact display rational matrix object. plot methods implemented pseries zvalues objects.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"convert-from-class-x-to-class-y","dir":"Articles","previous_headings":"Operations and Methods","what":"Convert from Class x to Class y","title":"Rational Matrices","text":"essential goal package provide tools, allow simple conversion one representation (realization) another. following table gives overview “conversion” procedures:  colors cells mean orange-red: make sense (general) light-steel-blue: use two step procure, e.g .lmfd(pseries(x, lag.max)) gold: (yet) implemented core procedures compute LMFD statespace realization given impules reponse described following subsection. information may found vignette “technical details”.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"realization-algorithms","dir":"Articles","previous_headings":"Operations and Methods > Convert from Class x to Class y","what":"Realization Algorithms","title":"Rational Matrices","text":"One characteristic features rational functions Hankel matrix impulse response2 coefficients \\[ H = \\begin{pmatrix} k_1 & k_2 & \\cdots \\\\ k_2 & k_3 & \\cdots \\\\ \\vdots & \\vdots & \\end{pmatrix} \\] finite rank. rational matrix \\(k(z)\\) LMFD representation \\(k(z)=^{-1}(z)b(z)\\), \\((z)=a_0 + a_1 z + \\cdots + a_p z^p\\), \\(b(z)=b_0 + b_1 z + \\cdots + b_q z^q\\) \\[ (z)(k(z)-k_0) = b(z) - (z)k_0 \\] implies \\[ a_0 k_l + a_1 k_{l-1} + \\cdots + a_p k_{l-p} = 0 \\mbox{ } l>\\max(p,q) \\] implies Hankel matrix indeed finite rank furthermore can construct matrix \\((z)\\) left kernel Hankel matrix. given \\(()\\) \\(k()\\), \\(b(z)\\) follows \\(b(z)=(z)k(z)\\). order describe linear dependence structure rows \\(H\\) convenient use “double” index rows: Let \\(h(,j)\\\\mathbb{R}^{1\\times \\infty}\\) denote \\(j\\)-th row \\(\\)-th block row \\(H\\), .e. \\(h(,j)\\) \\(((-1)m+j)\\)-th row \\(H\\). selection \\(\\mathcal{S}=\\{h(i_k,j_k) \\,|\\, k=1,\\ldots ,s\\}\\) rows Hankel matrix called nice selection, “holes” sense \\(h(,j)\\\\mathcal{S}\\), \\(>1\\) implies \\(h(-1,j)\\\\mathcal{S}\\). Nice selections may described multi-index \\(\\nu = (\\nu_1, \\ldots, \\nu_m)\\), \\(\\nu_j=\\max \\{\\,|\\,h(,j)\\\\mathcal{S}\\}\\). Suppose \\(H\\) rank \\(s\\). general many different selections rows \\(H\\) form basis row space \\(H\\). following choose first \\(s\\) rows \\(H\\) form basis row space denote corresponding selection \\(\\mathcal{S}=\\{h(i_k,j_k) \\,|\\, k=1,\\ldots ,s\\}\\). Due Hankel structure \\(H\\) nice selection sense. corresponding \\(\\nu_j\\)’s called Kronecker indices Hankel matrix (respectively rational matrix \\(k(\\cdot)\\)). Note sum Kronecker indices equal rank \\(H\\): \\(\\sum_{j=1}^m \\nu _j = s\\). given (nice) selection basis rows, one may construct unique LMFD representation rational matrix. particular, choose described “canonical” basis one obtains called echelon form left matrix fraction description rational matrix. procedure implemented tool pseries2lmfd(). S3 method .lmfd.pseries() just wrapper function, calls pseries2lmfd() default parameters. Quite analogously one may also construct statespace realization \\(k(\\cdot)\\) Ho-Kalman algorithm. See tools pseries2stsp() .stsp.pseries(). detailed discussion Kronecker indices echelon canonical forms, see @Hannan.Deistler12.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"examples","dir":"Articles","previous_headings":"Operations and Methods > Convert from Class x to Class y","what":"Examples","title":"Rational Matrices","text":"first create random \\((2 \\times 2)\\) rational matrix statespace form state dimension \\(s=5\\). Generically first \\(s\\) rows Hankel matrix form basis hence Kronecker indices \\(\\nu_1 = 3\\) \\(\\nu_2=2\\): Next take impulse response function compute statespace realization rational matrix echelon form: may also create rational matrix prescribed Kronecker indices. generate \\((3\\times 2)\\) matrix Kronecker indices \\(\\nu =(2,3,1)\\) addition demand matrix stable. .e. matrix poles inside unit circle: LMFD realization matrix \\(X\\) obtained s follows set \\((1,2,3,5,6,7)\\) correspond nice selection rows Hankel matrix (\\(m=3\\)). corresponding set rows (using described “double indices”) \\(\\mathcal{S}=\\{h(1,1),h(1,2),h(1,3),h(2,2),h(2,3),h(3,1)\\}\\). set \\(\\mathcal{S}\\) contains row \\(h(3,1)\\) row \\(h(2,1)\\) hence nice selection. Therefore function basis2nu throws error, try compute correponding Kronecker indices:","code":"# create a random rational matrix in statespace form X = test_stsp(dim = c(2,2), s = 5, digits = 2) X #> statespace realization [2,2] with s = 5 states #>       s[1]  s[2]  s[3]  s[4]  s[5]  u[1]  u[2] #> s[1] -0.35  0.43 -1.05 -2.39  2.21  1.16  1.26 #> s[2]  1.02 -0.63 -0.77  0.48  0.07 -0.23  0.20 #> s[3]  0.19  0.94 -1.37  0.86 -0.18  1.31 -1.33 #> s[4] -0.82  1.04  1.90 -1.05 -0.40 -0.14  0.00 #> s[5]  0.39  0.23  0.78  0.86 -1.85  0.74  0.32 #> x[1]  0.56  1.66 -1.39 -0.09  0.92  1.00  0.00 #> x[2]  0.73 -2.23 -1.21  0.65  1.09  0.00  1.00  # compute the impulse response function, # the Kornecker indices and the corresponding indices of the \"basis\" rows. K = pseries(X, lag.max = 10) nu = pseries2nu(K) cat('Kronecker indices: ', nu,'\\n',     '      basis rows: ', nu2basis(nu)) #> Kronecker indices:  3 2  #>        basis rows:  1 2 3 4 5 X = pseries2stsp(K, method = 'echelon')$Xs print(X, digits = 2) #> statespace realization [2,2] with s = 5 states #>       s[1]  s[2]  s[3]  s[4]  s[5]  u[1]  u[2] #> s[1]  0.00  0.00  1.00  0.00  0.00 -0.86  3.18 #> s[2]  0.00  0.00  0.00  1.00  0.00  0.49  2.43 #> s[3]  0.00  0.00  0.00  0.00  1.00  3.23  0.90 #> s[4] -3.17 -3.52 -1.21 -4.29 -0.11  2.53 -9.75 #> s[5] -3.94 -3.03  1.04 -2.51 -0.96 -2.63  2.83 #> x[1]  1.00  0.00  0.00  0.00  0.00  1.00  0.00 #> x[2]  0.00  1.00  0.00  0.00  0.00  0.00  1.00  # check the result all.equal(pseries(X, lag.max = 10), K) #> [1] TRUE nu = c(2,3,1) X = test_stsp(dim = c(3,2), nu = nu, D = matrix(c(1,NA,NA, 0, 1, NA), nrow = 3, ncol = 2),               digits = 2, bpoles = 1) X #> statespace realization [3,2] with s = 6 states #>       s[1] s[2]  s[3] s[4]  s[5] s[6]  u[1]  u[2] #> s[1]  0.00 0.00  0.00 1.00  0.00 0.00  1.47 -0.02 #> s[2]  0.00 0.00  0.00 0.00  1.00 0.00 -1.51 -0.21 #> s[3] -0.06 0.16  0.50 1.11 -0.67 0.00 -0.32 -0.70 #> s[4] -0.24 0.58  0.26 0.23 -0.42 0.00 -1.75 -0.45 #> s[5]  0.00 0.00  0.00 0.00  0.00 1.00 -0.52 -0.44 #> s[6]  0.59 0.23 -0.19 0.82 -0.13 0.53 -1.13  0.93 #> x[1]  1.00 0.00  0.00 0.00  0.00 0.00  1.00  0.00 #> x[2]  0.00 1.00  0.00 0.00  0.00 0.00  0.61  1.00 #> x[3]  0.00 0.00  1.00 0.00  0.00 0.00  0.80  0.55  # compute impulse response K = pseries(X, lag.max = 10) # and check the Kronecker indices all.equal(pseries2nu(K), nu) #> [1] TRUE X = pseries2lmfd(K)$Xl X #> ( 3 x 2 ) left matrix fraction description a^(-1)(z) b(z) with degrees (p = 3, q = 3) #> left factor a(z): #>      z^0 [,1]  [,2]  [,3] z^1 [,1]  [,2]  [,3] z^2 [,1]  [,2]  [,3] z^3 [,1] #> [1,]     1.00  0.00     0    -0.23  0.42   0.0     0.24 -0.58 -0.26     0.00 #> [2,]     0.00  1.00     0     0.00 -0.53   0.0    -0.82  0.13  0.00    -0.59 #> [3,]    -1.11  0.67     1     0.06 -0.16  -0.5     0.00  0.00  0.00     0.00 #>       [,2]  [,3] #> [1,]  0.00  0.00 #> [2,] -0.23  0.19 #> [3,]  0.00  0.00 #> right factor b(z): #>      z^0 [,1]  [,2] z^1 [,1]    [,2] z^2 [,1]    [,2] z^3 [,1]   [,2] #> [1,]   1.0000  0.00   1.4962  0.4000  -3.0441 -1.2566   0.0000 0.0000 #> [2,]   0.6100  1.00  -1.8333 -0.7400  -0.4604 -0.1987  -2.8344 1.0268 #> [3,]   0.0987  1.22  -3.4010 -1.2535   0.0000  0.0000   0.0000 0.0000  all.equal(pseries(X, lag.max = 10), K) #> [1] TRUE basis = c(1,2,3,5,6,7) nu = try(basis2nu(basis, m= 3)) #> Error in basis2nu(basis, m = 3) :  #>   This is not a nice basis, i.e. there are holes."},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"arithmetics","dir":"Articles","previous_headings":"Operations and Methods","what":"Arithmetics","title":"Rational Matrices","text":"group method function Ops.ratm() allows perform arithmetic operations rational matrices using ordinary arithmetic operators.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"the-unary-operators-a-and--a","dir":"Articles","previous_headings":"Operations and Methods > Arithmetics","what":"The Unary Operators +a and -a","title":"Rational Matrices","text":"operators usual meaning implemented rational matrix classes.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"the-power-operator-ak","dir":"Articles","previous_headings":"Operations and Methods > Arithmetics","what":"The Power Operator a^k","title":"Rational Matrices","text":"power operator ^k implemented square, rational matrices \\((z)\\) integers \\(k \\\\mathbb{Z}\\). ^0 works classes returns identity matrix, represented object class input argument . Note: means e.g. \\(0^0 = 1\\)! ^1 works classes simply returns input argument . ^k \\(k>1\\) implemented classes. However lmfd objects first coerced statespace realizations. Thus result case object class stsp. cases, result class input argument . ^k \\(k<0\\) implemented classes. However, \\(\\) must non empty objects class polm lmfd first coerced stsp objects. means result class stsp input polm, lmfd stsp object class pseries zvalues input pseries respectively zvalues object.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"binary-operators","dir":"Articles","previous_headings":"Operations and Methods > Arithmetics","what":"Binary Operators","title":"Rational Matrices","text":"binary operators (like ‘+ b’) two arguments first coerced common class. end use following pseudo ordering classes: matrix \\(\\;\\prec\\;\\) polm \\(\\;\\prec\\;\\) lmfd \\(\\;\\prec\\;\\) stsp \\(\\;\\prec\\;\\) pseries \\(\\;\\prec\\;\\) zvalues following table shows class result depends classes b:  Note: Objects “rational matrices” first coerced polm objects. fails error thrown. table case represented label matrix. lmfd objects first coerced stsp objects. two pseries objects combined truncated minimum respective number “lags”. Two zvalues objects combined “z” values identical. Otherwise error thrown. statespace realizations computed general minimal. remark also applies operations, like power ^k. course two arguments must compatible, e.g. elementwise operations must number rows columns. However elementwise operations one arguments may scalar, .e. \\((1 \\times 1)\\) matrix. arguments “expanded” matrices (compatible dimension) identical elements. automatic coercion pseries objects zvalues objects, since guarantee pseries object sufficiently many lags. course user may perform coercion manually. table applies addition +b substraction -b elementwise multiplication * b matrix multiplication %r% b bind operations rbind(,b,...) cbind(,b,...) polynomial division remainder operators %/% b %% b implemented polm objects objects may coerced polm objects. operations also elementwise operations hence remark scalar arguments applies .","code":""},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"ordinary-transpose-xz","dir":"Articles","previous_headings":"Operations and Methods > Transposition of Rational Matrices","what":"“Ordinary” transpose \\(x'(z)\\)","title":"Rational Matrices","text":"transposition operator (function) t(x) implemented classes, except lmfd objects, .e. rational matrices LMFD form (work expected). example consider construction Right Matrix Fraction Description rational matrix \\(x(z) = b(z)^{-1}(z)\\). trick simply construct LMFD transpose \\(x'(z) = \\hat{}^{-1}(z) \\hat{b}(z)\\), \\(\\hat{b}'(z)(\\hat{}')^{-1}(z) = x(z)\\) desired RMFD \\(x(z)\\):","code":"# create random rational, stable, (3 x 2) matrix in statespace form x = test_stsp(dim = c(3,2), s = 2, bpoles = 1)  # compute the impulse response k = pseries(x, lag.max = 5)  # Compute an LMFD realization of the transpose tx = as.lmfd(t(k))  a = t(tx$a) b = t(tx$b)  # check all.equal(zvalues(x), zvalues(b) %r% (zvalues(a)^{-1})) #> [1] TRUE"},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"hermitean-transpose-xz","dir":"Articles","previous_headings":"Operations and Methods > Transposition of Rational Matrices","what":"Hermitean transpose \\(x^*(z)\\)","title":"Rational Matrices","text":"Hermitean transpose Ht(x) implemented frequency response objects statespace realizations regular state transition matrix \\(\\). Hermitean transpose rational matrix \\((z)\\) defined \\[ ^*(z) = \\overline{(\\bar{z}^{-1})}' \\] \\((z)\\) real coefficients \\(|z|=1\\) \\(^*(z)=\\overline{(z)}'\\). example consider \\[ (z) = \\frac{1+0.5z}{1+0.1z+0.1z^2+0.1z^3-0.8z^4} \\]  Hermitean transpose plays important role spectral density VARMA processes processes defined via statespace models.","code":"(a = as.stsp(lmfd(c(1,0.1,0.1,0.1,-0.8),c(1,0.5)))) #> statespace realization [1,1] with s = 4 states #>      s[1] s[2] s[3] s[4]    u[1] #> s[1] -0.1 -0.1 -0.1  0.8  0.7866 #> s[2]  1.0  0.0  0.0  0.0 -0.1260 #> s[3]  0.0  1.0  0.0  0.0 -0.1400 #> s[4]  0.0  0.0  1.0  0.0  0.4000 #> x[1]  0.0  0.0  0.0  1.0  1.0000  fr = zvalues(a, n.f = 101) sp = fr %r% Ht(fr) max(abs(Im(sp))) #> [1] 0 all.equal(sp, zvalues(a %r% Ht(a), n.f = 101)) #> [1] TRUE plot(sp)"},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"bind-rational-matrices-by-rows-and-columns","dir":"Articles","previous_headings":"Operations and Methods","what":"Bind Rational Matrices by Rows and Columns","title":"Rational Matrices","text":"methods rbind(...) cbind(...) usual meaning, .e. take list rational matrix objects combine rows columns. matrices combined coerced objects class, described section arithmetic operations. particular note lmfd objects coerced stsp objects! Howver, one argument given coercion performed, .e. x lmfd object bind(x) returns lmfd object. Note statespace realizations general minimal. number lags pseries objects minimum number lags . Objects class zvalues combined z attributes (complex points rational function(s) evaluated) identical.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"extract-parts-replace-parts","dir":"Articles","previous_headings":"Operations and Methods","what":"Extract Parts, Replace Parts","title":"Rational Matrices","text":"subsetting operation x[,] rational matrices works analogously subsetting ordinary matrices. result object class. However, operator implemented lmfd objects. Hence x[,j] throws error x lmfd object! x[] x[,] simply return object x. x[] returns \\((s,1)\\) dimensional matrix elements selected index . x[,j] returns matrix rows selected columns selected j. $ operator may used extract \\(\\), \\(b\\) polynomial left matrix fraction description (lmfd object) matrices \\(,B,C,D\\) state space representation (stsp object). assigment operation x[,] <- value implemented polynomial matrices works quite analogously assigment operation “ordinary” matrices. Note: subsetting assigment operators allow “named” arguments. Therefore following statements throw error","code":"x = test_polm(dim = c(2,3), degree = 2) x #> ( 2 x 3 ) matrix polynomial with degree <= 2  #>      z^0 [,1]  [,2]  [,3] z^1 [,1]  [,2]  [,3] z^2 [,1]  [,2]  [,3] #> [1,]      110   120   130      111   121   131      112   122   132 #> [2,]      210   220   230      211   221   231      212   222   232 x[,] #> ( 2 x 3 ) matrix polynomial with degree <= 2  #>      z^0 [,1]  [,2]  [,3] z^1 [,1]  [,2]  [,3] z^2 [,1]  [,2]  [,3] #> [1,]      110   120   130      111   121   131      112   122   132 #> [2,]      210   220   230      211   221   231      212   222   232 x[c(1,2,6)] #> ( 3 x 1 ) matrix polynomial with degree <= 2  #>      z^0 [,1] z^1 [,1] z^2 [,1] #> [1,]      110      111      112 #> [2,]      210      211      212 #> [3,]      230      231      232 x[c(2,1), c(2,2,2)] #> ( 2 x 3 ) matrix polynomial with degree <= 2  #>      z^0 [,1]  [,2]  [,3] z^1 [,1]  [,2]  [,3] z^2 [,1]  [,2]  [,3] #> [1,]      220   220   220      221   221   221      222   222   222 #> [2,]      120   120   120      121   121   121      122   122   122  x = test_stsp(dim = c(3,3), s = 6) # the statements pseries(x[c(2,4)]) and pseries(x)[c(2,4)] are equivalent all.equal(pseries(x[c(2,4)]), pseries(x)[c(2,4)]) #> [1] TRUE  x = test_lmfd(dim = c(2,3), degrees = c(1,1)) try(x[,])  # throws an error #> ( 2 x 3 ) left matrix fraction description a^(-1)(z) b(z) with degrees (p = 1, q = 1) #> left factor a(z): #>      z^0 [,1]  [,2] z^1 [,1]       [,2] #> [1,]        1     0 1.103029 -1.3916966 #> [2,]        0     1 1.037564  0.1413492 #> right factor b(z): #>      z^0 [,1]     [,2]      [,3]   z^1 [,1]       [,2]      [,3] #> [1,] 1.396792 1.102716 0.6893530 -0.9366515 -1.7307931 1.2415333 #> [2,] 1.477923 2.094810 0.2146849  0.2121534  0.8942118 0.2735926 # extract a(z) polynomial x$a #> ( 2 x 2 ) matrix polynomial with degree <= 1  #>      z^0 [,1]  [,2] z^1 [,1]       [,2] #> [1,]        1     0 1.103029 -1.3916966 #> [2,]        0     1 1.037564  0.1413492 a = test_polm(dim = c(3,2), degree = 1) print(a, format = 'c') #> ( 3 x 2 ) matrix polynomial with degree <= 1  #>             [,1]        [,2] #> [1,]  110 + 111z  120 + 121z #> [2,]  210 + 211z  220 + 221z #> [3,]  310 + 311z  320 + 321z  # no items to replace, a is not changed a[FALSE] = 0    print(a, format = 'c') #> ( 3 x 2 ) matrix polynomial with degree <= 1  #>             [,1]        [,2] #> [1,]  110 + 111z  120 + 121z #> [2,]  210 + 211z  220 + 221z #> [3,]  310 + 311z  320 + 321z  # set elements below the diagonal equal to zero a[lower.tri(matrix(0, nrow = 3, ncol = 2))] = 0 print(a, format = 'c') #> ( 3 x 2 ) matrix polynomial with degree <= 1  #>             [,1]        [,2] #> [1,]  110 + 111z  120 + 121z #> [2,]           0  220 + 221z #> [3,]           0           0  # set (3,1) element a[3,1] = c(1,-1) print(a, format = 'c') #> ( 3 x 2 ) matrix polynomial with degree <= 1  #>             [,1]        [,2] #> [1,]  110 + 111z  120 + 121z #> [2,]           0  220 + 221z #> [3,]       1 - z           0  # set the elements in the first two rows and columns a[1:2, 2:1] = array(c(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),                     dim = c(2,2,4)) print(a, format = 'c') #> ( 3 x 2 ) matrix polynomial with degree <= 3  #>        [,1]  [,2] #> [1,]    z^2     1 #> [2,]    z^3     z #> [3,]  1 - z     0  # this produces a warning,   # left hand side refers to 3 elements but # the right hand side has 2 elements! a[, 1] = test_polm(dim = c(2,1), degree = 4) #> Warning in `[<-.polm`(`*tmp*`, , 1, value = structure(c(110, 210, 111, 211, : #> number of items to replace is not a multiple of replacement length print(a, format = 'c') #> ( 3 x 2 ) matrix polynomial with degree <= 4  #>                                        [,1]  [,2] #> [1,]  110 + 111z + 112z^2 + 113z^3 + 114z^4     1 #> [2,]  210 + 211z + 212z^2 + 213z^3 + 214z^4     z #> [3,]  110 + 111z + 112z^2 + 113z^3 + 114z^4     0 try(a[i=1, j=2]) #> Error in `[.polm`(a, i = 1, j = 2) : named dimensions are not supported try(a[i=1] <- 1) #> Error in `[<-.polm`(`*tmp*`, i = 1, value = 1) :  #>   named dimensions are not supported"},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"polynomials","dir":"Articles","previous_headings":"Operations and Methods > Poles and Zeroes","what":"Polynomials","title":"Rational Matrices","text":"zeroes square (\\(m\\times m\\))-dimensional, non singular polynomial matrix \\((z)=a_0+a_1z+\\cdots a_p z^p\\), \\(\\det(a_0)\\neq 0\\) reciprocals non zero eigenvalues companion matrix \\[ = \\begin{pmatrix} -a_0^{-1}a_1 & \\cdots & -a_0^{-1} a_{p-1} & -a_0^{-1} a_p \\\\ I_m          & \\cdots & 0                 &          0    \\\\ \\vdots       & \\ddots & \\vdots            &     \\vdots    \\\\ 0            & \\cdots & I_m               &           0 \\end{pmatrix} \\\\mathbb{R}^{mp\\times mp} \\] fact used zeroes.polm. However, problems (simple) approach. work polynomials zero \\(z=0\\) (\\(a_0\\) singular). alternative use function .coprime uses (singular) pencil. See examples . Due numerical errors function eigen (used compute eigenvalues companion matrix) may return (small) eigenvalues instead exact zeroes. function zeroes.polm therefore skips eigenvalues smaller certain threshold. option print_message set TRUE corresponding message printed. Clearly, choosing small tolerance bound may result large “spurious”” zeroes. hand bound large, “true” zeroes may skipped. summarize. numerical problems coefficient \\(a_0\\) ill conditioned companion matrix \\(\\) (close ) singular.","code":"# polynomial with degree p = 0 ############################## zeroes(polm(diag(3)))  # returns empty vector #> numeric(0)  # (2 x 2) polynomial with degree 2 ########################## a = test_polm(dim = c(2,2), degree = 2) (z = zeroes(a)) #> [1] -0.5-0.8660254i -0.5+0.8660254i -0.5-0.8660254i -0.5+0.8660254i  # check the rank of a(z) at the computed zeroes az = unclass(zvalues(a, z)) apply(az, MARGIN = 3, FUN = function(x) {d = svd(x)$d; min(d)/max(d)}) #> [1] 5.368273e-14 5.368273e-14 5.364620e-14 5.364620e-14  # (2 x 2) polynomial with degree 2 ########################## # and singular coefficient matrix a[2] a = test_polm(dim = c(2,2), degree = 2,                col_end_matrix = matrix(1, nrow = 2, ncol =2) ) (z = zeroes(a)) #> [1] -0.5-0.8660254i -0.5+0.8660254i -0.5-0.8660254i -0.5+0.8660254i  # alternatively, we may also use is.coprime() is.coprime(a, only.answer = FALSE)$zeroes #> [1] -0.5+0.8660254i -0.5-0.8660254i -0.5+0.8660254i -0.5-0.8660254i  # (2x2) polynomial matrix with degree 2 ##################### # and singular coefficient matrix a[0] a = polm(dbind(d = 3, matrix(1, nrow = 2, ncol = 2),                       test_array(dim = c(2,2,2))))  # zeroes(a) throws an error! try(zeroes(a)) #> Error in zeroes.polm(a) :  #>   Could not generate companion matrix. Coefficient pertaining to smallest degree might be singular.  # However, we may use is.coprime() in this case is.coprime(a, only.answer = FALSE)$zeroes #> [1] -1.000000e+00 -1.000000e+00 -7.917564e-10  7.917563e-10"},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"left-matrix-fraction-descriptions","dir":"Articles","previous_headings":"Operations and Methods > Poles and Zeroes","what":"Left Matrix Fraction Descriptions","title":"Rational Matrices","text":"Suppose \\(c(z)= ^{-1}(z) b(z)\\) \\((m \\times n)\\) dimensional rational matrix (\\(\\) \\(b\\) polynomials). \\((,b)\\) left coprime poles \\(c\\) zeroes \\(\\). Furthermore \\(c\\) square, zeroes \\(c\\) zeroes \\(b\\). Therefore methods poles.lmfd zeroes.lmfd simply use zeroes.polm order compute poles zeroes rational matrix given LMFD form. implies caveats also apply . E.g. methods work case \\(a_0\\) (respectively \\(b_0\\)) non singular. addition routines provide correct answers case pair \\((,b)\\) left coprime. pole/zero cancellation may occur, taken account methods poles.lmfd zeroes.lmfd. means functions may return spurious poles zeroes. Now construct LMFD ,b coprime. simply simply multiply matrices \\(,b\\) common factor \\(r\\) note \\((r )^{-1} (r b) = ^{-1} b = c\\).","code":"# create a random rational (2 x 2) matrix in LMFD form with p = 1, q = 2 # note that two random polynomials are \"generically\" left coprime set.seed(8924) a = test_polm(dim = c(2,2), degree = 1, random = TRUE) b = test_polm(dim = c(2,2), degree = 2, random = TRUE) c = lmfd(a,b)  # poles of c=a^{-1}b  are the zeroes of a poles(c) #> [1]  0.4136219 -0.9481900 all.equal(sort(poles(c)), sort(zeroes(a))) #> [1] TRUE  # zeroes of c=a^{-1}b  are the zeroes of b zeroes(c) #> [1]  0.01188418+0.0000000i -0.44699481+0.0000000i -0.07539272-0.8587459i #> [4] -0.07539272+0.8587459i all.equal(sort(zeroes(c)), sort(zeroes(b))) #> [1] TRUE # generate random common factor r = test_polm(dim = c(2,2), degree = 1, random = TRUE) ra = r %r% a rb = r %r% b cc = lmfd(ra,rb)  # here we get two \"spurious\" poles/zeroes (pz = round(poles(cc), 6)) #> [1]  0.413622 -0.817746 -0.948190  2.707221 (zz = round(zeroes(cc), 6)) #> [1]  0.011884+0.000000i -0.446995+0.000000i -0.817746+0.000000i #> [4] -0.075393-0.858746i -0.075393+0.858746i  2.707221+0.000000i  # the zeroes of r pop up as poles and zeroes of cc sort(round(zeroes(r), 6)) #> [1] -0.817746  2.707221 sort(intersect(pz, zz)) #> [1] -0.817746+0i  2.707221+0i  set.seed(NULL)"},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"statespace-representation-1","dir":"Articles","previous_headings":"Operations and Methods > Poles and Zeroes","what":"Statespace Representation","title":"Rational Matrices","text":"Let \\(k(z) = C(z^{-1}- )^{-1}B + D\\) rational matrix, given state space form. statespace representation minimal poles \\(k\\) reciprocals non zero eigenvalues \\(\\). Furthermore \\(k\\) square \\(D\\) regular (.e. \\(k(0)=D\\) regular) zeroes \\(k\\) reciprocals eigenvalues matrix \\((-BD^{-1}C)\\). methods poles.stsp zeroes.stsp therefore compute poles (zeroes) \\(k\\) via eigenvalues \\(\\) (respectively \\((-BD^{-1}C)\\)). However, check whether statespace realization minimal. analogous warnings place polynomial LMFD case: procedures may return “spurious” poles zeroes representation minimal. procedures use threshold (tol) order decide whether small eigenvalue returned eigen due “true zero” eigenvalue . computation zeroes implemented case \\(k\\) zero \\(z=0\\). \\(D\\) ill conditioned results may unreliable.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"checks","dir":"Articles","previous_headings":"Operations and Methods","what":"Checks","title":"Rational Matrices","text":".stable() checks whether rational matrix poles withing unit circle. .miniphase() checks whether rational matrix zeroes within unit circle. test function just return TRUE FALSE. poles zeroes rational matrix computed via functions poles zeroes respectively. Hence caveats also apply . pseries zvalues objects functions return NA.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"is-coprime","dir":"Articles","previous_headings":"Operations and Methods > Checks","what":"is.coprime()","title":"Rational Matrices","text":"polynomial matrix \\(c\\) called left prime, \\(c(z)\\) full row rank everywhere complex plane. Clearly implies \\(c\\) square “wide”, .e. \\(c\\) \\((m \\times n)\\)-dimensional \\(m \\leq n\\) must hold. pair \\((,b)\\) (compatible) polynomial matrices called left coprime matrix \\(c=[,b]\\) left prime. case important structure left matrix fraction descriptions. Suppose \\(c(z)=^{-1} b(z)\\), \\(\\) square, non singular polynomial matrix. pair \\((,b)\\) left coprime, may cancel common, non unimodular, factor thus obtain “simpler” representation \\(c(z)\\). function .coprime may called following syntax: test_coprime(c) c lmfd object, represents rational matrix \\(c(z)=^{-1}(z)b(z)\\), checks whether pair \\((,b)\\) left coprime. test_coprime() polm object, represents polynomial matrix \\((z)\\), checks whether \\(\\) left prime. test_coprime(,b) , b polm objects, represent polynomial matrices \\(\\) \\(b\\), checks whether pair \\((,b)\\) left coprime. implementation details see vignette .","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"is-minimal","dir":"Articles","previous_headings":"Operations and Methods > Checks","what":"is.minimal()","title":"Rational Matrices","text":"statespace realization \\((,B,C,D)\\) minimal Hankel matrix impulse response coefficients \\(k_i = CA^{-1}B\\), \\(\\geq 1\\) \\[ \\begin{pmatrix} k_1 & k_2     & \\cdots & k_s \\\\ k_2 & k_3     & \\cdots & k_{s+1} \\\\ \\vdots & \\vdots &      & \\vdots  \\\\ k_s & k_{s+1} & \\cdots & k_{2s-1}                    \\end{pmatrix} \\\\mathbb{R}^{ms\\times ns} \\] rank \\(s\\). Therefore procedure .minimal() computes SVD matrix returns TRUE \\(s\\)-th singular value larger given threshold tol. order check whether statespace realization observable /controllable one may consider observability controllability matrices (may computed obs_matrix ctr_matrix) corresponding Grammians (see grammians). Note operations stsp objects may return non minimal realizations. E.g.: s0 estimate minimal statespace dimension. order construct minimal realization one may use procedure balance.","code":"x = test_stsp(dim = c(2,2), s = 2) is.minimal(x) #> [1] TRUE is.minimal(rbind(x, x), only.answer = FALSE)[c('answer','sv','s0')] #> $answer #> [1] FALSE #>  #> $sv #> [1] 4.162446e+01 3.633925e+01 8.488171e-15 3.808400e-15 2.729067e-15 #> [6] 1.720477e-15 3.473458e-16 1.601466e-16 #>  #> $s0 #> [1] 2 is.minimal(x %r% (x^(-1)), only.answer = FALSE)[c('answer','sv','s0')] #> $answer #> [1] FALSE #>  #> $sv #> [1] 1.299743e-13 2.951303e-14 1.377293e-14 6.906353e-15 1.172737e-15 #> [6] 5.418091e-16 1.614441e-16 8.025565e-17 #>  #> $s0 #> [1] 0"},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"derivatives","dir":"Articles","previous_headings":"Operations and Methods","what":"Derivatives","title":"Rational Matrices","text":"derivative rational function (respect argument \\(z\\)) may computed S3 method derivative. However, lmfd zvalues objects supported. simply example consider polynomial degree \\(4\\) derivatives:  Note computing derivative impulse response object decreases number lags one!","code":"a = polm(1) for (x in c(-2,-1,1,2)) {   a = a * polm(c(1, -1/x)) } print(a, format = 'c') #> ( 1 x 1 ) matrix polynomial with degree <= 4  #>                        [,1] #> [1,]  1 - 1.25z^2 + 0.25z^4  z = seq(from = -2.25, to = 2.25, length.out = 201) out = plot(zvalues(a, z = z), x_list = list(zvalues(derivative(a)*(1/4), z = z),                                       zvalues(derivative(derivative(a))*(1/12), z = z),                                       zvalues(derivative(derivative(derivative(a)))*(1/24), z = z)),      which = 'real', legend = c(expression(a(x)), expression(frac(1,4)~frac(d*a,d*x)(x)),                                 expression(frac(1,12)~frac(d^2*a,d^2*x)(x)),                                 expression(frac(1,24)~frac(d^3*a,d^3*x)(x)))) opar = out(1,1) abline(h=0, col = 'darkgray') par(opar) x = test_stsp(dim = c(2,2), s = 12)  all.equal(pseries(derivative(x), lag.max = 10),           derivative(pseries(x, lag.max = 11))) #> [1] TRUE"},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"normal-forms","dir":"Articles","previous_headings":"Methods for Polynomials","what":"Normal Forms","title":"Rational Matrices","text":"package contains functions compute important “normal forms” polynomial matrices, e.g. Smith normal form. However, note computation normal form numerically quite tricky implementation rather simple minded. Therefore functions may fail large, complex polynomial matrices.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"hermite-normal-form","dir":"Articles","previous_headings":"Methods for Polynomials > Normal Forms","what":"Hermite Normal Form","title":"Rational Matrices","text":"polynomial matrix can transformed “quasi-upper-triangular” matrix elementary row operations, .e. multiplication unimodular matrix left. Suppose \\((z)\\) \\(m \\times n\\) dimensional matrix rank \\(r \\leq \\min(m,n)\\). \\(h(z) = u^{-1}(z) (z)\\) column Hermite form \\((z)\\), \\(u(z)\\) unimodular exist integers \\(1\\leq j() <j(2) < \\cdots < j(r)\\leq n\\) \\(h_{,j()}(z)\\) monic (coefficient pertaining highest degree equal one), elements \\(h_{,j()}(z)\\) lower polynomial degree \\(h_{,j()}(z)\\) \\(h_{,j}(z) = 0\\) \\(>r\\) \\(j < j()\\). See also @Kailath80. Quite analogously one may transform matrix \\((z)\\) elementary column operations “quasi-lower-triangular” form \\(h(z) = (z)u^{-1}(z)\\). corresponding normal form called row Hermite form. row Hermite form may obtained calling function hnf() options from_left=FALSE. Note polynomial \\((z)\\) considered R demonstration(s), row Hermite form particularly simple, since \\((z)\\) left prime. See also discussion left (co)prime matrices vignette “Technical Details”. following example \\((3,5)\\) dimensional polynomial matrix rank \\(2\\). function hnf() returns “estimate” rank “pivots” \\(j(1),j(2),\\ldots, j(r)\\).","code":"a = polm(array(c(-0.4, -1.3, -0.3,  0.6, 1.1,  1,                  -1.7,  0,   -0.8, -0.3, 3.2, -0.4), dim = c(2,3,2))) print(a, format = 'c') #> ( 2 x 3 ) matrix polynomial with degree <= 1  #>              [,1]         [,2]        [,3] #> [1,]  -0.4 - 1.7z  -0.3 - 0.8z  1.1 + 3.2z #> [2,]         -1.3   0.6 - 0.3z    1 - 0.4z  out = hnf(a) print(out$h, format = 'c', digits = 1) #> ( 2 x 3 ) matrix polynomial with degree <= 2  #>       [,1]               [,2]               [,3] #> [1,]     1        -0.5 + 0.2z        -0.8 + 0.3z #> [2,]     0  -1.2 - 3.8z + z^2  2 + 5.1z + 1.3z^2 # check the result(s) all.equal(a, prune(out$u %r% out$h)) #> [1] TRUE all.equal(polm(diag(2)), prune(out$u %r% out$u_inv)) #> [1] TRUE out = hnf(a, from_left = FALSE) print(out$h, format = 'c', digits = 1) #> ( 2 x 3 ) matrix polynomial with degree <= 0  #>       [,1]  [,2]  [,3] #> [1,]     1     0     0 #> [2,]     0     1     0 # check the result(s) all.equal(a, prune(out$h %r% out$u)) #> [1] TRUE all.equal(polm(diag(3)), prune(out$u %r% out$u_inv)) #> [1] TRUE a = polm(array(c(0,0,0,2,-1,1,2,-1,1,6,-3,3,3,0,2,0,0,0,2,-1,                  1,-2,1,-1,3,0,2,-8,1,-5,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1), dim = c(3,5,3))) print(a, format = 'c') #> ( 3 x 5 ) matrix polynomial with degree <= 2  #>       [,1]    [,2]    [,3]          [,4]          [,5] #> [1,]     0  2 + 2z  2 - 2z  6 + 3z + z^2  3 - 8z + z^2 #> [2,]     0  -1 - z  -1 + z      -3 + z^2       z + z^2 #> [3,]     0   1 + z   1 - z  3 + 2z + z^2  2 - 5z + z^2  out = hnf(a) print(out$h, format = 'c', digits = 1) #> ( 3 x 5 ) matrix polynomial with degree <= 2  #>       [,1]   [,2]   [,3]     [,4]          [,5] #> [1,]     0  1 + z  1 - z    3 + z        1 - 3z #> [2,]     0      0      0  z + z^2  1 - 2z + z^2 #> [3,]     0      0      0        0             0 print(out$rank)    # the rank of a(z) is 2 #> [1] 2 print(out$pivots)  # the columns 2 and 4 are linearly independent. #> [1] 2 4  # check the result(s) all.equal(a, prune(out$u %r% out$h)) #> [1] TRUE all.equal(polm(diag(3)), prune(out$u %r% out$u_inv)) #> [1] TRUE"},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"smith-normal-form","dir":"Articles","previous_headings":"Methods for Polynomials > Normal Forms","what":"Smith Normal Form","title":"Rational Matrices","text":"\\((m \\times n)\\) dimensional polynomial matrix \\((z)\\) rank \\(r\\leq \\min(m,n)\\) exists factorization \\[ (z) = u(z) s(z) v(z) \\] \\(u(z)\\) \\(v(z)\\) two unimodular matrices \\(s(z)\\) \\(m \\times n\\) dimensional quasi-diagonal matrix diagonal entries \\(d_i(z)\\) satisfy \\(d_i\\) monic \\(\\leq r\\) zero \\(>r\\), \\(d_i\\) divides \\(d_{+1}\\) \\(<r\\). factorization may constructed using elementary column- row- operations. details, see e.g. @Kailath80. simple example consider following \\(4 \\times 5\\) dimensional polynomial matrix","code":"set.seed(1234) # set seed for random number generation  z = polm(c(0,1)) a = matrix(c( 3, 2, 1,-3,-2,-1,0,0,0), nrow = 3, ncol = 3) - z*polm(diag(3)) # inflate this 3x3 matrix to a 4x5 matrix a = matrix(sample(c(-1:1), 4*3, replace = TRUE), nrow = 4, ncol = 3) %r% a a = a %r% matrix(sample(c(-1:1), 3*5, replace = TRUE), nrow = 3, ncol = 5) print(a, format='c') #> ( 4 x 5 ) matrix polynomial with degree <= 1  #>         [,1]  [,2]  [,3]    [,4]  [,5] #> [1,]      -1     z     0   1 + z    -z #> [2,]      -2     0     z       2     0 #> [3,]  -3 + z     0     z   3 - z     0 #> [4,]   3 - z     0    -z  -3 + z     0  out = snf(a)  print(out$s, digits = 2, format = 'c') #> ( 4 x 5 ) matrix polynomial with degree <= 2  #>       [,1]  [,2]      [,3]  [,4]  [,5] #> [1,]     1     0         0     0     0 #> [2,]     0     z         0     0     0 #> [3,]     0     0  -z + z^2     0     0 #> [4,]     0     0         0     0     0  # check result(s) all.equal(a, prune(out$u %r% out$s %r% out$v)) #> [1] TRUE  # reset seed set.seed(NULL)"},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"column-reduced-form","dir":"Articles","previous_headings":"Methods for Polynomials > Normal Forms","what":"Column Reduced Form","title":"Rational Matrices","text":"Let \\((z)=a_0 + a_1 z + \\cdots + a_p z^p\\) \\((m \\times n)\\), polynomial matrix column degrees \\(p_i\\), \\(=1,\\ldots ,n\\). column end matrix \\((z)\\) \\((m \\times n)\\) matrix \\(\\)-th column equal \\(\\)-th column coefficient matrix \\(a_{p_i}\\). \\((z)\\) square column end matrix regular, \\(\\) called column reduced. non singular, square polynomial matrix may transformed column reduced matrix sequence elementary column operations. means exists unimodular matrix \\(v(z)\\) \\((z) v^{-1}(z)\\) column reduced. task accomplished helper function col_reduce(, ...). example consider random \\((3 \\times 3)\\), polynomial matrix whose column end matrix rank 1:","code":"# create a random (3 x 3) polynmial matrix with a column end matrix of rank 1 col_end_matrix = matrix(round(rnorm(3),1), nrow = 3, ncol = 1) %*%                  matrix(round(rnorm(3),1), nrow = 1, ncol = 3) a = test_polm(dim = c(3,3), degree = c(2,1,1), random = TRUE,                digits = 2, col_end_matrix = col_end_matrix) print(a, format = 'c') #> ( 3 x 3 ) matrix polynomial with degree <= 2  #>                          [,1]           [,2]          [,3] #> [1,]    0.19 + 0.22z + 0.3z^2    1.07 - 0.3z  -1.27 - 0.5z #> [2,]   -0.4 + 0.21z + 0.06z^2   0.79 - 0.06z    0.5 - 0.1z #> [3,]  -0.49 - 1.07z + 0.12z^2  -0.56 - 0.12z   0.87 - 0.2z print(svd(col_end_matrix(a))$d)       # column end matrix has rank 1 #> [1] 7.183314e-01 1.379687e-17 4.078440e-34  out = col_reduce(a) print(out$a, format = 'c', digits = 2)   # column reduced matrix #> ( 3 x 3 ) matrix polynomial with degree <= 1  #>                [,1]           [,2]   [,3] #> [1,]    1.07 - 0.3z   0.19 + 1.29z  -3.05 #> [2,]   0.79 - 0.06z       -0.4 + z  -0.82 #> [3,]  -0.56 - 0.12z  -0.49 - 1.63z    1.8 print(out$col_degrees)                   # column degrees #> [1] 1 1 0 print(out$col_end_matrix)                # column end matrix #>       [,1]  [,2]       [,3] #> [1,] -0.30  1.29 -3.0533333 #> [2,] -0.06  1.00 -0.8166667 #> [3,] -0.12 -1.63  1.8033333 print(svd(out$col_end_matrix)$d)         # column end matrix is non singular! #> [1] 4.2389693 0.8233726 0.1549081  # check reult(s) all.equal(polm(diag(3)), prune(out$v %r% out$v_inv)) #> [1] TRUE all.equal(prune(a), prune(out$a %r% out$v)) #> [1] TRUE all.equal(col_end_matrix(out$a), out$col_end_matrix) #> [1] TRUE"},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"wiener-hopf-factorisation","dir":"Articles","previous_headings":"Methods for Polynomials > Normal Forms","what":"Wiener-Hopf Factorisation","title":"Rational Matrices","text":"Wiener-Hopf factorization (square \\((m,m)\\)-dimensional, non singular) polynomial matrix \\((z)\\) factorization form \\[ (z) = A_f(z^{-1}) A_0(z) A_b(z) = A_r(z) A_b(z), \\] \\(A_b(z)\\) polynomial matrix zeroes outside unit circle, \\(A_r(z)\\) column reduced polynomial matrix column degrees \\(\\kappa_i\\) \\(=1,\\ldots,m\\) zeroes inside unit circle, \\(A_0(z)\\) diagonal matrix diagonal entries \\(z^{\\kappa_i}\\) \\(A_f(z^{-1}) = A_r(z)A_0^{-1}(z)\\) polynomial \\(z^{-1}\\)! factors \\(A_f(z^{-1})\\), \\(A_0(z)\\), \\(A_b(z)\\) called forward, null backward components \\((z)\\), integers \\((\\kappa_1,\\ldots,\\kappa_n)\\) partial indices \\((z)\\). Note zeroes unit circle allowed. Wiener-Hopf factorization plays important role analysis linear, rational expectation models. See e.g. @Al-Sadoon2017. WHF constructed three steps first compute Smith form \\((z)= u(z) s(z) v(z)\\) diagonal entry \\(d_i\\) factored polynomial zeroes inside, respectivly outside unit circle. Let \\(s(z) = s_r(z) s_b (z)\\) denote corresponding factorization \\(s(z)\\). gives \\((z) = (u(z) s_r(z)) (s_b(z) v(z))\\). compute column reduced form \\((u(z) s_r(z)) = A_r(z) w(z)\\) set \\(A_b = w^{-1}(z) s_b(z) v(z)\\). Let \\(\\kappa_i\\) denote columnn degrees \\(A_r(z)\\) set \\(A_f(z^{-1}) = A_r(z) \\mbox{diag}(z^{-\\kappa_i})\\). Note construction \\(A_f(z^{-1})\\) polynomial \\(z^{-1}\\). Simulation example:","code":"set.seed(54321)  # create test polynomial a = test_polm(dim = c(4,4), deg = 2, digits = 2, random = TRUE)  # compute WHF and print the result out = whf(a)  print(out$af, digits = 2, format = 'c') #> ( 4 x 4 ) Laurent polynomial matrix with degree <= 0, and minimal degree >= -1 #>                 [,1]             [,2]              [,3]   [,4] #> [1,]               0         0.76z^-1             -1.59   1.57 #> [2,]               0                0                 0  -0.62 #> [3,]  2.6z^-1 - 4.83  -3.6z^-1 + 3.51   0.04z^-1 + 3.58  -3.35 #> [4,]   -2.61z^-1 + 6  4.19z^-1 - 6.26  -2.29z^-1 - 0.31    2.5 print(out$a0, digits = 2, format = 'c') #> ( 4 x 4 ) matrix polynomial with degree <= 1  #>       [,1]  [,2]  [,3]  [,4] #> [1,]     z     0     0     0 #> [2,]     0     z     0     0 #> [3,]     0     0     z     0 #> [4,]     0     0     0     1 print(out$ab, digits = 2, format = 'c') #> ( 4 x 4 ) matrix polynomial with degree <= 2  #>                         [,1]                    [,2]                     [,3]           [,4] #> [1,]           -2.99 + 5.26z           -4.16 - 1.04z             2.63 + 0.28z       3.13 - z #> [2,]           -3.35 + 5.61z           -4.22 - 1.11z             2.45 - 0.27z   3.69 - 1.06z #> [3,]           -0.35 + 3.09z           -2.13 - 0.92z             0.61 - 0.79z   2.06 - 0.57z #> [4,]  1.51 - 1.88z + 1.81z^2  1.78 - 0.79z - 0.86z^2  -0.29 - 0.08z - 1.26z^2  -0.84 + 2.07z  # check the result all.equal(a, prune(out$ar %r% out$ab))           # A = Ar * Ab #> [1] TRUE  # check A(z) = Ab(z^{-1}) A0(z) Ab(z) # generate random complex z's z = complex(real = rnorm(10), imaginary = rnorm(10)) a_z  = zvalues(a, z)         # A(z) ab_z = zvalues(out$ab, z)    # Ab(z) a0_z = zvalues(out$a0, z)    # A0(z) af_z = zvalues(out$af, 1/z)  # Af(z^{-1})   attr(af_z, 'z') = z           # in order to combine the 'zvalues' objects,                               # the attribute 'z' must be identical all.equal(a_z, af_z %r% a0_z %r% ab_z) #> [1] \"Mean relative Mod difference: 3.086469\"  all.equal(out$idx, degree(out$ar, 'columns'))    # idx = column degrees of Ar #> [1] TRUE all(svd(col_end_matrix(out$ar))$d > 1e-7)     # Ar is column reduced #> [1] TRUE all(abs(zeroes(out$ar, print_message = FALSE)) < 1)  # Ar has zeroes inside the unit circle #> [1] TRUE all(abs(zeroes(out$ab, print_message = FALSE)) > 1)  # Ab zeroes outside the unit circle #> [1] TRUE  set.seed(NULL)"},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"blaschke","dir":"Articles","previous_headings":"Methods for Polynomials","what":"Reflect Zeroes by Multiplication with All Pass Matrices","title":"Rational Matrices","text":"Blaschke factor rational function form \\[ (z) = \\frac{1-\\bar{\\alpha}z}{-\\alpha + z}\\frac{\\alpha}{\\bar{\\alpha}} \\] function pass, .e. \\[ (z) ^*(z) = \\left(\\frac{1-\\bar{\\alpha}z}{-\\alpha + z}\\frac{\\alpha}{\\bar{\\alpha}}\\right)               \\left(\\frac{1-\\alpha z^{-1}}{-\\bar{\\alpha} + z^{-1}}\\frac{\\bar{\\alpha}}{\\alpha}\\right)             =  \\left(\\frac{1-\\bar{\\alpha}z}{-\\alpha + z}\\right)               \\left(\\frac{z-\\alpha}{-\\bar{\\alpha}z + 1}\\right) = 1 \\] multiply (scalar) polynomial \\(p(z)\\), zero \\(z=\\alpha\\), Blascke factor obtain new polynomial, \\(\\tilde{p}(z) = p(z)(z)\\) say, zero \\(z=\\alpha\\) replaced zeroe \\(z=1/\\bar{\\alpha}\\). Furthermore polynomial generate spectral density, .e. \\[ \\tilde{p}(z) \\tilde{p}^*(z) = p(z) (z) ^*(z) p^*(z) = p(z) p^*(z) \\] \\(p(z)\\) real polynomial root \\(z=\\alpha\\) complex polynomial \\(\\tilde{p}\\) complex coefficients. However, also flip conjugated root \\(z=\\bar{\\alpha}\\) obtain polynomial real coefficients. means polynomial \\[ p(z)\\left(\\frac{1-\\bar{\\alpha}z}{-\\alpha + z}\\frac{\\alpha}{\\bar{\\alpha}}\\right)     \\left(\\frac{1-\\alpha z}{-\\bar{\\alpha} + z}\\frac{\\bar{\\alpha}}{\\alpha}\\right) \\] real coefficients (“flipped roots” \\(1/\\bar{\\alpha}\\) \\(1/\\alpha\\)). multiplication (univariate) Blaschke factor implemented routine blaschke_univariate(). procedure may generalized polynomial matrices, see blaschke_multivariate. Suppose \\(p(z)\\) \\((m \\times n)\\) dimensional polynomial matrix \\(\\alpha\\) root, .e \\(p(\\alpha)\\) singular. Let \\(p(\\alpha)=U\\Sigma V^*\\) denote SVD \\(p(\\alpha)\\) last row \\(U^* p(\\alpha)\\) zero, .e. \\((z-\\alpha)\\) divides entries last row. multiply last row corresponding Blaschke factor, obtain matrix polynomial, root \\(\\alpha\\) replaced root \\(1/\\bar{\\alpha}\\). (least “multiplicity” root \\(\\alpha\\) reduced one.) \\(\\alpha\\) complex “blaschkerize” also conjugate root \\(\\bar{\\alpha}\\) multiply result suitable unitary matrix (see helper function transform_polar4real) order obtain polynomial matrix real coeffcients. task accomplished blaschke_multivariate. want flip set roots, utility transform_allpass may used.","code":"set.seed(1719) m0 = test_polm(dim = c(2,2), degree = 2, digits = 2, random = TRUE)  m = m0 * (1 - polm(c(0,1))) mz = zeroes(m) mz #> [1]  0.1255159+0.000000i  1.0000000+0.000000i  1.0000000+0.000000i #> [4]  0.1371003-1.270166i  0.1371003+1.270166i -2.4509944+0.000000i  bm = try(blaschke_multivariate(m, mz[4])) #> Error in blaschke_multivariate(m, mz[4]) :  #>   could not find function \"blaschke_multivariate\"  bm = try(blaschke_multivariate(m, mz[2])) #> Error in blaschke_multivariate(m, mz[2]) :  #>   could not find function \"blaschke_multivariate\"  set.seed(NULL)"},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"companion-matrix","dir":"Articles","previous_headings":"Methods for Polynomials > Misc Tools","what":"Companion Matrix","title":"Rational Matrices","text":"Let \\((z) = a_0+a_1z+\\cdots a_p z^p\\) square (\\(m\\times m\\))-dimensional, non singular polynomial matrix \\(a_0\\neq 0\\). companion matrix \\[ \\begin{pmatrix} -a_0^{-1}a_1 & \\cdots & -a_0^{-1} a_{p-1} & -a_0^{-1} a_p \\\\ I_m          & \\cdots & 0                 &          0    \\\\ \\vdots       & \\ddots & \\vdots            &     \\vdots    \\\\ 0            & \\cdots & I_m               &           0 \\end{pmatrix} \\\\mathbb{R}^{mp\\times mp} \\] may computed helper function companion_matrix(). function throws error argument square, degree \\(-1\\) constant term \\(a_0\\) invertible.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"polynomial-degree","dir":"Articles","previous_headings":"Methods for Polynomials > Misc Tools","what":"Polynomial Degree","title":"Rational Matrices","text":"helper function degree() returns polynomial degrees elements polynomial matrix, maximum degrees elements columns rows matrix maximum degree elements \\((z)\\). Note degree zero polynomial set \\(-1\\).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"some-workhorse-functions","dir":"Articles","previous_headings":"Methods for Polynomials > Misc Tools","what":"Some Workhorse Functions","title":"Rational Matrices","text":"following helper functions particular used construct normal forms, like Hermite normal form, polynomial matrices. col_end_matrix() computes column end matrix polynomial matrix. prune() “simplifies” polynomial object. particular, small leading coefficients set zero zero leading coefficent matrices dropped. purge() “purges” elements , , right left pivot element elementary row- column- operations. “purge” means elements either reduced zero degree elements made smaller degree pivot element.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"balance","dir":"Articles","previous_headings":"Methods for Statespace Forms","what":"Grammians and Balanced Realizations","title":"Rational Matrices","text":"consider rational matrix \\(K(z) = C(z^{-1}I_s - )^{-1} B +D\\) state space form assume \\(K\\) stable, .e. eigenvalues matrix \\(\\) moduli less one. controllability Grammian statespace realization defined \\[ P = \\sum_{j\\geq 0} ^j BB' (')^j = APA' + BB' \\] observability Grammian \\[ Q = \\sum_{j\\geq 0} (')^j C'C ^j = 'QA + C'C \\] Grammians may computed routine grammians(obj). statespace realization minimal \\(P\\) \\(Q\\) positive definite. Furthermore can shown product \\(PQ\\) diagonalizable (non negative (real) eigenvalues) rank \\(PQ\\) equal minimal statespace dimension \\(K(z)\\), .e. exists statespace realization \\(K(z)\\) statespace dimension equal rank \\(PQ\\) statespace realization \\(K(z)\\) statespace dimension larger equal \\(\\mathrm{rk}(PQ)\\). apply state space transformation \\(T\\) Grammians transform follows \\[ P \\longrightarrow TPT',\\; Q \\longrightarrow (T^{-1})' Q T^{-1} \\text{ } PQ \\longrightarrow TPQT^{-1} \\] Let \\(\\sigma_1^2 \\geq \\sigma_2^2 \\geq \\cdots \\geq \\sigma_{s}^2 \\geq 0\\) denote ordered eigenvalues \\(PQ\\) suppose \\(PQ\\) rank \\(s_0 \\leq s\\), .e. \\(\\sigma_k>0\\) \\(1\\leq k \\leq s_0\\) \\(\\sigma_k=0\\) \\(k>s_0\\). exists state transformation \\(T\\) two transformed Grammians diagonal first \\(s_0\\) diagonal entries \\(P\\) \\(Q\\) given \\(\\sigma_k\\), \\(k=1,\\ldots,s_0\\). Therefore \\[ P = \\begin{pmatrix}     P_{11} & 0 \\\\     0      & P_{22}     \\end{pmatrix},\\; Q = \\begin{pmatrix}     Q_{11} & 0 \\\\     0      & Q_{22}     \\end{pmatrix} \\mbox{ } P_{11} = Q_{11} = \\mbox{diag}(\\sigma_1,\\ldots,\\sigma_{s_0}) \\mbox{ } P_{22} Q_{22} = 0. \\] \\(\\sigma_k\\)’s called Hankel singular values statespace realization since singular values Hankel matrix impulse response coefficients. minimal statespace realization \\(K\\) may simply computed truncating transformed matrices \\(,B,C\\). partition (transformed) state space matrices (conformingly \\(P\\), \\(Q\\)) \\[ = \\begin{pmatrix} A_{11} & A_{12} \\\\ A_{21} & A_{22} \\end{pmatrix}, \\; B = \\begin{pmatrix} B_{1} \\\\ B_{2} \\end{pmatrix} \\mbox{ } C = \\begin{pmatrix} C_{1} & C_2 \\end{pmatrix} \\] \\(K(z) = C_1(z^{-1}I_{s_0} -A_{11})^{-1} B_1 + D)\\) minimal statespace realization \\(K\\). balance(obj, P,Q, s0, truncate = FALSE) computes somewhat simplified balanced form, two blocks \\(P_{22}\\) \\(Q_{22}\\) diagonal. three possible scenarios paramater s0 equal rank \\(PQ\\). case \\(P_{22}Q_{22} = 0\\) (numerical errors). paramater s0 less rank \\(PQ\\). case \\(P_{22}Q_{22}\\) equal zero. paramater s0 larger rank \\(PQ\\). case procedure may throw error. optional parameter truncate=TRUE correspondingly truncated statespace realization returned. case paramater s0 less rank \\(PQ\\) truncated realization approximate realization rational matrix \\(K\\). approximation error depends size “neglected” singular values. Note also case statespace realization returned balanced form, .e. Grammians realization equal \\(P_{11}\\) \\(Q_{11}\\). \\(T=(T_1',T_2')'\\), \\(S=T^{-1}=(S_1,S_2)\\) denotes statespace transformation, gives balanced form, trancated system \\(A_{11}=T_1 S_1\\), \\(B_1=T_1 B\\), \\(C_1=CS_1\\) \\(D=D\\). Note also case (truncate=TRUE) procedure just returns \\(T_1\\), \\(S_1\\) “whole” transformation matrices. call balance(obj, P, Q, s0=NULL, tol, truncate) procedure tries determine rank \\(PQ\\) inspecting computed singular values \\(\\sigma_k\\). precise \\(s_0\\) set number singular values \\(\\sigma_k\\) larger tol times largest singular value \\(\\sigma_1\\). strategy fails singular values equal zero (numerical errors). discussed balancing balanced truncation case controllabaility observability Grammian. scheme sometimes called Lyapunov balancing. possible choices pair Grammians, e.g. one may use controllabaility matrix observability matrix statespace realization inverse \\(K^{-1}\\), .e. \\[ Q = (-BD^{-1}C)' Q (-BD^{-1}C) + C'C \\] course choice rational marix \\(K\\) must minimum phase, .e. moduli eigenvalues \\(-BD^{-1}C\\) must smaller one. balancing scheme therefore called minimum phase balancing. details balanced form actually computed given vignette “Technical Details”.","code":"# example A ############################################################  # \"obj\" is a (1 by 1) rational matrix in statespace form, # with stespace dimension s = 2.  obj = stsp(A = c(0,0.2,1,-0.5),            B = c(1,1), C = c(1,0)) gr = grammians(obj, 'lyapunov') bal = balance(obj, gr)  print(cbind(bal$P, bal$Q, diag(bal$sigma, nrow = 2, ncol = 2))) #>          [,1]     [,2]     [,3]     [,4]     [,5]     [,6] #> [1,] 1.586904 0.000000 1.586904 0.000000 1.586904 0.000000 #> [2,] 0.000000 1.458699 0.000000 1.458699 0.000000 1.458699 all.equal(grammians(bal$obj), bal[c('P','Q')]) #> [1] TRUE  # example B (non minimal statespace realization #########################  # The \"rbind\" operation below returns a statespace realization with # statespace dimension s = 4. However the minimal statespace dimensions # is s0 = 2. obj = rbind(obj, obj) gr = grammians(obj, 'lyapunov') bal = balance(obj, gr, s0 = 2, truncate = FALSE)  # the upper (2 by 2) block of the (transformed) controllability # Grammian is diagonal, the lower (2 by 2) block is \"zero\". # This shows that the (balanced) realization is not controllable. print(bal$P)   #>          [,1]     [,2]          [,3]          [,4] #> [1,] 2.244221 0.000000  0.000000e+00  0.000000e+00 #> [2,] 0.000000 2.062912  0.000000e+00  0.000000e+00 #> [3,] 0.000000 0.000000  2.272963e-32 -2.403037e-32 #> [4,] 0.000000 0.000000 -1.786739e-32  1.198986e-31  # the upper (2 by 2) block of the (transformed) observability # Grammian is diagonal and equal to the upper block of bal$P. print(bal$Q) #>          [,1]     [,2]       [,3]       [,4] #> [1,] 2.244221 0.000000 0.00000000 0.00000000 #> [2,] 0.000000 2.062912 0.00000000 0.00000000 #> [3,] 0.000000 0.000000 1.77315334 0.02695174 #> [4,] 0.000000 0.000000 0.02695174 1.00462444  # the product of the (transformed) controllability and observability # Grammians is (approximately) diagonal and the diagonal entries are   # the squares of the Hankel singular values. print(bal$P %*% bal$Q) #>          [,1]     [,2]          [,3]          [,4] #> [1,] 5.036528 0.000000  0.000000e+00  0.000000e+00 #> [2,] 0.000000 4.255604  0.000000e+00  0.000000e+00 #> [3,] 0.000000 0.000000  3.965545e-32 -2.352889e-32 #> [4,] 0.000000 0.000000 -2.845015e-32  1.199715e-31 print(bal$sigma^2)     #> [1] 5.036528e+00 4.255604e+00 2.792357e-17 6.353796e-32  all.equal(grammians(bal$obj), bal[c('P','Q')]) #> [1] TRUE  # we may construct a minimal realization by 'balanced truncation'. # note that we let the procedure determine the minimal statespace dimension trunc = balance(obj, gr)   print(trunc$obj) #> statespace realization [2,1] with s = 2 states #>            s[1]       s[2]       u[1] #> s[1]  0.3498560  0.3119731 -1.3299446 #> s[2] -0.3119731 -0.8498560 -0.5954318 #> x[1] -0.9404128  0.4210339  1.0000000 #> x[2] -0.9404128  0.4210339  1.0000000 # compare with the above balanced realization print(bal$obj) #> statespace realization [2,1] with s = 4 states #>               s[1]          s[2]          s[3]          s[4]          u[1] #> s[1]  3.498560e-01  3.119731e-01 -1.747240e-16  1.694153e-17 -1.329945e+00 #> s[2] -3.119731e-01 -8.498560e-01 -9.478857e-17 -1.914317e-16 -5.954318e-01 #> s[3]  3.687444e-17  1.314776e-17 -8.147341e-01 -7.816872e-02  5.551115e-17 #> s[4] -6.500433e-17 -1.117170e-16  7.218313e-01  3.147341e-01  2.220446e-16 #> x[1] -9.404128e-01  4.210339e-01  2.284728e-01 -6.691787e-01  1.000000e+00 #> x[2] -9.404128e-01  4.210339e-01 -2.284728e-01  6.691787e-01  1.000000e+00 # check all.equal(pseries(obj), pseries(trunc$obj)) #> [1] TRUE  # example C (balanced truncation) ##########################  # construct a random rational matrix with statespace dimension s=10 obj = test_stsp(dim = c(2,2), s = 10, bpoles = 1, bzeroes = 1) # compute an approximate realization with s0 = 8 gr = grammians(obj, 'minimum phase') trunc = balance(obj, gr, s0 = 5) print(trunc$sigma) #>  [1] 1.48858057 1.27641368 0.98417775 0.60004923 0.36379776 0.26893054 #>  [7] 0.14144190 0.11147519 0.05039678 0.01249503  max(abs(unclass(pseries(obj, lag.max = 25)) -         unclass(pseries(trunc$ob, lag.max = 25)))) #> [1] 0.09516145 plot(pseries(obj, lag.max = 25), x_list= list(pseries(trunc$obj, lag.max = 25)),      type = c('l','p'), legend = c('s=10', 's=5'))"},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"reflect-poles-or-zeroes-by-multiplication-with-all-pass-matrices","dir":"Articles","previous_headings":"Methods for Statespace Forms","what":"Reflect Poles or Zeroes by Multiplication with All Pass Matrices","title":"Rational Matrices","text":"algorithm outlined “Reflect Zeroes Multiplication Pass Matrices” flip zeroes multivariate polynomial matrix statespace analogon. Let \\(K(z)=C(z^{-1}-)^{-1}B+D\\) square, rational matrix statespace form suppose \\(\\alpha_1,\\ldots,\\alpha_k\\) zeroes \\(K(z)\\). exists allpass (rational) function \\(U(z)\\), \\(UU^*=U^*U=\\) \\(K(z)U(z)\\) rational matrix, roots \\(\\alpha_i\\) replaced “flipped” roots \\(1/\\bar{\\alpha}_i\\). \\(KU\\) \\(U\\) statespace realization, computed routine reflect_zeroes(). Quite analogously one may also mirror poles \\(K\\). construction allpass function \\(U\\) outlined vignette “technical details”.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/a_rational_matrices.html","id":"h2-norm-and-orthogonalization","dir":"Articles","previous_headings":"Methods for Statespace Forms","what":"H2 norm and orthogonalization","title":"Rational Matrices","text":"Create vector rational functions form \\(1/(1-0.9z)^k\\), \\(k=1,2,3,4\\): statespac realization (K) minimal. (Minimal state dimension \\(s=4\\).) Use balance construct minimal realization: Orthormalize components \\(K\\) respect \\(H_2\\) inner product. Plot frequency response     Compute reduced order model (s = 3)","code":"K0 = polm(c(1, -0.9))^(-1) K = rbind(K0,           K0^2,           K0^3,           K0^4) # K is not minimal! minimal state dimension = 4 gr = grammians(K, 'lyapunov') out = balance(K, gr, s = 4) print(out$sigma) #>  [1] 6.876057e+03 2.133678e+03 2.994808e+02 1.691065e+01 2.725611e-06 #>  [6] 9.858548e-07 2.501330e-07 1.723756e-07 1.170216e-13 5.639412e-15 # check all.equal(zvalues(K, n.f = 2^6), zvalues(out$obj, n.f = 2^6)) #> [1] TRUE  K = out$obj P = lyapunov(K$A, K$B %*% t(K$B)) Q = K$C %*% P %*% t(K$C) + K$D %*% t(K$D)  K0 = solve(t(chol(Q))) %r% K K0 #> statespace realization [4,1] with s = 4 states #>              s[1]         s[2]        s[3]         s[4]        u[1] #> s[1]  0.987214209  0.040644523 -0.01291412  0.002910154 -13.0817697 #> s[2] -0.040708578  0.943474772  0.06640124 -0.011901623 -14.8888604 #> s[3] -0.013472533 -0.067431696  0.87486975  0.066882649  -7.6963271 #> s[4] -0.003765234 -0.014720809 -0.07238612  0.794441274  -2.0269817 #> x[1] -0.007922199 -0.012583407 -0.01155208 -0.006119112   0.4358899 #> x[2] -0.008403204  0.006876849  0.02867369  0.028174871  -0.3923009 #> x[3] -0.002982258  0.015426702 -0.02592047 -0.078870839   0.3530708 #> x[4] -0.001299696  0.001345163 -0.03521625  0.174025836  -0.3177637  # check P = lyapunov(K0$A, K0$B %*% t(K0$B)) Q = K0$C %*% P %*% t(K0$C) + K0$D %*% t(K0$D) all.equal(Q, diag(4)) #> [1] TRUE fr = zvalues(K0, n.f = 2^12) fr0 = zvalues(K0, n.f = 10) legend = c(expression(K[1]), expression(K[2]), expression(K[3]), expression(K[4])) plot(fr[1,1], x_list = list(fr[2,1], fr[3,1], fr[4,1]), which = 'modulus',      legend = legend) plot(fr[1,1], x_list = list(fr[2,1], fr[3,1], fr[4,1]), which = 'phase',      legend = legend) plot(fr[1,1], x_list = list(fr[2,1], fr[3,1], fr[4,1]), which = 'nyquist',      legend = legend) subfigures.main = legend dim(subfigures.main) = c(2,2) plot(cbind(fr[1:2,1], fr[3:4,1]),      x_list = list(cbind(fr0[1:2,1], fr0[3:4,1])),      type = c('l','p'), cex.points = 0.1, col = c('red','black'), pch = 20,      which = 'nyquist', subfigures.main = subfigures.main) gr = grammians(K0, 'lyapunov') out = balance(K0, gr, s = 3) print(out$sigma) #> [1] 6.645557 4.594142 2.803345 1.040294 Kh = out$obj frh = zvalues(Kh, n.f = 2^12)  plot(cbind(fr[1:2,1], fr[3:4,1]),      x_list = list(cbind(frh[1:2,1], frh[3:4,1])),      which = 'nyquist', subfigures.main = subfigures.main,      legend = c(expression(K[i]), expression(hat(K)[i])))"},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"left-coprime-polynomials","dir":"Articles","previous_headings":"","what":"Left Coprime Polynomials","title":"Rational Matrices: Technical Details","text":"polynomial matrix \\(c\\) called left prime, \\(c(z)\\) full row rank everywhere complex plane. Clearly implies \\(c\\) square “wide”, .e. \\(c\\) \\((m \\times n)\\)-dimensional \\(m \\leq n\\) must hold. pair \\((,b)\\) (compatible) polynomial matrices called left coprime matrix \\(c=[,b]\\) left prime. case important structure left matrix fraction descriptions. Suppose \\(c(z)=^{-1} b(z)\\), \\(\\) square, non singular polynomial matrix. pair \\((,b)\\) left coprime, may cancel common, non unimodular, factor thus obtain “simpler” representation \\(c(z)\\). discuss two strategies testing whether polynomial matrix left prime. first approach uses Hermite normal form (HNF) second one tackles problem via (singular) pencil. approach via singular pencils numerically stable thus implemented function .coprime(). See also examples . First note problem easy tackle case \\(c\\) degree zero. just check left kernel coefficient matrix \\(z^0\\). Also case \\(c\\) “tall”, .e. number rows larger number columns trivial. case \\(c\\) clearly left prime, since rank \\(c(z)\\) smaller number rows \\(z \\\\mathbb{C}\\). Therefore throughout section, assume \\(c\\) \\((m \\times n)\\)-dimensional polynomial matrix degree \\(p > 0\\) \\(m \\leq n\\).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"hermite-normal-form","dir":"Articles","previous_headings":"Left Coprime Polynomials","what":"Hermite Normal Form","title":"Rational Matrices: Technical Details","text":"Consider row Hermite form obtained elementary column operations \\[ c(z) = h(z) u(z) = h_1(z) u_1(z) \\] \\(u\\) \\((n \\times n)\\)-dimensional unimodular modular matrix, \\(h\\) \\((m \\times n)\\)-dimensional lower (quasi) triangular matrix. \\((m \\times m)\\)-dimensional matrix \\(h_1\\) obtained \\(h\\) selecting first \\(m\\) columns \\(u_1\\) consists first \\(m\\) rows \\(u\\). Note \\(h_1\\) square, lower triangular matrix, diagonal elements either monic zero, diagonal element non zero, elements left element lower degree. Furthermore note rank \\(c(z)\\) equal rank \\(h_1(z)\\) \\(z \\\\mathbb{C}\\). Therefore rank \\(c(z)\\) less \\(m\\) \\(z\\) zero product diagonal entries: \\(h_{11} h_{22} \\cdots h_{mm}\\). following cases may occur diagonal elements \\(h_{ii}\\) constant (hence \\(h_1 = I_m\\) must hold). case \\(\\mbox{rk}(c(z))=m\\) \\(z\\\\mathbb{C}\\) thus \\(c\\) coprime. One diagonal elements zero: case \\(\\mbox{rk}(c(z))<m\\) holds \\(z\\\\mathbb{C}\\) thus \\(c\\) coprime. diagonal elements non zero least one degree larger zero. case \\(\\mbox{rk}(c(z))=m\\) except zeroes polynomial \\((h_{11} h_{22} \\cdots h_{mm})\\). Also case, \\(c\\) coprime. Hence, polynomial \\(c\\) left prime \\(h_1 = I_m\\).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"generalized-pencils","dir":"Articles","previous_headings":"Left Coprime Polynomials","what":"Generalized Pencils","title":"Rational Matrices: Technical Details","text":"reference generalized pencils, see [@Gantmacher1959, Chapter XII (particular §4 page 35ff)] [@Kailath80, page 393ff] [@DemmelKagstroem1993] first construct pencil \\(P(z)=(-Bz)\\) \\(z \\\\mathbb{C}\\) left kernel \\(c(z)\\) \\(P(z)\\) dimension. means \\(c\\) left prime \\(P\\) left prime. Furthermore zeroes \\(P\\) \\(c\\) . condition \\[ u c(z) = u (c_0 + c_1 z + \\cdots + c_p z^p) = 0 \\] \\(z \\\\mathbb{C}\\) \\(u \\\\mathbb{C}^{1 \\times m}, u \\neq 0\\) equivalent condition \\[ (v_1,v_2,\\ldots,v_p) \\begin{pmatrix} c_0 & 0      & \\cdots  & 0 \\\\ 0   & I_{n}      & \\cdots  &  0 \\\\ 0   & \\vdots & \\ddots  &  \\vdots \\\\ 0   & 0      & \\cdots  & I_{n} \\\\ \\end{pmatrix} = (v_1,v_2,\\ldots,v_p) \\begin{pmatrix} -c_1    & \\cdots & -c_{p-1} & -c_p \\\\ I_{n}      & \\cdots & 0       & 0 \\\\ \\vdots & \\ddots & \\vdots  & \\vdots \\\\ 0      & \\cdots & I_{n} & 0 \\end{pmatrix} z \\] \\(v_1 \\\\mathbb{C}^{1 \\times m}\\), \\(v_1 \\neq 0\\) \\(v_j\\\\mathbb{C}^{1\\times n}\\) \\(=2,\\ldots ,p\\). follows immediately rewriting condition \\[ \\begin{array}{rcl} v_2 z   &=& v_1 c_0 + v_1 c_1 z = v_1 (c_0 + c_1 z) \\\\ v_3 z^2 &=& (v_2 + v_1 c_2 z) z = v_1 (c_0 + c_1 z + c_2 z^2) \\\\ v_4 z^3 &=& (v_3 + v_1 c_3 z) z^2 = v_1 (c_0 + c_1 z + c_2 z^2 + c_3 z^3) \\\\ & \\vdots &  \\\\ v_p z^{p-1} &=& v_1 (c_0 + c_1 z + \\cdots + c_{p-1} z^{p-1}) \\\\ -v_1 c_p z^p &=& v_p z^{p-1} \\end{array} \\] see also @Kailath80, page 393ff. Combining last two equations gives \\[ 0 = v_pz^{p-1} + v_1 c_p z^p = v_1 (c_0 + c_1 z + \\cdots + c_{p} z^{p}). \\] Therefore matrix \\(c(z)\\) non trivial left kernel pencil \\(P(z) = (- Bz)\\),\\[ = \\begin{pmatrix} c_0 & 0      & \\cdots  & 0 \\\\ 0   & I_{n}      & \\cdots  &  0 \\\\ 0   & \\vdots & \\ddots  &  \\vdots \\\\ 0   & 0      & \\cdots  & I_{n} \\\\ \\end{pmatrix}, \\quad B = \\begin{pmatrix} -c_1    & \\cdots & -c_{p-1} & -c_p \\\\ I_{n}      & \\cdots & 0       & 0 \\\\ \\vdots & \\ddots & \\vdots  & \\vdots \\\\ 0      & \\cdots & I_{n} & 0 \\end{pmatrix}, \\] non trivial left kernel. implies \\(c\\) left prime \\(P\\) left prime.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"staircase-form","dir":"Articles","previous_headings":"Left Coprime Polynomials > Generalized Pencils","what":"Staircase Form","title":"Rational Matrices: Technical Details","text":"order analyze left kernel pencil, transform pencil (multiplication orthogonal matrices left right) called staircase form. simplify notation set \\(M=(m+n(p-1))\\) \\(N = np\\), .e. \\((M,N)\\) now denotes dimension pencil \\(P(z)\\). Note \\(M-N = m-n \\neq 0\\) general, means deal non regular pencils. procedure described works arbitary pencil, .e. impose special structure also consider case \\(M>N\\). pencil \\(P(z) = (-Bz)\\) “tall”, .e. \\(M > N\\), \\(P(z)\\) non trivial left kernel \\(z \\\\mathbb{C}\\). case \\(P\\) (matrix \\(c\\)) left prime. pencil \\(P(z)=(-Bz)\\) square, .e. \\(M=N\\), \\(B\\) non singular, zeroes pencil \\(P(z)\\) (zeroes \\(c(z)\\)) eigenvalues matrix \\(AB^{-1}\\). case \\(P\\) (matrix \\(c\\)) left prime. Now suppose right kernel \\(B\\) \\(N_1 > 0\\) dimensional. \\(N_1 = N\\), .e. \\(B=0\\), two cases may occur: matrix \\(\\) full row rank. case pencil \\(P\\) (matrix \\(c\\)) left prime. matrix \\(\\) full row rank hence \\(P(z)\\) non trivial left kernel \\(z \\\\mathbb{C}\\). case \\(P\\) (matrix \\(c\\)) left prime. Finally suppose \\(0 < N_1 <N\\) holds let \\(0 \\leq M_1 \\leq N_1\\) denote rank first \\(N_1\\) columns \\(AV\\). exists orthogonal transformation, \\(U\\) say, first \\(M_1\\) rows first \\(N_1\\) columns \\(U'AV\\) full rank \\(M_1\\) remaining rows zero. Using symbols transformed pencil get \\[ P (z) = \\begin{pmatrix} A_{11} & A_{12} \\\\ 0_{(M-M_1) \\times N_1} & A_{22} \\end{pmatrix} - \\begin{pmatrix} 0_{M_1\\times N_1} & B_{12} \\\\ 0_{(M-M_1) \\times N_1} & B_{22} \\end{pmatrix}z,\\quad A_{11} \\\\mathbb{R}^{M_1 \\times N_1}. \\] Clearly \\(P(z)\\) full row rank reduced pencil \\((A_{22} - B_{22} z)\\) full row rank. Now iterate procedure reduced pencil \\((A_{22} - B_{22}z)\\) end following staircase form pencil: \\[ P (z) = \\begin{pmatrix} A_{11}                 & \\cdots & A_{1,k-1}              & A_{1k} \\\\ \\vdots                 & \\ddots & \\vdots                 & \\vdots  \\\\ 0_{M_{k-1} \\times N_1} & \\cdots & A_{k-1,k-1}            & A_{k-1, k}\\\\ 0_{M_k \\times N_1}     & \\cdots & 0_{M_k \\times N_{k-1}} & A_{kk}  \\\\ \\end{pmatrix} - \\begin{pmatrix} 0_{M_1 \\times N_1}     & \\cdots & B_{1,k-1}                   & B_{1,k} \\\\ \\vdots                 & \\ddots &  \\vdots                     & \\vdots   \\\\ 0_{M_{k-1} \\times N_1} & \\cdots & 0_{M_{k-1} \\times N_{k-1}}  & B_{k-1,k} \\\\ 0_{M_k \\times N_1}     & \\cdots & 0_{M_k \\times N_{k-1}}      & B_{kk} \\\\ \\end{pmatrix} z \\] diagonal blocks dimension \\((M_i\\times N_i)\\). first \\((k-1)\\) diagonal blocks \\(\\) full row rank (hence \\(0\\leq M_i \\leq N_i\\)) first \\((k-1)\\) diagonal block \\(B\\) zero. Therefore \\(P(z)\\) full row rank last block \\((A_{kk} - B_{kk}z)\\) full row rank. last block following cases may occur: \\((A_{kk} - B_{kk})\\) “tall” (\\(M_k > N_k\\)), \\(P(z)\\) non trivial left kernel \\(z \\\\mathbb{C}\\). case \\(P\\) (matrix \\(c\\)) left prime. pencil \\((A_{kk} - B_{kk})\\) square (\\(M_k=N_k\\)) \\(B_{kk}\\) non singular, zeroes pencil \\(P(z)\\) (zeroes \\(c(z)\\)) eigenvalues matrix \\(A_{kk}B_{kk}^{-1}\\). case \\(P\\) (matrix \\(c\\)) left prime. \\(B_{kk}\\) zero matrix \\(\\) full row rank, \\(P(z)\\) full row rank \\(z\\\\mathbb{C}\\). case pencil \\(P\\) (matrix \\(c\\)) left prime. \\(B_{kk}\\) zero matrix \\(\\) full row rank, \\(P(z)\\) non trivial left kernel \\(z \\\\mathbb{C}\\). case \\(P\\) (matrix \\(c\\)) left prime. function .coprime() uses approach test wether polynomial left prime (pair polynomials left coprime). default case function just returns boolean variable. However, optional argument .answer set FALSE, list returned contains described staircase form. list contains following slots: answer TRUE, polynomial prime (pair left coprime).,B hold two matrices \\(\\) \\(B\\) (staircase form).m,n two integer vectors contain size blocks \\((M_i)\\) \\((N_i)\\) respectively.zeroes vector contains zeroes pencil (polynomial \\(c\\)). (co-)prime case vector empty \\(P\\) rank deficient \\(z \\\\mathbb{C}\\) zeroes = NA_real_.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"examples","dir":"Articles","previous_headings":"Left Coprime Polynomials","what":"Examples","title":"Rational Matrices: Technical Details","text":"present three examples pertaining three different outcomes: coprime polynomial matrices \\((z)\\) \\(b(z)\\) non-coprime polynomial matrices finite number common zeros non-coprime polynomial matrices reduced rank \\(z\\\\mathbb{C}\\)","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"coprime-polynomials","dir":"Articles","previous_headings":"Left Coprime Polynomials > Examples","what":"Coprime Polynomials","title":"Rational Matrices: Technical Details","text":"Two “generic” polynomials coprime.","code":"# Generate a random (m x m), and a random (m x n) polynomial matrix, with degree p=2 m = 2 n = 3 set.seed(1803) a = test_polm(dim = c(m,m), degree = 2, digits = 1, random = TRUE) b = test_polm(dim = c(m,n), degree = 2, digits = 1, random = TRUE)"},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"hermite-form","dir":"Articles","previous_headings":"Left Coprime Polynomials > Examples > Coprime Polynomials","what":"Hermite Form","title":"Rational Matrices: Technical Details","text":"Hermite form \\(\\left( (z), b(z)\\right)\\) square submatrix \\(h_1\\) Hermite form \\(h\\) equal identity matrix, hence \\((,b)\\) left coprime.","code":"HNF = hnf(cbind(a,b), from_left = FALSE) print(HNF$h, digits = 2, format = 'character') #> ( 2 x 5 ) matrix polynomial with degree <= 0  #>       [,1]  [,2]  [,3]  [,4]  [,5] #> [1,]     1     0     0     0     0 #> [2,]     0     1     0     0     0"},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"pencil","dir":"Articles","previous_headings":"Left Coprime Polynomials > Examples > Coprime Polynomials","what":"Pencil","title":"Rational Matrices: Technical Details","text":"method using pencil gives answer: common zeros. polynomial matrices left coprime.","code":"out = is.coprime(a, b, debug = FALSE, only.answer = FALSE) cat(\"The polynomials are left coprime: \", out$answer,\"\\n\",      \"The zeros of the pencil are: \", out$zeroes, sep = '') #> The polynomials are left coprime: TRUE #> The zeros of the pencil are:"},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"not-coprime-finite-number-of-zeros","dir":"Articles","previous_headings":"Left Coprime Polynomials > Examples","what":"Not coprime: Finite Number of Zeros","title":"Rational Matrices: Technical Details","text":"consider example \\(c(z)= [(z),b(z)]\\) rank deficient () \\(z\\\\mathbb{C}\\). generate polynomials multiplying common (matrix) factor. show (least) one singular value \\(c(z)\\) evaluated zeros common factor zero.","code":"a0 = a b0 = b  # Generate random common factor  with degree 1 r = test_polm(dim = c(m,m), degree = 1, digits = 1, random = TRUE)  # Generate polynomials with a common factor a = r %r% a0 b = r %r% b0 c = cbind(a,b)  z_r = zeroes(r) cat(\"The zeros of the common factor r(z) are: \\n\", z_r, \"\\n\\n\") #> The zeros of the common factor r(z) are:  #>  -0.2051932 5.377607  d = svd(unclass(zvalues(c, z = z_r[1]))[,,1])$d cat(\"minimal singular value of c(z_0): \", d[m], sep=\"\") #> minimal singular value of c(z_0): 1.007532e-16"},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"hermite-form-1","dir":"Articles","previous_headings":"Left Coprime Polynomials > Examples > Not coprime: Finite Number of Zeros","what":"Hermite Form","title":"Rational Matrices: Technical Details","text":"Hermite Form \\(c(z) = ((z), b(z))\\) calculate zeros \\(c(z)= [(z),b(z)]\\) calculating zeros diagonal elements square submatrix \\(h_1(z)\\). Note example \\((1,1)\\) element equal \\(1\\). (common) zeros therefore Note zeroes identical zeroes common factor \\(r(z)\\).","code":"HNF = hnf(cbind(a,b), from_left = FALSE) print(HNF$h, digits = 2, format = 'character') #> ( 2 x 5 ) matrix polynomial with degree <= 2  #>               [,1]                [,2]  [,3]  [,4]  [,5] #> [1,]             1                   0     0     0     0 #> [2,]  2.49 - 0.39z  -1.1 - 5.17z + z^2     0     0     0 zeroes(HNF$h[m,m]) #> [1] -0.2051932  5.3776070"},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"pencil-1","dir":"Articles","previous_headings":"Left Coprime Polynomials > Examples > Not coprime: Finite Number of Zeros","what":"Pencil","title":"Rational Matrices: Technical Details","text":"outcome pencil .","code":"out = is.coprime(a, b, debug = FALSE, only.answer = FALSE) cat(\"The polynomials are left coprime: \", out$answer,\"\\n\",      \"The zeros of the pencil are: \", out$zeroes, sep = '') #> The polynomials are left coprime: FALSE #> The zeros of the pencil are: 5.377607-0.2051932"},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"not-coprime-everywhere-rank-deficient","dir":"Articles","previous_headings":"Left Coprime Polynomials > Examples","what":"Not coprime: Everywhere Rank Deficient","title":"Rational Matrices: Technical Details","text":"Finally let us consider case, \\(c(z) = ((z),b(z))\\) rank deficient \\(z\\). generate pair polynomial matrices kind multiplying two polynomials \\((z), b(z)\\) (left) singular common factor. verify \\(c(z)\\) reduced row rank \\(z\\\\mathbb{C}\\), print singular values \\(c(z)\\) randomly selected point.","code":"# generate a square polynomial matrix with rank one! r = test_polm(dim = c(m,1), degree = 1, digits = 1, random = TRUE) %r%      test_polm(dim = c(1,m), degree = 1, digits = 1, random = TRUE)  print(r, format = 'c') #> ( 2 x 2 ) matrix polynomial with degree <= 2  #>                         [,1]                     [,2] #> [1,]   1.36 - 1.43z - 2.1z^2  -0.72 + 2.07z - 1.35z^2 #> [2,]  1.53 + 3.47z + 1.82z^2  -0.81 - 0.36z + 1.17z^2  a = r %r% a0 b = r %r% b0  # Evaluate c(z) = (a(z),b(z)) at a random point z0 and print the corresponding singular values z0 = complex(real = rnorm(1), imaginary = rnorm(1)) d = svd( unclass(zvalues(cbind(a,b), z = z0))[,,1], nu = 0, nv = 0 )$d  cat(\"The singular values of c(z) \\n evaluated at z0 = \", z0, \"\\n are: \", d, \"\\n\\n\") #> The singular values of c(z)  #>  evaluated at z0 =  0.3368112-0.2077692i  #>  are:  8.087889 6.256749e-16"},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"hermite-form-2","dir":"Articles","previous_headings":"Left Coprime Polynomials > Examples > Not coprime: Everywhere Rank Deficient","what":"Hermite Form","title":"Rational Matrices: Technical Details","text":"Hermite Form \\(c(z) = ((z), b(z))\\) matrix \\(c(z)\\) rank deficient (\\(z\\)) since \\(h[2,2] = 0\\)! procedure hnf returns also estimate rank \\(c(z)\\) (\\(c(z)\\) considered rational matrix). get means \\(c(z)\\) rank deficient \\(z \\\\mathbb{C}\\).","code":"HNF = hnf(cbind(a,b), from_left = FALSE) print(HNF$h, digits = 1, format = 'char') #> ( 2 x 5 ) matrix polynomial with degree <= 1  #>              [,1]  [,2]  [,3]  [,4]  [,5] #> [1,]     -0.5 + z     0     0     0     0 #> [2,]  -0.6 - 0.9z     0     0     0     0 cat(HNF$rank,'\\n') #> 1"},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"pencil-2","dir":"Articles","previous_headings":"Left Coprime Polynomials > Examples > Not coprime: Everywhere Rank Deficient","what":"Pencil","title":"Rational Matrices: Technical Details","text":"result pencils .","code":"out = is.coprime(a, b, debug = FALSE, only.answer = FALSE) cat(\"The polynomials are left coprime: \", out$answer,\"\\n\",      \"The zeros of the pencil are: \", out$zeroes, sep = '') #> The polynomials are left coprime: FALSE #> The zeros of the pencil are: NA"},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"column-reduced-matrix","dir":"Articles","previous_headings":"","what":"Column Reduced Matrix","title":"Rational Matrices: Technical Details","text":"Note: functions degree (col_end_matrix) col_reduce use different strategies compute column degrees (column end matrix). first two consider elements, whereas col_reduce considers euclidean norm respective columns. Let \\((z) = ^0 + ^1 z + \\cdots + ^p z^p\\), \\(^k = (^k_{ij})\\) \\(^k_j=(^k_{1j}, \\ldots, ^k_{mj})'\\). function degree sets degree \\(j\\)-th column \\(p_j\\) iff \\(^{p_j}_{ij} > \\tau\\) least one \\(\\) \\(^{k}_{ij} \\leq \\tau\\) \\(\\) \\(k>p_j\\). column end matrix constructed correspondingly. function col_reduce sets degree \\(j\\)-th column \\(p_j\\) iff \\(\\|^{p_j}_{j}\\| > \\tau\\) \\(\\|^{k}_{j}\\| \\leq \\tau\\) \\(k>p_j\\). Therefore one may get different results! basic strategy construct column reduced matrix (case \\((z)\\) square non singular) follows. First permute columns \\((z)\\) column degrees \\(p_1 \\leq p_2 \\leq \\cdots \\leq p_m\\) ordered. Now suppose \\(k\\)-th column, \\(c_k\\) say, column end matrix linearly dependent previous columns (\\(c_j\\), \\(1\\leq j < k\\)), .e. \\(c_k = \\alpha_1 c_1 + \\cdots \\alpha_{k-1} c_{k-1}\\). substract \\(k\\)-th column \\((z)\\), \\(z^{p_k-p_j}\\alpha_j\\) times \\(j\\)-th column. operation reduces degree \\(k\\)-th column one. procedure repeated column end matrix regular. See also @Wolovich1974. coefficients \\(\\alpha_j\\) determined SVD column end matrix.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"impulse-response","dir":"Articles","previous_headings":"Realization Algorithms","what":"Impulse Response","title":"Rational Matrices: Technical Details","text":"One main features rational functions Hankel matrix impulse response coefficients finite rank: \\[ H = \\begin{pmatrix} k_1 & k_2 & \\cdots \\\\ k_2 & k_3 & \\cdots \\\\ \\vdots & \\vdots & \\end{pmatrix} \\] Note impulse response function well defined rational matrix pole \\(z=0\\).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"lmfd","dir":"Articles","previous_headings":"Realization Algorithms > Impulse Response","what":"LMFD","title":"Rational Matrices: Technical Details","text":"consider \\((m,n)\\)-dimensional rational matrix LMFD form \\[ k(z) = ^{-1}(z) b(z) = k_0 + k_1 z + k_2 z^2 + \\cdots \\] \\((z)=a_0 + a_1 z + \\cdots + a_p z^p\\) \\(b(z)=b_0 + b_1 z +\\cdots + b_p z^p\\). W.l.o.g set \\(p=q\\). implies \\[ \\begin{array}{rcl} (z)(k(z) - k_0) &=& b(z) - (z)k_0 \\\\ (a_0 + a_1 z + \\cdots + a_p z^p)(k_1 z + k_2 z + \\cdots ) &=& (b_0-a_0k_0) + (b_1-a_1 k_0) z + \\cdots + (b_p-a_p k_0) z^p \\end{array} \\] thus \\[ \\sum_{=0}^p a_{p-} k_{j+} = 0 \\mbox{ } j\\geq 1. \\] identity follows Hankel matrix \\(H\\) finite rank coefficients polynomial \\((z)\\) closely related left kernel \\(H\\). following discuss, construct unique LMFD rational matrix \\(k()\\) via identity. order describe linear dependence structure rows \\(H\\) convenient use “double” index rows: Let \\(h(,j)\\\\mathbb{R}^{1\\times \\infty}\\) denote \\(j\\)-th row \\(\\)-th block row \\(H\\), .e. \\(h(,j)\\) \\(((-1)m+j)\\)-th row \\(H\\). selection \\(\\mathcal{S}=\\{(i_k,j_k) \\,|\\, k=1,\\ldots ,s\\}\\) rows Hankel matrix called nice selection, “holes” sense \\((,j)\\\\mathcal{S}\\), \\(>1\\) implies \\((-1,j)\\\\mathcal{S}\\). Nice selections may described multi-index \\(\\nu = (\\nu_1, \\ldots ,\\nu_m)\\), \\(\\nu_j=\\max \\{\\,|\\,(,j)\\\\mathcal{S}\\}\\). Suppose \\(H\\) rank \\(s\\). general many different selections rows \\(H\\) form basis row space \\(H\\). following choose first \\(s\\) rows \\(H\\) form basis row space denote corresponding selection \\(\\mathcal{S}=\\{(i_k,j_k) \\,|\\, k=1,\\ldots ,s\\}\\). Due Hankel structure \\(H\\) nice selection sense. corresponding \\(\\nu_j\\)’s called Kronecker indices Hankel matrix (respectively rational matrix \\(k(\\cdot)\\)). Note sum Kronecker indices equal rank \\(H\\): \\(\\sum_{j=1}^m \\nu _j = s\\). row \\(h(\\nu_j+1,j)\\) linearly dependent previous (basis) rows therefore \\[ h(\\nu_j+1,j) + \\sum_{\\substack{(\\nu_j+1-,l) \\\\mathcal{S} \\\\ (\\nu_j+1-,l) < (\\nu_j+1,j)}} a_{,jl} h(\\nu_j+1-,l) = 0 \\] holds suitably chosen coefficients \\(a_{,jl}\\). sum runs basis rows previous row \\(h(\\nu_j+1,j)\\), .e. notation \\((k,l) < (,j)\\) means (\\(k < \\)) (\\(k=\\) \\(l<j)\\)). equation now (uniquely) defines polynomial matrix \\((z) = a_0 + a_1 z + \\cdots + a_p z^p\\), \\(p=\\max_j{\\nu_j}\\). Let \\(a_{,jl}\\) denote \\((jl)\\)-th entry matrix \\(a_i\\). entries \\(a_{,jl}\\), \\((\\nu_j+1-,l) \\\\mathcal{S}\\) \\((\\nu_j+1-,l) < (\\nu_j+1,j)\\) read equation, \\(a_{0,jj}\\) set one (\\(a_{0,jj}=1\\)) entries set zero. construction \\((z)(k(z)-k_0)\\) polynomial (degree less equal \\(p=\\max_j\\nu_j\\)). last step set \\[ b(z) = (z)(k(z)-k_0) + (z)k_0. \\] construction one gets unique LMFD representation rational matrix \\(k(z)\\) following properties: \\(a_0\\) lower triangular matrix ones diagonal. \\(b_0 = a_0 k_0\\). particular square rational matrix \\(k_0=I_m\\) \\(b_0=a_0\\). row degrees \\(((z),b(z))\\) equal \\(\\nu_1,\\ldots,\\nu_m\\), elements \\(a_{ij}(z)\\) divisible \\(z^{\\nu_{ij}}\\), \\(\\nu_{ij} = \\max(\\nu_i+1-\\nu_j,1)\\) \\(j>\\) \\(\\nu_{ij} = \\max(\\nu_i+1-\\nu_j,0)\\) \\(j<\\). pair \\(((z), b(z))\\) left coprime row reduced. pair \\(((z),b(z))\\) satisfied conditions said echelon canonical form.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"ho-kalman","dir":"Articles","previous_headings":"Realization Algorithms > Impulse Response","what":"Ho-Kalman","title":"Rational Matrices: Technical Details","text":"quite analogous strategy may used construct (unique) state space realization rational matrix. Suppose Hankel matrix \\(H\\) rank \\(s\\) \\(S\\\\mathbb{R}^{s\\times \\infty}\\) \\(SH\\) basis row space \\(H\\). state space representation rational matrix \\(k(\\cdot)\\) obtained solving following equations \\[ \\begin{array}{rcl} SH_{-1,.} &=& SH \\\\ H_{1,.} &=& C SH \\\\ SH_{.,1} &=& B \\\\ k_0 &=& D, \\end{array} \\] \\[ H_{-1,.} = \\begin{pmatrix} k_2 & k_3 & \\cdots \\\\ k_3 & k_4 & \\cdots \\\\ \\vdots & \\vdots & \\end{pmatrix} \\, \\quad H_{1,.} = \\begin{pmatrix} k_1 & k_2 & \\cdots \\end{pmatrix} \\, \\mbox{ } H_{,1} = \\begin{pmatrix} k_1 \\\\ k_2 \\\\ \\vdots \\end{pmatrix} \\] obtained result clearly depends matrix \\(S\\), .e. choice basis row space \\(H\\). Two choices implemented: echelon form: \\(S\\) selection matrix selects first \\(s\\) linearly independent rows \\(H\\). statespace realization obtained echelon canonical form. balanced form: \\(S\\) obtained via SVD decomposition finite dimensional sub matrix \\(H\\). details, see …","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"notes","dir":"Articles","previous_headings":"Realization Algorithms > Impulse Response","what":"Notes:","title":"Rational Matrices: Technical Details","text":"constructions LMFD statespace representations also work finite dimensional sub matrix \\[ H_{fp} = \\begin{pmatrix} k_1 & k_2 & \\cdots & k_p \\\\ k_2 & k_3 & \\cdots & k_{p+1}\\\\ \\vdots & \\vdots &  & \\vdots \\\\ k_f & k_{f+1} & \\cdots & k_{f+p-1} \\end{pmatrix} \\] provided \\((f,p)\\) “large enough”. detailed discussion Kronecker indices echelon canonical forms, see @Hannan.Deistler12.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"addition","dir":"Articles","previous_headings":"Operations with/on Statespace Realizations","what":"Addition","title":"Rational Matrices: Technical Details","text":"\\[ (C_1 (z^{-1} - A_1)^{-1} B_1 + D_1) + (C_2 (z^{-1} - A_2)^{-1} B_2 + D_2) \\] \\[ \\left[\\begin{array}{@{}cc|c@{}} A_1      & 0   & B_1   \\\\ 0        & A_2 & B_2 \\\\  \\hline C_1      & C_2 & D_1 + D_2 \\end{array}\\right] \\] See Ops.ratm() particular + b.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"multiplication","dir":"Articles","previous_headings":"Operations with/on Statespace Realizations","what":"Multiplication","title":"Rational Matrices: Technical Details","text":"\\[ (C_1 (z^{-1} - A_1)^{-1} B_1 + D_1) \\cdot (C_2 (z^{-1} - A_2)^{-1} B_2 + D_2) \\] \\[ \\left[\\begin{array}{@{}cc|c@{}} A_1      & B_1 C_2 & B_1 D_2   \\\\ 0        & A_2     & B_2 \\\\  \\hline C_1      & D_1 C_2 & D_1 D_2 \\end{array}\\right] \\] See %r% b.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"inverse","dir":"Articles","previous_headings":"Operations with/on Statespace Realizations","what":"Inverse","title":"Rational Matrices: Technical Details","text":"\\[ (C (z^{-1} - )^{-1} B + D)^{-1} \\] \\[ \\left[\\begin{array}{@{}c|c@{}} - B D^{-1} C & BD^{-1}   \\\\ \\hline -D^{-1}C       & D^{-1} \\end{array}\\right] \\] See Ops.ratm() particular x^{-1}.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"bind-by-columns-or-rows","dir":"Articles","previous_headings":"Operations with/on Statespace Realizations","what":"Bind by columns or rows","title":"Rational Matrices: Technical Details","text":"\\[ \\begin{pmatrix} C_1 (z^{-1} - A_1)^{-1} B_1 + D_1) & C_2 (z^{-1} - A_2)^{-1} B_2 + D_2) \\end{pmatrix} \\] \\[ \\left[\\begin{array}{@{}cc|cc@{}} A_1      & 0       & B_1 & 0   \\\\ 0        & A_2     & 0   & B_2 \\\\  \\hline C_1      & C_2     & D_1 & D_2 \\end{array}\\right] \\] See cbind.ratm(). \\[ \\begin{pmatrix} C_1 (z^{-1} - A_1)^{-1} B_1 + D_1 \\\\ C_2 (z^{-1} - A_2)^{-1} B_2 + D_2 \\end{pmatrix} \\] \\[ \\left[\\begin{array}{@{}cc|c@{}} A_1      & 0       & B_1 \\\\ 0        & A_2     & B_2 \\\\  \\hline C_1      & 0       & D_1 \\\\ 0        & C_2     & D_2 \\end{array}\\right] \\] See rbind.ratm().","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"elementwise-multiplication","dir":"Articles","previous_headings":"Operations with/on Statespace Realizations","what":"Elementwise Multiplication","title":"Rational Matrices: Technical Details","text":"First consider product two \\((m\\times 1)\\) matrices, write elementwise product product suitable diagonal matrix second factor \\[ \\left[\\begin{array}{@{}cccc|c@{}} A_1     & \\cdots  & 0       & B_1 C_{2,1}     & B_1 D_{2,1}   \\\\ \\vdots  & \\ddots  & \\vdots  & \\vdots          & \\vdots        \\\\ 0       & \\cdots  & A_1     & B_1 C_{2,m}     & B_1 D_{2,m}   \\\\ 0       & \\cdots  & 0       & A_2             & B_2           \\\\  \\hline C_{1,1} & \\cdots  & 0       & D_{1,1} C_{2,1} & D_{1,1} C_{2,1}  \\\\ \\vdots  & \\ddots  & \\vdots  & \\vdots          & \\vdots           \\\\ 0       & \\cdots  & C_{1,m} & D_{1,m} C_{2,m} & D_{1,m} D_{2,m}   \\end{array}\\right] \\] \\(C_{,k}\\) denotes \\(k\\)-th row \\(C_i\\) \\(D_{,k}\\) \\(k\\)-entry \\((m\\times 1)\\)-dimensional matrix \\(D_i\\). can shown (???) controllability matrix statespace model rank \\((s_1 + s_2)\\). Therefore may construct equivalent model state dimension \\((s_1 + s_2)\\). Now simply construction columns two factors \\((z)\\) \\(b(z)\\) “column-bind” result. statespace realisation state dimension \\(n(s_1+s_2)\\). “wide” matrices (\\(m< n\\)) consider transpose two factors. gives statespace realisations \\[ s = \\min(m,n)(s_1+s_2). \\] proof ??? kann man die \\((s_1+s_2)\\) Zustandsraum Darstellung direkt “hinschreiben”? See Ops.ratm() particular * b.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"transpose","dir":"Articles","previous_headings":"Operations with/on Statespace Realizations","what":"Transpose","title":"Rational Matrices: Technical Details","text":"\\[ (C(z^{-1}- )^{-1} B + D)' = B'(z^{-1}- ')^{-1} C + D' \\] \\[ \\left[\\begin{array}{@{}c|c@{}} ' & C'  \\\\  \\hline B' & D' \\end{array}\\right] \\] See t().","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"hermitean-transpose","dir":"Articles","previous_headings":"Operations with/on Statespace Realizations","what":"Hermitean Transpose","title":"Rational Matrices: Technical Details","text":"\\[ \\begin{array}{rcl} [C(z^{-1}- )^{-1} B + D]^* &=& B' (zI - ')^{-1} C' + D' \\\\ &=& B' [(-'z)(z^{-1}-^{-T})]^{-1}C' + D' \\\\ &=& B' [(-^{-T}z^{-1})(zI + z^2A^{-T} + z^3A^{-2T} + \\cdots)]C' + D' \\\\ &=& (-^{-1}B)' [zI + z^2A^{-T} + Z^3A^{-2T} + \\cdots)](CA^{-1})' + D' - B' ^{-T}C'\\\\ &=& (-^{-1}B)' (z^{-1} - ^{-T})^{-1}(CA^{-1})' + (D' - B' ^{-T}C')\\\\ \\end{array} \\] \\[ \\left[\\begin{array}{@{}c|c@{}} ^{-T}      & (CA^{-1})'  \\\\  \\hline (-^{-1}B)' & D' - B' ^{-T} C' \\end{array}\\right] \\] See Ht().","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"derivative","dir":"Articles","previous_headings":"Operations with/on Statespace Realizations","what":"Derivative","title":"Rational Matrices: Technical Details","text":"\\[ \\begin{array}{rcl} \\frac{d}{dz} (C(z^{-1} - )^{-1}B+D) &=& \\frac{d}{dz}(D + CBz + CABz^2 + CA^2Bz^3  + CA^2Bz^4 + \\cdots )\\\\ &=& CB + 2CABz + 3CA^2Bz^2 + 4CA^2Bz^3 +\\cdots \\\\ &=& \\bar{C}\\bar{}\\bar{B} + \\bar{C}\\bar{}^2\\bar{B}z + \\bar{C}\\bar{}^3\\bar{B}z^2  + \\bar{C}\\bar{}^4\\bar{B}z^3 +\\cdots \\\\ \\end{array} \\] \\[ \\bar{C} = \\begin{pmatrix} C & 0 \\end{pmatrix},\\ \\bar{} = \\begin{pmatrix} & \\\\ 0 & \\end{pmatrix} \\mbox{ } \\bar{B} = \\begin{pmatrix} 0 \\\\ B \\end{pmatrix}. \\] corresponding statespace realization \\[ \\left[\\begin{array}{@{}cc|c@{}}     &       & B  \\\\ 0     &       & AB \\\\  \\hline CA    & C       & CB \\end{array}\\right] \\] See derivative.stsp().","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"construct-statespace-representation-of-rational-matrix-in-lmfd-form","dir":"Articles","previous_headings":"Operations with/on Statespace Realizations","what":"Construct statespace representation of rational matrix in LMFD form","title":"Rational Matrices: Technical Details","text":"Suppose \\(c(z)=^{-1}(z) b(z)\\) \\((z) = a_0 + a_1 z + a_2 z^2 + \\cdots + a_p z^p\\), \\(b(z) = b_0 + b_1 z + \\cdots + b_q z^q\\) given. construction, detailed , assumes \\(a_0\\) non singular hence rewrite polynomial \\((z)\\) \\((z) = I_m - a_1 z - a_2 z^2 - \\cdots - a_p z^p\\). Furthermore assume, w.l.o.g \\(p=q\\). powerseries expansion \\(c(\\cdot)\\) \\(c(z)=k_0 + k_1 z + \\cdots + k_pz^p + \\cdots\\). statespace realization \\(c(\\cdot)\\) \\[ \\left[\\begin{array}{@{}cccc|c@{}} a_1   & \\cdots & a_{p-1} & a_p    & k_p     \\\\ I_m   & \\cdots & 0       & 0      & k_{p-1} \\\\ \\vdots& \\ddots & \\vdots  & \\vdots & \\vdots  \\\\ 0     & \\cdots & I_m     & 0      & k_1     \\\\ \\hline 0     & \\cdots & 0       & I_m    & k_0 \\end{array}\\right] \\] scheme implemented .stsp.lmfd (.stsp.polm).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"construct-statespace-representation-of-rational-matrix-in-rmfd-form","dir":"Articles","previous_headings":"Operations with/on Statespace Realizations","what":"Construct statespace representation of rational matrix in RMFD form","title":"Rational Matrices: Technical Details","text":"Likewise, possible write RMFD $k(z)=d(z) c^{-1}(z) $, \\(c(z) = c_0 + c_1 z + c_2 z^2 + \\cdots + c_p z^p\\), \\(d(z) = d_0 + d_1 z + \\cdots + d_q z^q\\) given. , simplify exposition setting non-singular \\(c_0\\) equal \\(m\\)-dimensional identity matrix \\(I_m\\). case \\(p \\geq q\\), state space realization \\(k(z)\\) \\[ \\left[\\begin{array}{@{}cccc|c@{}} c_1   & \\cdots & c_{p-1} & c_p    & I_m     \\\\ I_m   & \\cdots & 0       & 0      & 0 \\\\ \\vdots& \\ddots & \\vdots  & \\vdots & \\vdots  \\\\ 0     & \\cdots & I_m     & 0      & 0     \\\\ \\hline d_1     & \\cdots & d_{q-1}       & d_q    & d_0 \\end{array}\\right] \\] \\(p>q\\), zeros appear \\(C\\) matrix. \\(p<q\\), zeros padded \\(\\) matrix. scheme implemented .stsp.rmfd.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"lyapunov-equation","dir":"Articles","previous_headings":"Schur, QZ decomposition, Lyapunov and Riccati Equations","what":"Lyapunov equation","title":"Rational Matrices: Technical Details","text":"generalized (non-symmetric) Lyapunov equation \\[ X = X B^* + Q \\] Schur factorization \\(\\) \\(B\\) obtain form triangular matrices \\(\\), \\(B\\) \\[ \\begin{array}{rcl} \\begin{pmatrix} X_{11} & X_{12} \\\\ X_{21} & X_{22} \\end{pmatrix} &=& \\begin{pmatrix} A_{11} & A_{12} \\\\ 0 & A_{22} \\end{pmatrix} \\begin{pmatrix} X_{11} & X_{12} \\\\ X_{21} & X_{22} \\end{pmatrix} \\begin{pmatrix} B_{11}^* & 0 \\\\ B_{12}^* & B_{22}^* \\end{pmatrix} + \\begin{pmatrix} Q_{11} & Q_{12} \\\\ Q_{21} & Q_{22} \\end{pmatrix} \\\\ &=& \\begin{pmatrix} A_{11}X_{11}B_{11}^* +  A_{11}X_{12}B_{12}^* + A_{12}X_{21}B_{11}^* + A_{12}X_{22}B_{12}^* &     (A_{11}X_{12}+A_{12}X_{22})B_{22}^*     \\\\ A_{22}(X_{21}B_{11}^*+X_{22}B_{12}^*) & A_{22}X_{22}B^*_{22} \\end{pmatrix} + \\begin{pmatrix} Q_{11} & Q_{12} \\\\ Q_{21} & Q_{22} \\end{pmatrix} \\end{array} \\] 22-block: solve \\(X_{22}\\) 12-block: solve \\(X_{12}\\) 21-block: solve \\(X_{21}\\) continue 11-block also consider non-square case, \\(\\) \\(m\\times m\\), \\(B\\) \\(n\\times n\\) \\(Q\\) \\(m\\times n\\).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"balancing-and-balanced-truncation","dir":"Articles","previous_headings":"Schur, QZ decomposition, Lyapunov and Riccati Equations","what":"Balancing and Balanced Truncation","title":"Rational Matrices: Technical Details","text":"Consider pair Grammians \\(P,Q\\). first compute sqare roots \\(P=MM'\\) \\(Q=NN'\\) consider SVD1 \\(M'N\\): \\[ M'N = U \\Sigma V' = [U_1, U_2] \\begin{pmatrix} \\Sigma_{11} & 0 \\\\ 0 & \\Sigma_{22} \\end{pmatrix} [V_1, V_2]' \\] diagonal blocks \\(\\Sigma_{11}\\), \\(\\Sigma_{22}\\) size \\((s_1,s_1)\\) \\((s_2,s_2)\\) respectively. assume \\(\\Sigma_{11}\\) positive definite set \\[ \\begin{array}{rcl} T_1 &=& \\Sigma_{11}^{-1/2} V_1' N' \\\\ S_1 &=& M U_1\\Sigma_{11}^{-1/2} \\end{array} \\] note \\[ \\begin{array}{rcl} T_1 S_1 &=& \\Sigma_{11}^{-1/2} V_1' N' M U_1\\Sigma_{11}^{-1/2} \\\\         &=& \\Sigma_{11}^{-1/2} V_1' V \\Sigma U' M U_1\\Sigma_{11}^{-1/2} = I_{s_1} \\end{array} \\] extend matrices square \\((s\\times s)\\) matrices \\[ T = \\begin{pmatrix} T_1 \\\\ T_2 \\end{pmatrix} \\mbox{ } S = \\begin{pmatrix} S_1 & S_2 \\end{pmatrix} \\] \\(TS=ST= I_s\\), .e. \\(S= T^{-1}\\). end consider SVD’s \\[ \\begin{array}{rclcl} S_1 T_1 &=& \\bar{U}_1 \\bar{\\Sigma}_{11} \\bar{V}_1' &&\\bar{U}_1,\\bar{V}_1\\\\mathbb{R}^{s\\times s_1},\\,                                                      \\bar{\\Sigma}_{11} \\\\mathbb{R}^{s_1 \\times s_1} \\\\ \\bar{U}_2'\\bar{V}_2 &=& \\hat{U}\\hat{\\Sigma}\\hat{V}' &&\\hat{U},\\hat{V},\\hat{\\Sigma} \\\\mathbb{R}^{s_2\\times s_2} \\end{array} \\] set \\(T_2 = \\hat{\\Sigma}^{-1/2}\\hat{U}'\\bar{U}_2'\\) \\(S_2 = \\bar{V}_2\\hat{V}\\hat{\\Sigma}^{-1/2}\\). now consider transformed statespace realization \\[ \\left[\\begin{array}{@{}c|c@{}} & B \\\\ \\hline C & D \\end{array}\\right] \\; \\longrightarrow \\; \\left[\\begin{array}{@{}cc|c@{}} T_1 S_1 & T_1 S_2 & T_1 B \\\\ T_2 S_1 & T_2 S_2 & T_2 B \\\\ \\hline C S_1 & C S_2  & D \\end{array}\\right] \\] Grammians transformed \\(P \\rightarrow TPT'\\) \\(Q \\rightarrow S' QS\\). \\[ T M = \\begin{pmatrix} \\Sigma_{11}^{-1/2} V_1' N' M \\\\ T_2 M \\end{pmatrix}     = \\begin{pmatrix} \\Sigma_{11}^{1/2} U_1' \\\\ T_2 M \\end{pmatrix} \\] \\[ S' N = \\begin{pmatrix} \\Sigma_{11}^{-1/2} U_1' M' N \\\\ S_2' N \\end{pmatrix}     = \\begin{pmatrix} \\Sigma_{11}^{1/2} V_1' \\\\ S_2' N \\end{pmatrix} \\] \\[ TPT' = (TM)(TM)' = \\begin{pmatrix} \\Sigma_{11}^{1/2} U_1' U_1 \\Sigma_{11}^{1/2}  & \\Sigma_{11}^{1/2} U_1' M' T_2'  \\\\ T_2 M U_1 \\Sigma_{11}^{1/2}                    & T_2 MM' T_2' \\end{pmatrix} = \\begin{pmatrix} \\Sigma_{11} & 0 \\\\ 0           & T_2 P T_2' \\end{pmatrix} \\] \\[ S'QS = (S'N)(S'N)' = \\begin{pmatrix} \\Sigma_{11}^{-1/2} V_1' V_1 \\Sigma_{11}^{1/2}  & \\Sigma_{11}^{1/2} V_1' N' S_2  \\\\ S_2' N V_1 \\Sigma_{11}^{1/2}                    & S_2' NN' S_2   \\end{pmatrix} = \\begin{pmatrix} \\Sigma_{11} & 0 \\\\ 0           & S_2' Q S_2 \\end{pmatrix} \\] used \\(T_2 M U_1 \\Sigma_{11}^{1/2} = T_2 S_1 \\Sigma_{11} = 0\\) \\(\\Sigma_{11}^{1/2} V_1' N' S_2 = \\Sigma_{11} T_1 S_2 = 0\\). Due block diagonal structure \\(TPT'\\) \\(S'QS\\) also immediately get \\[ TPQS = TPT' S'QS =   \\begin{pmatrix} \\Sigma_{11}^2 & 0 \\\\ 0           & T_2 P Q S_2 \\end{pmatrix} \\] \\[ T_2 PQ S_2 = T_2 MM' NN' S_2 = T_2 M U\\Sigma V' N'S_2 = \\underbrace{T_2 M U_1}_{=0}\\Sigma_{11} \\underbrace{V_1' N' S_2}_{=0} + T_2 M U_2\\Sigma_{22} V_2' N' S_2 = T_2 M U_2\\Sigma_{22} V_2' N' S_2. \\] following scenarios particular interest: \\(s_2=0\\): model minimal procedure renders statespace realization balanced form. \\(s_2>0\\) \\(\\Sigma_{22} = 0\\): procedure renders model form controllable observable states clearly seperated non observable non controllable states. particular truncated model \\[ \\left[\\begin{array}{@{}c|c@{}} T_1 S_1 & T_1 B \\\\ T_2 S_1 & T_2 B \\\\ \\hline C S_1     & D \\end{array}\\right] \\] equivalent original model minimal balanced form \\(s_2>0\\) \\(\\Sigma_{22} \\neq 0\\) truncated model just approximation original model. quality depends size neglected singular values. Note also truncated model balanced. Note determination number non zeroe singular values quite tricky. (difficult due numerics). Currently number non zero singular values chosen number singular values satisfy \\(\\sigma_k > \\tau \\sigma_1\\) \\(\\tau\\) user defined tolerance parameter.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"all-pass-matrices","dir":"Articles","previous_headings":"Schur, QZ decomposition, Lyapunov and Riccati Equations > Reflect Poles and Zeroes","what":"All-Pass Matrices","title":"Rational Matrices: Technical Details","text":"rational matrix \\(k(z)\\) -pass \\(k(z) k'\\left(\\frac{1}{z}\\right) = k'\\left(\\frac{1}{z}\\right) k(z) = I_m\\). \\((,B,C,D)\\) statespace realization \\(k(z)\\) product \\(k(z) k'\\left(\\frac{1}{z}\\right)\\) realization given \\[ \\left[\\begin{array}{@{}cc|c@{}}   & -BB'^{-T}   & BD' - BB'^{-T}C' \\\\ 0   & ^{-T}       & ^{-T}C' \\\\ \\hline C   & -DB'^{-T}   & DD' - DB' ^{-T} C' \\end{array}\\right] \\] state transformation gives \\[ \\left[ \\begin{array}{@{}cc|c@{}} & X & 0 \\\\ 0 & & 0 \\\\ \\hline 0 & 0 & \\end{array} \\right] \\left[\\begin{array}{@{}cc|c@{}}   & -BB'^{-T}   & BD' - BB'^{-T}C' \\\\ 0   & ^{-T}       & ^{-T}C' \\\\ \\hline C   & -DB'^{-T}   & DD' - DB' ^{-T} C' \\end{array}\\right] \\left[ \\begin{array}{@{}cc|c@{}} & -X & 0 \\\\ 0 & & 0 \\\\ \\hline 0 & 0 & \\end{array} \\right] = \\left[\\begin{array}{@{}cc|c@{}}   & XA^{-T}-AX-BB'^{-T}   & BD' - BB'^{-T}C' + X ^{-T}C'\\\\ 0   & ^{-T}                 & ^{-T}C' \\\\ \\hline C   & -DB'^{-T}-CX   & DD' - DB' ^{-T} C' \\end{array}\\right] \\] (1,1) block controllable (2,2) block observable \\[ \\begin{array}{rclcrcl} XA^{-T}-AX-BB'^{-T} &=& 0 & \\Longleftrightarrow   & X -AXA' - BB' &=& 0 \\\\ -DB'^{-T}-CX &=& 0        &  \\Longleftrightarrow  & [X', ^{-1}B] [C, D]' &=& 0\\\\ BD' - BB'^{-T}C' + X ^{-T}C' &=& 0                            &  \\Longleftrightarrow  & [XA^{-T}-BB'^{-T}, B][C, D]'  &=& 0\\\\ & &                       &  \\Longleftrightarrow  & [AX', B][C, D]'  &=& 0\\\\ \\end{array} \\] Furthermore \\[ DD' - DB' ^{-T} C' = D[B'^{-T}, -][C,D]' = \\] must hold. follows end system \\[ \\left[\\begin{array}{@{}cc|c@{}}   & 0   & 0\\\\ 0   & ^{-T}                 & ^{-T}C' \\\\ \\hline C   & 0   & \\end{array}\\right] \\] whose transfer function equal \\[ \\begin{pmatrix} C & 0 \\end{pmatrix} \\left( z^{-1} - \\begin{pmatrix} & 0 \\\\ 0 & ^{-T} \\end{pmatrix} \\right)^{-1} \\begin{pmatrix} 0 \\\\ ^{-T}C' \\end{pmatrix} + I_m, \\] .e. identity matrix required. following need construct allpass matrix given \\((,B)\\) (given \\((,C)\\)). Lyapunov equation \\(X = AXA' + BB'\\) determine \\(X\\). Determine row space \\([C,D]\\) left kernel \\([AX',B]'\\). Determine scaling matrix requirement \\(DD' - DB' ^{-T} C' = \\). Note: Wann gibt es Probleme? ….","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"zero-cancellations","dir":"Articles","previous_headings":"Schur, QZ decomposition, Lyapunov and Riccati Equations > Reflect Poles and Zeroes","what":"zero cancellations","title":"Rational Matrices: Technical Details","text":"Let \\(k(z)\\) given. want find allpass transfer function \\(\\hat{k}(z)\\) poles \\(k(z)\\) cancelled \\(k(z)\\hat{k}(z)\\). Consider state transformation realization \\(k\\hat{k}\\): \\[ \\left[ \\begin{array}{@{}ccc|c@{}} & 0 & 0 & 0 \\\\ 0 & & 0  & 0 \\\\ & 0 &  & 0 \\\\ \\hline 0 & 0 & 0  & \\end{array} \\right] \\left[ \\begin{array}{@{}ccc|c@{}} A_{11} & A_{12} & B_{1}\\hat{C} & B_{1}\\hat{D} \\\\ A_{21} & A_{22} & B_{2}\\hat{C} & B_{2}\\hat{D} \\\\      0 & 0      & \\hat{}      & \\hat{B} \\\\ \\hline C_{1}  & C_{2}  & D\\hat{C}     & D\\hat{D} \\end{array} \\right] \\left[ \\begin{array}{@{}ccc|c@{}} & 0 & 0 & 0 \\\\ 0 & & 0 & 0 \\\\ -& 0 & & 0 \\\\ \\hline 0 & 0 & 0 & \\end{array} \\right] = \\left[ \\begin{array}{@{}ccc|c@{}} A_{11}-B_{1}\\hat{C}    & A_{12} & B_{1}\\hat{C} & B_{1}\\hat{D}\\\\ A_{21}-B_{2}\\hat{C}    & A_{22} & B_{2}\\hat{C}           & B_2 \\hat{D} \\\\ A_{11}-B_{1}\\hat{C} -\\hat{}         & A_{12}      & \\hat{} + B_{1}\\hat{C}  & B_{1}\\hat{D} + \\hat{B} \\\\ \\hline C_{1}-D\\hat{C}  & C_{2}  & D\\hat{C}                  & D\\hat{D} \\end{array} \\right] \\] \\((1,1)\\) block observable \\[ \\begin{array}{rclcrcl} A_{21} - B_2 \\hat{C} &=& 0 &\\Longleftrightarrow& A_{21} - B_2 D^{-1} C_1 &=& 0\\\\ A_{11}-B_{1}\\hat{C} -\\hat{} &=& 0 &\\Longleftrightarrow& \\hat{} &=& A_{11} - B_1 D^{-1} C_1 \\\\ C_{1}-D\\hat{C} &=& 0 &\\Longleftrightarrow& \\hat{C} &=& D^{-1} C_1 \\\\ \\end{array} \\]","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"pole-cancellations","dir":"Articles","previous_headings":"Schur, QZ decomposition, Lyapunov and Riccati Equations > Reflect Poles and Zeroes","what":"pole cancellations","title":"Rational Matrices: Technical Details","text":"Let \\(k(z)\\) given. want find allpass transfer function \\(\\hat{k}(z)\\) poles \\(k(z)\\) cancelled \\(k(z)\\hat{k}(z)\\). Consider state transformation realization \\(k\\hat{k}\\): \\[ \\left[ \\begin{array}{@{}ccc|c@{}} & 0 & -& 0 \\\\ 0 & & 0  & 0 \\\\ 0 & 0 &  & 0 \\\\ \\hline 0 & 0 & 0  & \\end{array} \\right] \\left[ \\begin{array}{@{}ccc|c@{}} A_{11} & A_{12} & B_{1}\\hat{C} & B_{1}\\hat{D} \\\\ A_{21} & A_{22} & B_{2}\\hat{C} & B_{2}\\hat{D} \\\\      0 & 0      & \\hat{}      & \\hat{B} \\\\ \\hline C_{1}  & C_{2}  & D\\hat{C}     & D\\hat{D} \\end{array} \\right] \\left[ \\begin{array}{@{}ccc|c@{}} & 0 & & 0 \\\\ 0 & & 0 & 0 \\\\ 0 & 0 & & 0 \\\\ \\hline 0 & 0 & 0 & \\end{array} \\right] = \\left[ \\begin{array}{@{}ccc|c@{}} A_{11}    & A_{12} & A_{11} + B_{1}\\hat{C} - \\hat{} & B_{1}\\hat{D} - \\hat{B} \\\\ A_{21}    & A_{22} & A_{21} + B_{2}\\hat{C}           & B_2 \\hat{D} \\\\ 0         & 0      & \\hat{}                         & \\hat{B} \\\\ \\hline C_{1}     & C_{2}  & C_1 + D\\hat{C}                  & D\\hat{D} \\end{array} \\right] \\] (1,1) block controllable \\[ \\begin{array}{rclcrcl} A_{12} &=& 0                       & \\Longleftrightarrow & A_{12} &=& 0\\\\ \\hat{} &=& A_{11} + B_1 \\hat{C}   & \\Longleftrightarrow & (\\hat{} - \\hat{B} \\hat{D}^{-1} \\hat{C}) &=& A_{11}\\\\ \\hat{B} &=& B_1 \\hat{D}            & \\Longleftrightarrow & (\\hat{B}\\hat{D}^{-1}) &=& B_{1} \\end{array} \\] Hence “\\(,B\\)” matrices inverse \\(\\hat{k}^{-1}\\) determined.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/articles/b_technical_details_ratm.html","id":"qr-decomposition-rank-and-null-space","dir":"Articles","previous_headings":"","what":"QR decomposition, Rank and Null Space","title":"Rational Matrices: Technical Details","text":"Consider following example desired result rank (null space)? main reason somewhat strange results qr() considers column zero, projection onto space spanned previous columns reduces norm factor larger tol. following example works desired","code":"tol = 1e-7 tol2 = tol/10  x = diag(c(1,tol2, tol2^2, tol2^3)) qr_x = qr(x, tol = tol)  x #>      [,1]  [,2]  [,3]  [,4] #> [1,]    1 0e+00 0e+00 0e+00 #> [2,]    0 1e-08 0e+00 0e+00 #> [3,]    0 0e+00 1e-16 0e+00 #> [4,]    0 0e+00 0e+00 1e-24 qr_x$rank #> [1] 4 qr_x$pivot #> [1] 1 2 3 4 qr.R(qr_x) #>      [,1]   [,2]   [,3]  [,4] #> [1,]   -1  0e+00  0e+00 0e+00 #> [2,]    0 -1e-08  0e+00 0e+00 #> [3,]    0  0e+00 -1e-16 0e+00 #> [4,]    0  0e+00  0e+00 1e-24 x[1,] = 1 x[nrow(x), ncol(x)] = 1 qr_x = qr(x, tol = tol)  x #>      [,1]  [,2]  [,3] [,4] #> [1,]    1 1e+00 1e+00    1 #> [2,]    0 1e-08 0e+00    0 #> [3,]    0 0e+00 1e-16    0 #> [4,]    0 0e+00 0e+00    1 qr_x$rank #> [1] 2 qr_x$pivot #> [1] 1 4 2 3 qr.R(qr_x) #>      [,1] [,2]   [,3]   [,4] #> [1,]   -1   -1 -1e+00 -1e+00 #> [2,]    0   -1  0e+00  0e+00 #> [3,]    0    0 -1e-08  0e+00 #> [4,]    0    0  0e+00  1e-16"},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Wolfgang Scherrer. Author. Bernd Funovits. Author, maintainer.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Scherrer W, Funovits B (2023). rationalmatrices: Classes Methods Rational Matrices. R package version 0.3.3, https://bfunovits.github.io/rationalmatrices/.","code":"@Manual{,   title = {rationalmatrices: Classes and Methods for Rational Matrices},   author = {Wolfgang Scherrer and Bernd Funovits},   year = {2023},   note = {R package version 0.3.3},   url = {https://bfunovits.github.io/rationalmatrices/}, }"},{"path":"https://bfunovits.github.io/rationalmatrices/index.html","id":"a-package-for-rational-matrices","dir":"","previous_headings":"","what":"Classes and Methods for Rational Matrices","title":"Classes and Methods for Rational Matrices","text":"rationalmatrices collects classes, methods tools creating manipulating rational matrices, .e. matrices whose entries rational functions.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Classes and Methods for Rational Matrices","text":"remotes::install_github(\"bfunovits/rationalmatrices\")","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/index.html","id":"classes","dir":"","previous_headings":"","what":"Classes","title":"Classes and Methods for Rational Matrices","text":"exist many different representations rational matrices. package particular deals left matrix fraction representations (ARMA), implemented lmfd class, right matrix fraction representations, implemented rmfd class, state space representations, implemented stsp class. special case, polynomial matrices, polm class, Laurent polynomial matrices, lpolm class, allow negative powers implemented well. latter class special sense even though superset polm object, coerced stsp, lfmd, rmfd objects interaction classes make sense many cases. coefficients power series expansion rational function stored pseries objects collection values rational function may stored zvalues objects. package offers tools convert one representation another (equivalent) representation. methods quite sophisticated, e.g. pseries2stsp based Ho-Kalman Realization Algorithm.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/index.html","id":"general-matrix-methods","dir":"","previous_headings":"","what":"General Matrix Methods","title":"Classes and Methods for Rational Matrices","text":"package provides “standard” generic functions objects: General methods, like print, dim, plot. Arithmetic operations, like addition (matrix) multiplication. Extract parts matrix, transposition, (column row) bind two matrices.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/index.html","id":"special-methods","dir":"","previous_headings":"","what":"Special Methods","title":"Classes and Methods for Rational Matrices","text":"package also provides specific methods rational matrices: Compute poles zeroes rational matrices. Check properties rational matrix, like stability inverse stability. Normal Forms polynomial matrices, like Hermite normal form, Smith form, Wiener-Hopf factorization. Check left primeness .coprime() Compute derivative (respect z) Tools related state space representations, e.g. computation controllability observability matrices.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/index.html","id":"authors","dir":"","previous_headings":"","what":"Authors","title":"Classes and Methods for Rational Matrices","text":"Wolfgang Scherrer Bernd Funovits","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/Ht.html","id":null,"dir":"Reference","previous_headings":"","what":"Hermitean Transpose — Ht","title":"Hermitean Transpose — Ht","text":"Hermitean transpose rational matrix \\(x(z)\\) defined  $$x^{*}(z)=\\overline{x(\\bar{z}^{-1})}'.$$  means e.g. polynomial real coefficients  \\(x(z)=a_0 + a_1 z +\\cdots + a_p z^p\\)  coefficient matrices transposed \\(z\\) replaced  \\(z^{-1}\\):  \\(x^*(z)=a_0' + a_1' z^{-1} +\\cdots + a_p' z^{-p}\\), .e.  result (general) Laurent polynomial.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/Ht.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hermitean Transpose — Ht","text":"","code":"Ht(x)  # S3 method for polm Ht(x)  # S3 method for lpolm Ht(x)  # S3 method for stsp Ht(x)  # S3 method for zvalues Ht(x)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/Ht.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hermitean Transpose — Ht","text":"x rational matrix object class polm, lpolm,  stsp zvalues.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/Ht.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hermitean Transpose — Ht","text":"rational matrix object represents Hermitean transpose \\(x^*(z)\\).          Hermitean transpose polynomial matrix (general) Laurent polynomial,          therefore output class lpolm x polm object.          cases output class input x.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/Ht.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hermitean Transpose — Ht","text":"Hermitean transpose implemented  polynomial matrices (polm objects),  Laurent polynomials lpolm objects),  rational matrices statespace form (stsp objects)  frequency response rational matrices (zvalues objects). case rational matrices LMFD RMFD form (yet) implemented.  possible directly construct Hermitean transpose  given power series coefficients. Therefore Ht()  support pseries objects. Finally note Hermitean transpose rational matrix  \\(x(z)=D+zB(-Az)^{-1}B\\) statespace form  (general) pole zero, state transition matrix \\(\\)  singular. Since rational matrices pole \\(z=0\\)  statespace realization, procedure Ht() throws error case.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/Ht.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hermitean Transpose — Ht","text":"","code":"# rational matrix in statespace form  x = test_stsp(dim = c(4,4), s = 2) Ht(x) #> statespace realization [4,4] with s = 2 states #>            s[1]       s[2]      u[1]        u[2]       u[3]        u[4] #> s[1]  4.1924923  2.1617158  7.812309  2.57442615  7.3629682  -5.1559544 #> s[2]  2.4801583  0.3778927  2.104994  0.01705809  3.5533117  -4.0171188 #> x[1] 12.9928352  5.6566007 22.298283  6.23541894 21.8896671 -17.0978747 #> x[2] -0.1900343 -0.4691884 -1.391000  0.26283434 -0.6643592  -0.1647283 #> x[3]  3.3766392  0.1252050  1.778483 -0.62746679  5.4909792  -5.8869884 #> x[4] -4.3316269 -2.3148729 -8.298996 -2.79595267 -7.6798349   6.2396736 all.equal(zvalues(Ht(x)), Ht(zvalues(x))) #> [1] TRUE  # Note (x(z)  x^*(z)) is Hermitean for |z| = 1 xx = zvalues(x) %r% Ht(zvalues(x)) # print(xx, digits = 2) apply(unclass(xx), MARGIN = 3, FUN = isSymmetric) #> [1] TRUE TRUE TRUE TRUE TRUE  # polynomial matrix  x = test_polm(dim = c(2,3), degree = 1) Ht(x) #> ( 3 x 2 ) Laurent polynomial matrix with degree <= 0, and minimal degree >= -1 #>      z^-1 [,1]  [,2] z^0 [,1]  [,2] #> [1,]       111   211      110   210 #> [2,]       121   221      120   220 #> [3,]       131   231      130   230  if (FALSE) { Ht(test_lmfd(dim = c(2,2), degrees = c(3,3))) Ht(test_rmfd(dim = c(2,2), degrees = c(3,3))) Ht(pseries(test_lmfd(dim = c(2,2), degrees = c(3,3)))) }"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/Kronecker-Indices.html","id":null,"dir":"Reference","previous_headings":"","what":"Tools related to Kronecker indices — Kronecker-Indices","title":"Tools related to Kronecker indices — Kronecker-Indices","text":"Kronecker indices \\((\\nu_1,\\ldots,\\nu_m)\\) describe (nice) basis row space Hankel matrix impulse response coefficients. indices e.g. used construct (unique) LMFD representation echelon canonical form given impulse response.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/Kronecker-Indices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tools related to Kronecker indices — Kronecker-Indices","text":"","code":"basis2nu(basis, m)  nu2basis(nu)  pseries2nu(obj, Hsize = NULL, tol = sqrt(.Machine$double.eps))"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/Kronecker-Indices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tools related to Kronecker indices — Kronecker-Indices","text":"basis s-dimensional (integer) vector contains indices basis rows Hankel matrix. m (integer) number rows underlying rational matrix. nu vector Kronecker indices, .e. m-dimensional integer vector. obj pseries object 3-D array dimension \\((m,n,l+1)\\).  object represents impulse response rational matrix. Hsize integer vector c(f,p), number block rows block columns  Hankel matrix impulse response coefficients.        NULL default choice made. tol tolerance parameter, used qr.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/Kronecker-Indices.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tools related to Kronecker indices — Kronecker-Indices","text":"basis2nu returns Kronecker indices (nu) given indices basis rows. nu2basis returns indices basis rows given Kronecker indices nu. pseries2nu determines Kronecker indices given impulse response  coefficients. function uses QR decomposition (pivoting) transpose  Hankel matrix determine rank basis row space. See qr.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/Kronecker-Indices.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tools related to Kronecker indices — Kronecker-Indices","text":"function pseries2nu first constructs Hankel matrix impulse response coefficients  \\(f\\) \\(p\\) block rows columns respectively. (nice) basis row space  computed via QR decomposition (pivoting) transposed Hankel matrix. See qr. size Hankel matrix specified (parameter Hsize=c(f,p) missing),   default choice made \\(f+p-1 = l\\), \\(p\\geq 1\\)  \\(f \\geq p+1\\) holds.  function pseries2nu throws error conditions \\(p\\geq 1\\),   \\(f \\geq 2\\) \\(l \\geq f+p-1\\)  satisfied. particular, implies  \\(l \\geq 2\\) must hold.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/Kronecker-Indices.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Tools related to Kronecker indices — Kronecker-Indices","text":"Hannan EJ, Deistler M (2012). Statistical Theory Linear Systems,  Classics Applied Mathematics. SIAM, Philadelphia. Originally published: John Wiley & Sons, New York, 1988.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/Kronecker-Indices.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tools related to Kronecker indices — Kronecker-Indices","text":"","code":"basis = c(1,2,3,4,6,7)     # suppose rows 1,2,3,4,6,7 of the Hankel matrix form a basis nu = basis2nu(basis, m=3)  # compute the corresponding Kronecker index print(nu) #> [1] 3 1 2 all.equal(basis,nu2basis(nu))  # nu2basis(nu) returns the indices of the basis rows (basis) #> [1] TRUE  # generate random rational matrix in statspace form # make sure that the matrix is stable m = 3 n = 2 s = 7 A = matrix(rnorm(s*s), nrow = s, ncol = s) A = A / (1.1 * max(abs(eigen(A, only.values = TRUE)$values))) x = stsp(A, B = matrix(rnorm(s*n), nrow = s, ncol = n),             C = matrix(rnorm(s*m), nrow = m, ncol = s),             D = diag(1, nrow = m, ncol = n)) k = pseries(x, lag.max = 20)  # compute the Kronecker indices of this  rational matrix pseries2nu(k) #> [1] 3 2 2  if (FALSE) { # Suppose the rational matrix has dimension m=2. Then the rows 1,2,5 # do not form a \"nice\" basis for the row space of the Hankel matrix. # Therefore \"basis2nu\" stops with an error message. basis2nu(c(1,2,5), m=2) }"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/Ops.ratm.html","id":null,"dir":"Reference","previous_headings":"","what":"Arithmetic Ops Group Methods for Rational Matrices — Ops.ratm","title":"Arithmetic Ops Group Methods for Rational Matrices — Ops.ratm","text":"Implements following basic arithmetic operations rational matrices unary operators '+' '-'. power ('^k') operator square, non empty rational matrices        integer powers k. elementwise multiplication ('* b') addition substraction ('+ b' '- b') elementwise polynomal division ('%/% b'), elementwise polynomial remainder ('%% b'),","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/Ops.ratm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Arithmetic Ops Group Methods for Rational Matrices — Ops.ratm","text":"","code":"# S3 method for ratm Ops(e1, e2)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/Ops.ratm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Arithmetic Ops Group Methods for Rational Matrices — Ops.ratm","text":"e1, e2 least one e1, e2 must object  class polm, lpolm, lmfd,  rmfd, stsp, pseries  zvalues.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/Ops.ratm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Arithmetic Ops Group Methods for Rational Matrices — Ops.ratm","text":"Rational matrix object.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/Ops.ratm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Arithmetic Ops Group Methods for Rational Matrices — Ops.ratm","text":"unitary operators '+' '-' implemented classes. power ('^k') operator implemented square, rational matrices integer powers k. ^0 returns identity matrix (represented object class input argument ). ^1 simply returns input arguments . case \\(k>1\\) implemented classes.      However, lmfd rmfd objects first coerced stsp objects. case \\(k<0\\) implemented classes, except Laurent polynomials      (lpolm objects).      However, matrix must non empty polm, lmfd rmfd      objects first coerced stsp objects. binary operators `+ b`, `- b` `* b` two arguments  first coerced common class according following scheme Note pseries objects (easily) coerced  zvalues objects, binary operations throw error,  one tries combine pseries zvalues object. two pseries objects combined truncated  minimum respective number “lags”. Two zvalues objects  combined “z” values identical. Otherwise error thrown. course two arguments compatible dimension.  one arguments scalar (\\((1,1)\\) matrix)  argument \"expanded\" compatible matrix identical entries. Note computed statespace realizations often non minimal!  (remark also applies operations statespace realizations.) matrix multiplication, see %r%. elementwise polynomal division ('%/% b')  elementwise polynomial remainder ('%% b') course implemented  polynomial matrices (polm objects) (objects may coerced  polm objects). remark scalar arguments also applies operations.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/Ops.ratm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Arithmetic Ops Group Methods for Rational Matrices — Ops.ratm","text":"","code":"# Multiplication (and division) of a scalar (from left and right) a = test_polm(dim = c(2,2), degree = 3) a #> ( 2 x 2 ) matrix polynomial with degree <= 3  #>      z^0 [,1]  [,2] z^1 [,1]  [,2] z^2 [,1]  [,2] z^3 [,1]  [,2] #> [1,]      110   120      111   121      112   122      113   123 #> [2,]      210   220      211   221      212   222      213   223 -a #> ( 2 x 2 ) matrix polynomial with degree <= 3  #>      z^0 [,1]  [,2] z^1 [,1]  [,2] z^2 [,1]  [,2] z^3 [,1]  [,2] #> [1,]     -110  -120     -111  -121     -112  -122     -113  -123 #> [2,]     -210  -220     -211  -221     -212  -222     -213  -223 a * (-1) #> ( 2 x 2 ) matrix polynomial with degree <= 3  #>      z^0 [,1]  [,2] z^1 [,1]  [,2] z^2 [,1]  [,2] z^3 [,1]  [,2] #> [1,]     -110  -120     -111  -121     -112  -122     -113  -123 #> [2,]     -210  -220     -211  -221     -212  -222     -213  -223 a %/% 0.5 #> ( 2 x 2 ) matrix polynomial with degree <= 3  #>      z^0 [,1]  [,2] z^1 [,1]  [,2] z^2 [,1]  [,2] z^3 [,1]  [,2] #> [1,]      220   240      222   242      224   244      226   246 #> [2,]      420   440      422   442      424   444      426   446  # Addition 2 + a        # 2 is coerced to a constant matrix polynomial #> ( 2 x 2 ) matrix polynomial with degree <= 3  #>      z^0 [,1]  [,2] z^1 [,1]  [,2] z^2 [,1]  [,2] z^3 [,1]  [,2] #> [1,]      112   122      111   121      112   122      113   123 #> [2,]      212   222      211   221      212   222      213   223  # Elementwise remainder a %% 0.5 #> ( 2 x 2 ) matrix polynomial with degree <= -1  0.5 %% a #> ( 2 x 2 ) matrix polynomial with degree <= 0  #>      z^0 [,1]  [,2] #> [1,]      0.5   0.5 #> [2,]      0.5   0.5  # Elementwise division and multiplication with scalar polm z = polm(c(0,1)) a %/% z #> ( 2 x 2 ) matrix polynomial with degree <= 2  #>      z^0 [,1]  [,2] z^1 [,1]  [,2] z^2 [,1]  [,2] #> [1,]      111   121      112   122      113   123 #> [2,]      211   221      212   222      213   223 z * a #> ( 2 x 2 ) matrix polynomial with degree <= 4  #>      z^0 [,1]  [,2] z^1 [,1]  [,2] z^2 [,1]  [,2] z^3 [,1]  [,2] z^4 [,1]  [,2] #> [1,]        0     0      110   120      111   121      112   122      113   123 #> [2,]        0     0      210   220      211   221      212   222      213   223 a * z^2 #> ( 2 x 2 ) matrix polynomial with degree <= 5  #>      z^0 [,1]  [,2] z^1 [,1]  [,2] z^2 [,1]  [,2] z^3 [,1]  [,2] z^4 [,1]  [,2] #> [1,]        0     0        0     0      110   120      111   121      112   122 #> [2,]        0     0        0     0      210   220      211   221      212   222 #>      z^5 [,1]  [,2] #> [1,]      113   123 #> [2,]      213   223  # (Non-negative integer) power of univariate polynomial  # (useful for generating a polynomial matrix) z^3 #> ( 1 x 1 ) matrix polynomial with degree <= 3  #>      z^0 [,1] z^1 [,1] z^2 [,1] z^3 [,1] #> [1,]        0        0        0        1 matrix(0, nrow = 2) + z * matrix(1, nrow = 2) + z^2 * matrix(2, nrow = 2) #> ( 2 x 1 ) matrix polynomial with degree <= 2  #>      z^0 [,1] z^1 [,1] z^2 [,1] #> [1,]        0        1        2 #> [2,]        0        1        2  # (Non-negative integer) power of quadratic polynomial matrices a^0 #> ( 2 x 2 ) matrix polynomial with degree <= 0  #>      z^0 [,1]  [,2] #> [1,]        1     0 #> [2,]        0     1 a^1 #> ( 2 x 2 ) matrix polynomial with degree <= 3  #>      z^0 [,1]  [,2] z^1 [,1]  [,2] z^2 [,1]  [,2] z^3 [,1]  [,2] #> [1,]      110   120      111   121      112   122      113   123 #> [2,]      210   220      211   221      212   222      213   223 a^2 #> ( 2 x 2 ) matrix polynomial with degree <= 6  #>      z^0 [,1]  [,2] z^1 [,1]   [,2] z^2 [,1]   [,2] z^3 [,1]   [,2] z^4 [,1] #> [1,]    37300 39600    75150  79770   113552 120512   152508 161828   115220 #> [2,]    69300 73600   139350 147970   210152 223112   281708 299028   212420 #>        [,2] z^5 [,1]   [,2] z^6 [,1]  [,2] #> [1,] 122240    77374  82074    38968 41328 #> [2,] 225440   142374 151074    71568 75928  # inverse of square polynomial matrix a = test_polm(dim = c(2,2), degree = 1, random = TRUE, digits = 2) a^(-1) #> statespace realization [2,2] with s = 2 states #>           s[1]      s[2]       u[1]     u[2] #> s[1] 24.965970 -4.622687 -10.447761 9.373134 #> s[2]  3.846567 -1.368955  -1.492537 1.910448 #> x[1] 24.965970 -4.622687 -10.447761 9.373134 #> x[2]  3.846567 -1.368955  -1.492537 1.910448 print(pseries(a %r% a^(-1)), digits = 3) #> ( 2 x 2 ) impulse response with maximum lag = 5  #>      lag=0 [,1]  [,2] lag=1 [,1]  [,2] lag=2 [,1]  [,2] lag=3 [,1]  [,2] #> [1,]          1     0          0     0          0     0          0     0 #> [2,]          0     1          0     0          0     0          0     0 #>      lag=4 [,1]  [,2] lag=5 [,1]  [,2] #> [1,]          0     0          0     0 #> [2,]          0     0          0     0  # elementwise multiplication  a = test_polm(dim = c(2,3), degree = 1, random = TRUE, digits = 2) b = test_polm(dim = c(2,3), degree = 1, random = TRUE, digits = 2) b * a #> ( 2 x 3 ) matrix polynomial with degree <= 2  #>      z^0 [,1]    [,2]    [,3] z^1 [,1]    [,2]    [,3] z^2 [,1]    [,2]    [,3] #> [1,]   0.2950  0.1463 -0.0576   0.7573 -1.4638 -0.2208   0.3589  2.8059  0.4284 #> [2,]   0.0468 -0.0780 -1.9800  -0.4350 -0.3382 -1.5030   0.5358 -0.3384 -0.0702 all.equal(zvalues(a * b), zvalues(a) * zvalues(b)) #> [1] TRUE"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/array2data.frame.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce arrays to data frames — array2data.frame","title":"Coerce arrays to data frames — array2data.frame","text":"helper function creates data.frame given array.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/array2data.frame.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce arrays to data frames — array2data.frame","text":"","code":"array2data.frame(x, rows = NULL, cols = NULL)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/array2data.frame.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce arrays to data frames — array2data.frame","text":"x Matrix array. rows, cols integer vectors. two vectors define partition \"dimensions\" (1,...,n), n number dimensions x (.e. length(dim(x))). either two missing, complement used. least one arguments \"rows\" \"cols\" given.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/array2data.frame.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce arrays to data frames — array2data.frame","text":"data.frame","code":""},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/reference/array2data.frame.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce arrays to data frames — array2data.frame","text":"","code":"# test array x = test_array(dim = c(2,3,2), dimnames = TRUE) array2data.frame(x, cols = c(1,3,2)) #>   A=1.C=1.B=1 A=2.C=1.B=1 A=1.C=2.B=1 A=2.C=2.B=1 A=1.C=1.B=2 A=2.C=1.B=2 #> 1         111         211         112         212         121         221 #>   A=1.C=2.B=2 A=2.C=2.B=2 A=1.C=1.B=3 A=2.C=1.B=3 A=1.C=2.B=3 A=2.C=2.B=3 #> 1         122         222         131         231         132         232 array2data.frame(x, rows = 1) #>     A B=1.C=1 B=2.C=1 B=3.C=1 B=1.C=2 B=2.C=2 B=3.C=2 #> 1 A=1     111     121     131     112     122     132 #> 2 A=2     211     221     231     212     222     232 array2data.frame(x, rows = 2:1) #>     B   A C=1 C=2 #> 1 B=1 A=1 111 112 #> 2 B=2 A=1 121 122 #> 3 B=3 A=1 131 132 #> 4 B=1 A=2 211 212 #> 5 B=2 A=2 221 222 #> 6 B=3 A=2 231 232 array2data.frame(x, rows = c(2,1,3)) #>      B   A   C value #> 1  B=1 A=1 C=1   111 #> 2  B=2 A=1 C=1   121 #> 3  B=3 A=1 C=1   131 #> 4  B=1 A=2 C=1   211 #> 5  B=2 A=2 C=1   221 #> 6  B=3 A=2 C=1   231 #> 7  B=1 A=1 C=2   112 #> 8  B=2 A=1 C=2   122 #> 9  B=3 A=1 C=2   132 #> 10 B=1 A=2 C=2   212 #> 11 B=2 A=2 C=2   222 #> 12 B=3 A=2 C=2   232  # consider a pseudo socio economic data set x = test_array(dim = c(2,4,5), random = TRUE) dimnames(x) = list(sex=c('female','male'),                    education = c('none','primary','high','university'),                    age = c('<20','30-40','40-50','50-60','>60')) array2data.frame(x, cols = 1) #>     education   age      female       male #> 1        none   <20  0.29428262  0.1495922 #> 2     primary   <20  1.75193125  0.5010902 #> 3        high   <20 -0.05701830 -0.4776046 #> 4  university   <20 -0.18282365 -0.1097048 #> 5        none 30-40  0.94032587  0.1151560 #> 6     primary 30-40  0.34723615  0.0800871 #> 7        high 30-40 -1.15203196  0.8677256 #> 8  university 30-40 -1.05184478 -0.6718172 #> 9        none 40-50 -0.19266489  0.8826651 #> 10    primary 40-50  0.75275053  1.0371300 #> 11       high 40-50  0.05087321 -0.6823964 #> 12 university 40-50  0.77645610 -2.4229910 #> 13       none 50-60  2.51335467  1.7956230 #> 14    primary 50-60 -0.15389086 -0.3472571 #> 15       high 50-60  0.26050437 -1.1675108 #> 16 university 50-60 -1.04812214 -0.6097700 #> 17       none   >60 -0.70621093  0.3645390 #> 18    primary   >60 -0.12712999 -0.2470875 #> 19       high   >60  0.32171650  0.5161089 #> 20 university   >60  0.93547189  0.4893814 array2data.frame(x, cols = c(1,2)) #>     age female.none male.none female.primary male.primary female.high #> 1   <20   0.2942826 0.1495922      1.7519313    0.5010902 -0.05701830 #> 2 30-40   0.9403259 0.1151560      0.3472361    0.0800871 -1.15203196 #> 3 40-50  -0.1926649 0.8826651      0.7527505    1.0371300  0.05087321 #> 4 50-60   2.5133547 1.7956230     -0.1538909   -0.3472571  0.26050437 #> 5   >60  -0.7062109 0.3645390     -0.1271300   -0.2470875  0.32171650 #>    male.high female.university male.university #> 1 -0.4776046        -0.1828237      -0.1097048 #> 2  0.8677256        -1.0518448      -0.6718172 #> 3 -0.6823964         0.7764561      -2.4229910 #> 4 -1.1675108        -1.0481221      -0.6097700 #> 5  0.5161089         0.9354719       0.4893814  # convert an impulse response function into a data.frame # generate a random statespace model with m=3 outputs, n=2 inputs and s=4 states. model = stsp(A = matrix(stats::rnorm(16), nrow = 4, ncol = 4),               B = matrix(stats::rnorm(8),  nrow = 4, ncol = 2),              C = matrix(stats::rnorm(12), nrow = 3, ncol = 4),               D = matrix(stats::rnorm(6), nrow = 3, ncol = 2)) k = unclass(pseries(model, lag.max = 25)) dimnames(k) = list(y = paste('y[',1:3,']',sep=''),                     x = paste('x[',1:2,']',sep=''),                    lag = 0:25) head(array2data.frame(k, rows = c(1,3), cols=2)) #>      y lag       x[1]       x[2] #> 1 y[1]   0  1.2353808  2.1302053 #> 2 y[2]   0 -0.9622066 -1.5101288 #> 3 y[3]   0  1.6773689 -0.8899489 #> 4 y[1]   1 -3.5244864  0.1903175 #> 5 y[2]   1 -0.4019647  0.3947148 #> 6 y[3]   1  1.5226602 -0.7445722"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as.lmfd.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to Left Matrix Fraction Description — as.lmfd","title":"Coerce to Left Matrix Fraction Description — as.lmfd","text":"function .lmfd.pseries calls pseries2lmfd default parameters. course pseries object must contain sufficiently many lags.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as.lmfd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to Left Matrix Fraction Description — as.lmfd","text":"","code":"as.lmfd(obj, method, ...)  # S3 method for pseries as.lmfd(obj, method, ...)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as.lmfd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to Left Matrix Fraction Description — as.lmfd","text":"obj object method character string ... optional additional arguments","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as.lmfd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to Left Matrix Fraction Description — as.lmfd","text":"object class lmfd","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as.lpolm.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to Laurent polynom object — as.lpolm","title":"Coerce to Laurent polynom object — as.lpolm","text":"attribute min_deg set zero given function input.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as.lpolm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to Laurent polynom object — as.lpolm","text":"","code":"as.lpolm(obj, ...)  # S3 method for polm as.lpolm(obj, ...)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as.lpolm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to Laurent polynom object — as.lpolm","text":"obj polm object ... arguments","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as.lpolm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to Laurent polynom object — as.lpolm","text":"lpolm object","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as.lpolm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce to Laurent polynom object — as.lpolm","text":"","code":"p = test_polm(degree = 2) as.lpolm(p) #> ( 1 x 1 ) Laurent polynomial matrix with degree <= 2, and minimal degree >= 0 #>      z^0 [,1] z^1 [,1] z^2 [,1] #> [1,]      110      111      112"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as.polm.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerece to polynomial object — as.polm","title":"Coerece to polynomial object — as.polm","text":"Coerece polynomial object","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as.polm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerece to polynomial object — as.polm","text":"","code":"as.polm(obj, ...)  # S3 method for lpolm as.polm(obj, ...)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as.polm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerece to polynomial object — as.polm","text":"obj lpolm object ... arguments","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as.polm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerece to polynomial object — as.polm","text":"polm object","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as.polm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerece to polynomial object — as.polm","text":"","code":"lp = lpolm(1:3, min_deg = 1)  as.polm(lp) #> ( 1 x 1 ) matrix polynomial with degree <= 3  #>      z^0 [,1] z^1 [,1] z^2 [,1] z^3 [,1] #> [1,]        0        1        2        3"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as.rmfd.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to Right Matrix Fraction Description — as.rmfd","title":"Coerce to Right Matrix Fraction Description — as.rmfd","text":"function .rmfd.pseries calls pseries2rmfd default parameters. course pseries object must contain sufficiently many lags.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as.rmfd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to Right Matrix Fraction Description — as.rmfd","text":"","code":"as.rmfd(obj, method, ...)  # S3 method for pseries as.rmfd(obj, method, ...)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as.rmfd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to Right Matrix Fraction Description — as.rmfd","text":"obj object method character string ... optional additional arguments","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as.rmfd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to Right Matrix Fraction Description — as.rmfd","text":"object class rmfd","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as.stsp.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to Statespace Realization — as.stsp","title":"Coerce to Statespace Realization — as.stsp","text":"function .stsp.pseries calls pseries2stsp default parameters. course pseries object must contain sufficiently many lags.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as.stsp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to Statespace Realization — as.stsp","text":"","code":"as.stsp(obj, ...)  # S3 method for lpolm as.stsp(obj, ...)  # S3 method for polm as.stsp(obj, ...)  # S3 method for lmfd as.stsp(obj, ...)  # S3 method for rmfd as.stsp(obj, ...)  # S3 method for pseries as.stsp(obj, method = c(\"balanced\", \"echelon\"), ...)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as.stsp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to Statespace Realization — as.stsp","text":"obj object ... optional additional parameters method character string","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as.stsp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to Statespace Realization — as.stsp","text":"object class stsp.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as.stsp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce to Statespace Realization — as.stsp","text":"","code":"(rr = test_rmfd(dim = c(3,2), degrees = c(2,1))) #> ( 3 x 2 ) right matrix fraction description d(z) c^(-1)(z) with degrees deg(c(z)) = p = 2, deg(d(z)) = q = 1 #> left factor d(z): #>        z^0 [,1]       [,2]    z^1 [,1]        [,2] #> [1,] -0.7112850 -0.5344179 -0.09141650  0.80152319 #> [2,] -0.7465091 -2.0518592 -0.05685715 -0.63589298 #> [3,]  2.2203530 -0.4300648  0.04017560  0.04859415 #> right factor c(z): #>      z^0 [,1]  [,2]   z^1 [,1]      [,2]  z^2 [,1]      [,2] #> [1,]        1     0 -1.5654000 0.2725982 0.9980043  1.438483 #> [2,]        0     1 -0.4423597 0.6272987 1.0283705 -1.053177 as.stsp(rr) #> statespace realization [3,2] with s = 4 states #>            s[1]       s[2]       s[3]       s[4]       u[1]       u[2] #> s[1]  1.5654000 -0.2725982 -0.9980043 -1.4384829  1.0000000  0.0000000 #> s[2]  0.4423597 -0.6272987 -1.0283705  1.0531768  0.0000000  1.0000000 #> s[3]  1.0000000  0.0000000  0.0000000  0.0000000  0.0000000  0.0000000 #> s[4]  0.0000000  1.0000000  0.0000000  0.0000000  0.0000000  0.0000000 #> x[1] -1.4412670  1.3306579  1.2594451  0.4603348 -0.7112850 -0.5344179 #> x[2] -2.1331024  0.8547327  2.8550908 -1.0871298 -0.7465091 -2.0518592 #> x[3]  3.3256727 -0.2868911 -1.7736558 -3.6468741  2.2203530 -0.4300648"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as_tex_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"TeX Matrix — as_tex_matrix","title":"TeX Matrix — as_tex_matrix","text":"TeX Matrix","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as_tex_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"TeX Matrix — as_tex_matrix","text":"","code":"as_tex_matrix(x)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as_tex_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"TeX Matrix — as_tex_matrix","text":"x matrix, paste(x[,j]) returns valid \"TeX\" string.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as_tex_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"TeX Matrix — as_tex_matrix","text":"character string.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as_tex_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"TeX Matrix — as_tex_matrix","text":"","code":"as_tex_matrix(diag(1:2, nrow = 2, ncol = 3)) #> [1] \"\\\\begin{pmatrix}\\n  1 & 0 & 0  \\\\\\\\\\n  0 & 2 & 0  \\\\\\\\\\n\\\\end{pmatrix}\""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as_tex_matrixfilter.html","id":null,"dir":"Reference","previous_headings":"","what":"TeX Matrix Polynomial Filters — as_tex_matrixfilter","title":"TeX Matrix Polynomial Filters — as_tex_matrixfilter","text":"TeX Matrix Polynomial Filters","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as_tex_matrixfilter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"TeX Matrix Polynomial Filters — as_tex_matrixfilter","text":"","code":"as_tex_matrixfilter(coefs, x = \"z\", t = \"t\")"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as_tex_matrixfilter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"TeX Matrix Polynomial Filters — as_tex_matrixfilter","text":"coefs 3-dimensional array coefficients filter. x (character string) polynomial variable process variable. t (character string) time/index variable.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as_tex_matrixfilter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"TeX Matrix Polynomial Filters — as_tex_matrixfilter","text":"character string.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as_tex_matrixfilter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"TeX Matrix Polynomial Filters — as_tex_matrixfilter","text":"","code":"coefs = array(round(rnorm(2*3*1), 1), dim = c(2,3,2))  as_tex_matrixfilter(coefs, x = '\\\\epsilon', t = 's') #> [1] \" \\\\begin{pmatrix}\\n  0.5 & -0.1 & -2  \\\\\\\\\\n  -0.7 & -1 & -0.6  \\\\\\\\\\n\\\\end{pmatrix} \\\\epsilon_{s} +\\n \\\\begin{pmatrix}\\n  0.5 & -0.1 & -2  \\\\\\\\\\n  -0.7 & -1 & -0.6  \\\\\\\\\\n\\\\end{pmatrix} \\\\epsilon_{s-1}\""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as_tex_matrixpoly.html","id":null,"dir":"Reference","previous_headings":"","what":"TeX Matrix Polynomials — as_tex_matrixpoly","title":"TeX Matrix Polynomials — as_tex_matrixpoly","text":"TeX Matrix Polynomials","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as_tex_matrixpoly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"TeX Matrix Polynomials — as_tex_matrixpoly","text":"","code":"as_tex_matrixpoly(coefs, x = \"z\", as_matrix_of_polynomials = TRUE)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as_tex_matrixpoly.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"TeX Matrix Polynomials — as_tex_matrixpoly","text":"coefs 3-dimensional array coefficients matrix polynomial. x (character string) polynomial variable process variable. as_matrix_of_polynomials boolean.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as_tex_matrixpoly.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"TeX Matrix Polynomials — as_tex_matrixpoly","text":"character string.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as_tex_matrixpoly.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"TeX Matrix Polynomials — as_tex_matrixpoly","text":"","code":"coefs = array(round(rnorm(2*3*1), 1), dim = c(2,3,2))  as_tex_matrixpoly(coefs) #> [1] \"\\\\begin{pmatrix}\\n  -1.2 - 1.2z & 0.9 + 0.9z & -0.1 - 0.1z  \\\\\\\\\\n  1.1 + 1.1z & -0.4 - 0.4z & 0.8 + 0.8z  \\\\\\\\\\n\\\\end{pmatrix}\" as_tex_matrixpoly(coefs, x = 'x', as_matrix_of_polynomials = FALSE) #> [1] \" \\\\begin{pmatrix}\\n  -1.2 & 0.9 & -0.1  \\\\\\\\\\n  1.1 & -0.4 & 0.8  \\\\\\\\\\n\\\\end{pmatrix}  +\\n \\\\begin{pmatrix}\\n  -1.2 & 0.9 & -0.1  \\\\\\\\\\n  1.1 & -0.4 & 0.8  \\\\\\\\\\n\\\\end{pmatrix} x\""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as_txt_scalarfilter.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce Scalar Polynomial Filters to Character Strings — as_txt_scalarfilter","title":"Coerce Scalar Polynomial Filters to Character Strings — as_txt_scalarfilter","text":"utility coerces scalar polynomial filter (given vector coefficients) character string. following \"formats\" implemented. syntax = \"txt\" returns simple text representation, syntax = \"TeX\" renders coefficients string \"TeX\" syntax syntax = \"expression\" gives string may rendered R expression parse. expression may used evaluate filter annotating plots, see plotmath examples .","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as_txt_scalarfilter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce Scalar Polynomial Filters to Character Strings — as_txt_scalarfilter","text":"","code":"as_txt_scalarfilter(   coefs,   syntax = c(\"txt\", \"TeX\", \"expression\"),   x = \"z\",   t = \"t\" )"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as_txt_scalarfilter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce Scalar Polynomial Filters to Character Strings — as_txt_scalarfilter","text":"coefs (numeric) vector coefficients. syntax (character string) determines format output string. x (character string) names \"input\" series. t (character string) names \"time-index\".","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as_txt_scalarfilter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce Scalar Polynomial Filters to Character Strings — as_txt_scalarfilter","text":"character string.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as_txt_scalarfilter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce Scalar Polynomial Filters to Character Strings — as_txt_scalarfilter","text":"","code":"coefs = c(1, 2.3, 0, -1, 0)  as_txt_scalarfilter(coefs, syntax = 'txt', x = 'x', t = 't') #> [1] \"x[t] + 2.3x[t-1] - x[t-3]\" as_txt_scalarfilter(coefs, syntax = 'TeX', x = 'x', t = 's') #> [1] \"x_{s} + 2.3x_{s-1} - x_{s-3}\" as_txt_scalarfilter(coefs, syntax = 'expression', x = 'x', t = 'k') #> [1] \"x[k] + 2.3*x[k-1] - x[k-3]\"  if (FALSE) { # the case syntax = \"expression\" may be used e.g. as follows  # make_filterfun creates a \"closure\" which computes the filter-output # note that this simple version does not work for zero filters! make_filterfun = function(coefs) {   p = length(coefs) - 1   expr = parse(text = as_txt_scalarfilter(coefs, 'expression', 'x', 't'))   fun = function(x, t) {     # x, t must be vectors     y = rep(NA_real_, length(t))     t0 = t     y = rep(NA_real_, length(t))      i = ((t0 > p) & (t0 <= length(x)))     t = t0[i]     if (any(i)) y[i] = eval(expr)      return(y)   }   return(fun) }  coefs = rep(1, 4) / 4  # represents a moving average of length 4. a = make_filterfun(coefs) u = rnorm(100)       # input series a(u, 1)    # return the value of the output series at t = 1            # this value is not defined due to missing initial values a(u, 1:10) # return the values of the output series at t = 1,..,10  # create a plot plot(1:length(u), u, type = 'n', xlab = 'time', ylab = '') grid() lines(1:length(u), u, col = 'black', lwd = 1) lines(1:length(u), a(u, 1:length(u)), col = 'red', lwd = 2) legend('topright', bty = 'n',        fill = c('black', 'red'),        legend = c(expression(u[t]),                   parse(text = paste('x[t] == ',                      as_txt_scalarfilter(coefs, 'expression', 'u','t')))) ) }"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as_txt_scalarpoly.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce Scalar Polynomials to Character Strings — as_txt_scalarpoly","title":"Coerce Scalar Polynomials to Character Strings — as_txt_scalarpoly","text":"utility coerces scalar polynomial (given vector real coefficients) scalar Laurent polynomial character string.  vector interpreted Laurent polynomial, minimal degree given argument laurent described . following \"formats\" implemented. syntax = \"txt\" returns simple text representation, syntax = \"TeX\" renders coefficients string \"TeX\" syntax syntax = \"expression\" gives string may rendered         R expression parse. expression         may used evaluate polynomial annotating plots,         see plotmath examples .","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as_txt_scalarpoly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce Scalar Polynomials to Character Strings — as_txt_scalarpoly","text":"","code":"as_txt_scalarpoly(   coefs,   syntax = c(\"txt\", \"TeX\", \"expression\"),   x = \"z\",   laurent = FALSE )"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as_txt_scalarpoly.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce Scalar Polynomials to Character Strings — as_txt_scalarpoly","text":"coefs Vector doubles (complex elements allowed) representing univariate polynomial (first element corresponds power zero). represents Laurent polynomial, first element corresponds minimal degree. syntax (character string) determines format output string. x (character string) polynomial variable. laurent Boolean integer. Default set FALSE. one deals Laurent polynomials, integer corresponding minimal degree Laurent polynomial supplied.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as_txt_scalarpoly.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce Scalar Polynomials to Character Strings — as_txt_scalarpoly","text":"Character string used printing univariate (Laurent) polynomials.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/as_txt_scalarpoly.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce Scalar Polynomials to Character Strings — as_txt_scalarpoly","text":"","code":"coefs = c(1, 2.3, 0, -1, 0)  as_txt_scalarpoly(coefs, syntax = 'txt', x = 'x') #> [1] \"1 + 2.3x - x^3\" as_txt_scalarpoly(coefs, syntax = 'TeX', x = '\\\\alpha') #> [1] \"1 + 2.3\\\\alpha - \\\\alpha^{3}\" as_txt_scalarpoly(coefs, syntax = 'expression', x = 'z') #> [1] \"1 + 2.3*z - z^{3}\" as_txt_scalarpoly(coefs = sample((-10):10, 7, replace = TRUE),                    syntax = 'txt', x = 'x',                    laurent = -3) #> [1] \"6x^-3 - 9x^-2 + 3 - 5x - x^2 + 9x^3\"  if (FALSE) { # the case syntax = \"expression\" may be used e.g. as follows  # make_polyfun creates a \"closure\" which evaluates the polynomial at given points # note that this simple version does not work for zero polynomials! make_polyfun = function(coefs) {   expr = parse(text = as_txt_scalarpoly(coefs, 'expression', 'x'))   fun = function(x) {     return(eval(expr))   }   return(fun) }  a = make_polyfun(coefs) a(1)   # return the value  of the polynomial at x = 1 a(1:5) # return the values of the polynomial at x = 1,2,3,4,5  # create a plot x_grid = seq(from = -1, to = 1, length.out = 101) plot(x_grid, a(x_grid), type = 'l', xlab = 'x', ylab = 'a(x)',      main = parse(text = paste('a(x) == ',           as_txt_scalarpoly(coefs, syntax = 'expression', x = 'x')))) }"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/balance.html","id":null,"dir":"Reference","previous_headings":"","what":"Balanced Realization and Balanced Truncation — balance","title":"Balanced Realization and Balanced Truncation — balance","text":"Compute balanced realization balanced truncated statespace realization rational matrix statespace form.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/balance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Balanced Realization and Balanced Truncation — balance","text":"","code":"balance(   obj,   gr,   tol = 10 * sqrt(.Machine$double.eps),   s0 = NULL,   truncate = TRUE )"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/balance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Balanced Realization and Balanced Truncation — balance","text":"obj (stsp object) rational matrix statespace form. gr list two components P Q contain two Grammians.  Grammians may e.g. computed grammians. tol tolerance parameter used determination rank \\(PQ\\).  s0 = NULL procedure estimates rank \\(PQ\\)  sets s0 equal estimate. s0 given,  tol ignored. s0 determines  size two diagonal blocks transformed  Grammians \\(P\\), \\(Q\\), respectively (truncate = TRUE  statespace dimension balanced truncated statespace realization. truncate (boolean) true balanced truncated model returned.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/balance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Balanced Realization and Balanced Truncation — balance","text":"list components obj (stsp object) represents balanced (truncated) statespace             realization. T,Tinv state transformation inverse state transformation matrix.                Note case truncate=TRUE matrix T                s0 x s matrix Tinv dimension s x s0. P,Q transformed (truncated) Grammians. sigma vector singular values matrix \\((P^{1/2}Q^{1/2})\\).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/balance.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Balanced Realization and Balanced Truncation — balance","text":"Let \\(P,Q\\) denote controllability observability Grammian statespace  realization  $$K(z) = C(Iz^{-1} - )^{-1}B +D$$  rational matrix \\(K(z)\\) statespace dimension \\(s\\).  matrix \\(PQ\\) diagonalizable eigenvalues real non negative.  Let \\(\\sigma_1^2 \\geq \\cdots \\geq \\sigma_s^2 \\geq 0\\) denote eigenvalues \\(PQ\\) suppose \\(PQ\\) rank \\(k\\leq s\\),  .e. \\(\\sigma_i=0\\) \\(>k\\).  exists statespace transformation \\(T\\) renders Grammians diagonal form  furthermore \\(p_{ii}=q_{ii}=\\sigma_i\\)  first \\(k\\) diagonal entries (transformed) Grammians. (non zero) \\(\\sigma_i\\)'s equal (non zero) singular values  Hankel matrix impulse response coefficients \\(K\\) hence called  Hankel singular values. singular values also singular values  product \\(P^{1/2}Q^{1/2}\\) \\(P^{1/2}\\) \\(Q^{1/2}\\) denote \"square roots\"  Grammians \\(P\\) \\(Q\\) respectively. procedure balance(obj,...) computes somewhat simplified \"balanced\" form  transformed Grammians \\(P,Q\\) block diagonal two diagonal blocks dimension  \\(s_0\\) \\(s_1 = s - s_0\\) respectively. two  upper, left blocks \\(P\\) \\(Q\\) diagonal diagonal entries   \\(p_{ii}=q_{ii}=\\sigma_i\\)  \\(=1,\\ldots,s_0\\). \\(s_0=k\\) equal rank \\(PQ\\)  product two lower, right blocks \\(P\\) \\(Q\\) zero  (numerical errors). Note \\(k=\\mathrm{rk}(PQ)\\) equal minimal statespace dimension, .e.  exists statespace realization statespace dimension \\(k\\)  statespace realization \\(K\\) statespace dimension \\(geq k\\).  minimal statespace realization now constructed \"truncating\" balanced  realization:   $$K(z) = C_{1}(Iz^{-1} - A_{11})^{-1} B_{1} + D$$ \\(A_{11}\\) left, upper, \\((k,k)\\) dimensional block \\(\\),  \\(B_1\\) upper, \\((k,n)\\) dimensional block \\(B\\)  \\(C_1\\) left, \\((m,k)\\) dimensional block \\(C\\). balanced truncated statespace realization returned  optional parameter truncate TRUE. Note case  s0 less rank \\(PQ\\) truncated realization  just approximate realization \\(K(z)\\). approximation error  depends size \"neglected\" Hankel singular values. Note also  truncated realization balanced (\\(s_0<k\\)). \"target\" statespace dimension \\(s_0\\) given  procedure sets \\(s_0\\) equal estimate rank  \\(PQ\\). estimate computed inspecting singular values  \\(\\sigma_i\\) product square roots  \\(P^{1/2}\\) \\(Q^{1/2}\\). discussion deals controllability observability  Grammian statespace realization. However, one may also use  pairs Grammians, e.g. invertible matrices \\(K\\)  one may use controllabaility Grammian statespace realizatton  observability Grammian statespace realization  inverse K^{-1}(z).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/balance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Balanced Realization and Balanced Truncation — balance","text":"","code":"# example A ############################################################  # \"obj\" is a (1 by 1) rational matrix in statespace form,  # with stespace dimension s = 2.   obj = stsp(A = c(0,0.2,1,-0.5),            B = c(1,1), C = c(1,0)) gr = grammians(obj, 'lyapunov') bal = balance(obj, gr)  print(cbind(bal$P, bal$Q, diag(bal$sigma, nrow = 2, ncol = 2))) #>          [,1]     [,2]     [,3]     [,4]     [,5]     [,6] #> [1,] 1.586904 0.000000 1.586904 0.000000 1.586904 0.000000 #> [2,] 0.000000 1.458699 0.000000 1.458699 0.000000 1.458699 all.equal(grammians(bal$obj), bal[c('P','Q')]) #> [1] TRUE  # example B (non minimal statespace realization #########################  # The \"rbind\" operation below returns a statespace realization with  # statespace dimension s = 4. However the minimal statespace dimensions  # is s0 = 2.  obj = rbind(obj, obj) gr = grammians(obj, 'lyapunov') bal = balance(obj, gr, s0 = 2, truncate = FALSE)  # the upper (2 by 2) block of the (transformed) controllability  # Grammian is diagonal, the lower (2 by 2) block is \"zero\".  # This shows that the (balanced) realization is not controllable.  print(bal$P)   #>          [,1]     [,2]          [,3]          [,4] #> [1,] 2.244221 0.000000  0.000000e+00  0.000000e+00 #> [2,] 0.000000 2.062912  0.000000e+00  0.000000e+00 #> [3,] 0.000000 0.000000  2.272963e-32 -2.403037e-32 #> [4,] 0.000000 0.000000 -1.786739e-32  1.198986e-31                # the upper (2 by 2) block of the (transformed) observability  # Grammian is diagonal and equal to the upper block of bal$P. print(bal$Q)  #>          [,1]     [,2]       [,3]       [,4] #> [1,] 2.244221 0.000000 0.00000000 0.00000000 #> [2,] 0.000000 2.062912 0.00000000 0.00000000 #> [3,] 0.000000 0.000000 1.77315334 0.02695174 #> [4,] 0.000000 0.000000 0.02695174 1.00462444  # the product of the (transformed) controllability and observability  # Grammians is (approximately) diagonal and the diagonal entries are   # the squares of the Hankel singular values. print(bal$P %*% bal$Q) #>          [,1]     [,2]          [,3]          [,4] #> [1,] 5.036528 0.000000  0.000000e+00  0.000000e+00 #> [2,] 0.000000 4.255604  0.000000e+00  0.000000e+00 #> [3,] 0.000000 0.000000  3.965545e-32 -2.352889e-32 #> [4,] 0.000000 0.000000 -2.845015e-32  1.199715e-31 print(bal$sigma^2)     #> [1] 5.036528e+00 4.255604e+00 2.792357e-17 6.353796e-32  all.equal(grammians(bal$obj), bal[c('P','Q')]) #> [1] TRUE  # we may construct a minimal realization by 'balanced truncation'. # note that we let the procedure determine the minimal statespace dimension  trunc = balance(obj, gr)   print(trunc$obj) #> statespace realization [2,1] with s = 2 states #>            s[1]       s[2]       u[1] #> s[1]  0.3498560  0.3119731 -1.3299446 #> s[2] -0.3119731 -0.8498560 -0.5954318 #> x[1] -0.9404128  0.4210339  1.0000000 #> x[2] -0.9404128  0.4210339  1.0000000 # compare with the above balanced realization  print(bal$obj) #> statespace realization [2,1] with s = 4 states #>               s[1]          s[2]          s[3]          s[4]          u[1] #> s[1]  3.498560e-01  3.119731e-01 -1.747240e-16  1.694153e-17 -1.329945e+00 #> s[2] -3.119731e-01 -8.498560e-01 -9.478857e-17 -1.914317e-16 -5.954318e-01 #> s[3]  3.687444e-17  1.314776e-17 -8.147341e-01 -7.816872e-02  5.551115e-17 #> s[4] -6.500433e-17 -1.117170e-16  7.218313e-01  3.147341e-01  2.220446e-16 #> x[1] -9.404128e-01  4.210339e-01  2.284728e-01 -6.691787e-01  1.000000e+00 #> x[2] -9.404128e-01  4.210339e-01 -2.284728e-01  6.691787e-01  1.000000e+00 # check  all.equal(pseries(obj), pseries(trunc$obj)) #> [1] TRUE  # example C (balanced truncation) ##########################  # construct a random rational matrix with statespace dimension s=10 obj = test_stsp(dim = c(2,2), s = 10, bpoles = 1, bzeroes = 1) # compute an approximate realization with s0 = 8 gr = grammians(obj, 'minimum phase') trunc = balance(obj, gr, s0 = 5) print(trunc$sigma) #>  [1] 2.209162586 1.318023393 0.699404621 0.417914114 0.304352222 0.104232208 #>  [7] 0.040550915 0.029675682 0.004633122 0.001629029  max(abs(unclass(pseries(obj, lag.max = 25)) -          unclass(pseries(trunc$ob, lag.max = 25)))) #> [1] 0.06920354 plot(pseries(obj, lag.max = 25), x_list= list(pseries(trunc$obj, lag.max = 25)),       type = c('l','p'), legend = c('s=10', 's=5'))"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/bdiag.html","id":null,"dir":"Reference","previous_headings":"","what":"Block Diagonal Matrix — bdiag","title":"Block Diagonal Matrix — bdiag","text":"Combine two matrices block-diagonal matrix. functions supports boolean, integer, numeric complex matrices (vectors). procedure makes effort retain (col- / row-) names inputs.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/bdiag.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Block Diagonal Matrix — bdiag","text":"","code":"bdiag(...)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/bdiag.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Block Diagonal Matrix — bdiag","text":"... matrices vectors. Vectors treated diagonal matrices. input arguments provided bdiag returns NULL.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/bdiag.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Block Diagonal Matrix — bdiag","text":"block diagonal matrix (NULL bdiag called without inputs).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/bdiag.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Block Diagonal Matrix — bdiag","text":"","code":"A = matrix(TRUE, nrow = 2, ncol = 3) colnames(A) = paste('A',1:3,sep ='.') B = rep(2L,3) names(B) = paste('B',1:3,sep = '.') C = matrix(0, nrow = 3, ncol = 0) rownames(C) = paste('C',1:3) D = matrix(4, nrow = 2, ncol = 3) E = matrix(complex(real=5), nrow = 2, ncol = 2) rownames(E) = paste('E',1:2,sep='.') colnames(E) = paste('E',1:2,sep='.')  bdiag() #> NULL bdiag(NULL,NULL) #> NULL  X = bdiag(A,NULL) # NULL arguments are skipped X #>       A.1  A.2  A.3 #> [1,] TRUE TRUE TRUE #> [2,] TRUE TRUE TRUE str(X)            # output is of type 'logi' #>  logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE #>  - attr(*, \"dimnames\")=List of 2 #>   ..$ : NULL #>   ..$ : chr [1:3] \"A.1\" \"A.2\" \"A.3\"  X = bdiag(A,NULL,B) X #>     A.1 A.2 A.3 B.1 B.2 B.3 #>       1   1   1   0   0   0 #>       1   1   1   0   0   0 #> B.1   0   0   0   2   0   0 #> B.2   0   0   0   0   2   0 #> B.3   0   0   0   0   0   2 str(X)            # output is of type 'int' #>  int [1:5, 1:6] 1 1 0 0 0 1 1 0 0 0 ... #>  - attr(*, \"dimnames\")=List of 2 #>   ..$ : chr [1:5] \"\" \"\" \"B.1\" \"B.2\" ... #>   ..$ : chr [1:6] \"A.1\" \"A.2\" \"A.3\" \"B.1\" ...  # note the action of the \"empty\" (3 times 0) matrix C X = bdiag(A,C,B) X #>     A.1 A.2 A.3 B.1 B.2 B.3 #>       1   1   1   0   0   0 #>       1   1   1   0   0   0 #> C 1   0   0   0   0   0   0 #> C 2   0   0   0   0   0   0 #> C 3   0   0   0   0   0   0 #> B.1   0   0   0   2   0   0 #> B.2   0   0   0   0   2   0 #> B.3   0   0   0   0   0   2 str(X)            # output is of type 'num' #>  num [1:8, 1:6] 1 1 0 0 0 0 0 0 1 1 ... #>  - attr(*, \"dimnames\")=List of 2 #>   ..$ : chr [1:8] \"\" \"\" \"C 1\" \"C 2\" ... #>   ..$ : chr [1:6] \"A.1\" \"A.2\" \"A.3\" \"B.1\" ...  X = bdiag(A,B,C,D,E) X #>      A.1  A.2  A.3  B.1  B.2  B.3                 E.1  E.2 #>     1+0i 1+0i 1+0i 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i #>     1+0i 1+0i 1+0i 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i #> B.1 0+0i 0+0i 0+0i 2+0i 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i #> B.2 0+0i 0+0i 0+0i 0+0i 2+0i 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i #> B.3 0+0i 0+0i 0+0i 0+0i 0+0i 2+0i 0+0i 0+0i 0+0i 0+0i 0+0i #> C 1 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i #> C 2 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i #> C 3 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i #>     0+0i 0+0i 0+0i 0+0i 0+0i 0+0i 4+0i 4+0i 4+0i 0+0i 0+0i #>     0+0i 0+0i 0+0i 0+0i 0+0i 0+0i 4+0i 4+0i 4+0i 0+0i 0+0i #> E.1 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i 5+0i 5+0i #> E.2 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i 0+0i 5+0i 5+0i str(X)            # output is of type 'cplx' #>  cplx [1:12, 1:11] 1+0i 1+0i 0+0i ... #>  - attr(*, \"dimnames\")=List of 2 #>   ..$ : chr [1:12] \"\" \"\" \"B.1\" \"B.2\" ... #>   ..$ : chr [1:11] \"A.1\" \"A.2\" \"A.3\" \"B.1\" ...  if (FALSE) { # the inputs must be vectors or matrices. arrays are not supported. bdiag(A, array(1, dim = c(2,3,1)))  # character matrices are problematic, since it is not clear how to set the # non diagonal elements. Therefore, the following statement throws an error. bdiag(A, matrix('B', nrow = 2, ncol = 1), 3:4) }"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/bhankel.html","id":null,"dir":"Reference","previous_headings":"","what":"Block Hankel matrix — bhankel","title":"Block Hankel matrix — bhankel","text":"Construct block Hankel matrix (block) entries 3-dimensional array R. \\((,j)\\)-th block Hankel matrix R[,,+j-1].","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/bhankel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Block Hankel matrix — bhankel","text":"","code":"bhankel(R, d = NULL)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/bhankel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Block Hankel matrix — bhankel","text":"R 3-dimensional array, matrix vector. vector length \\(k\\) coerced \\((1,1,k)\\)-dimensional array \\((p,q)\\) matrix treated array dimension \\((p,q,1)\\). d determines number block rows columns. Suppose R array size \\((p,q,k)\\). \\(d=(m,n)\\) bhankel returns block Hankel matrix \\(m\\) block rows \\(n\\) block columns. \\(d=m\\) Hankel matrix \\(m\\) block rows \\(n=\\max(k+1-m,1)\\) block columns returned. default case d = NULL number block rows \\(m=(k+1)/2\\) odd \\(k\\) \\(m=(k/2+1)\\) else number block columns set \\(n=\\max(k+1-m,1)\\). case \\((m+n-1)>k\\) array R padded zeros.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/bhankel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Block Hankel matrix — bhankel","text":"Matrix size \\((pm\\times qn)\\).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/bhankel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Block Hankel matrix — bhankel","text":"","code":"bhankel(1:6) #>      [,1] [,2] [,3] #> [1,]    1    2    3 #> [2,]    2    3    4 #> [3,]    3    4    5 #> [4,]    4    5    6 bhankel(1:6, d = 3) #>      [,1] [,2] [,3] [,4] #> [1,]    1    2    3    4 #> [2,]    2    3    4    5 #> [3,]    3    4    5    6 bhankel(letters[1:6], d = c(3,7))  # note the \"zero padding\" #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] #> [1,] \"a\"  \"b\"  \"c\"  \"d\"  \"e\"  \"f\"  \"0\"  #> [2,] \"b\"  \"c\"  \"d\"  \"e\"  \"f\"  \"0\"  \"0\"  #> [3,] \"c\"  \"d\"  \"e\"  \"f\"  \"0\"  \"0\"  \"0\"  bhankel(test_array(dim = c(2,2,6))) #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]  111  121  112  122  113  123 #> [2,]  211  221  212  222  213  223 #> [3,]  112  122  113  123  114  124 #> [4,]  212  222  213  223  214  224 #> [5,]  113  123  114  124  115  125 #> [6,]  213  223  214  224  215  225 #> [7,]  114  124  115  125  116  126 #> [8,]  214  224  215  225  216  226 bhankel(test_array(dim = c(3,2,6)), d = 3) #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #>  [1,]  111  121  112  122  113  123  114  124 #>  [2,]  211  221  212  222  213  223  214  224 #>  [3,]  311  321  312  322  313  323  314  324 #>  [4,]  112  122  113  123  114  124  115  125 #>  [5,]  212  222  213  223  214  224  215  225 #>  [6,]  312  322  313  323  314  324  315  325 #>  [7,]  113  123  114  124  115  125  116  126 #>  [8,]  213  223  214  224  215  225  216  226 #>  [9,]  313  323  314  324  315  325  316  326 bhankel(test_array(dim = c(2,2,6)), d = c(3,7)) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14] #> [1,]  111  121  112  122  113  123  114  124  115   125   116   126     0     0 #> [2,]  211  221  212  222  213  223  214  224  215   225   216   226     0     0 #> [3,]  112  122  113  123  114  124  115  125  116   126     0     0     0     0 #> [4,]  212  222  213  223  214  224  215  225  216   226     0     0     0     0 #> [5,]  113  123  114  124  115  125  116  126    0     0     0     0     0     0 #> [6,]  213  223  214  224  215  225  216  226    0     0     0     0     0     0 bhankel(test_array(dim = c(1,2,6)), d = c(1,2)) #>      [,1] [,2] [,3] [,4] #> [1,]  111  121  112  122 bhankel(test_array(dim = c(2,3)), d = c(2,2)) #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]   11   12   13    0    0    0 #> [2,]   21   22   23    0    0    0 #> [3,]    0    0    0    0    0    0 #> [4,]    0    0    0    0    0    0 bhankel(test_array(dim = c(2,2,6)), d = c(3,0)) #>      #> [1,] #> [2,] #> [3,] #> [4,] #> [5,] #> [6,] bhankel(test_array(dim = c(2,2,0)), d = c(2,2)) #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    0    0 #> [2,]    0    0    0    0 #> [3,]    0    0    0    0 #> [4,]    0    0    0    0  if (FALSE) { # the following examples throw an error bhankel(1:5, d = c(-1,1)) bhankel(test_array(dim = c(2,3,2,1))) }"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/bind.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine Rational Matrices by Rows or Columns — bind","title":"Combine Rational Matrices by Rows or Columns — bind","text":"function `rbind()` `cbind()` take sequence rational matrix objects  (.e. polm, lmfd, stsp, pseries  zvalues objects) combines matrices  rows columns.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/bind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine Rational Matrices by Rows or Columns — bind","text":"","code":"# S3 method for ratm rbind(...)  # S3 method for ratm cbind(...)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/bind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine Rational Matrices by Rows or Columns — bind","text":"... rational matrix objects, objects may coerced rational matrix objects.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/bind.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine Rational Matrices by Rows or Columns — bind","text":"rational matrix object.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/bind.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Combine Rational Matrices by Rows or Columns — bind","text":"input matrices first coerced objects class,  described group operator methods Ops.ratm.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/bind.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Combine Rational Matrices by Rows or Columns — bind","text":"","code":"a1 = test_polm(dim = c(2,3), degree = 2) a2 = test_polm(dim = c(1,3), degree = 1)  rbind(a1, a2)                  # => polm object #> ( 3 x 3 ) matrix polynomial with degree <= 2  #>      z^0 [,1]  [,2]  [,3] z^1 [,1]  [,2]  [,3] z^2 [,1]  [,2]  [,3] #> [1,]      110   120   130      111   121   131      112   122   132 #> [2,]      210   220   230      211   221   231      212   222   232 #> [3,]      110   120   130      111   121   131        0     0     0 rbind(lmfd(diag(2), a1), a2)   # => stsp object #> statespace realization [3,3] with s = 5 states #>      s[1] s[2] s[3] s[4] s[5] u[1] u[2] u[3] #> s[1]    0    0    0    0    0  112  122  132 #> s[2]    0    0    0    0    0  212  222  232 #> s[3]    1    0    0    0    0  111  121  131 #> s[4]    0    1    0    0    0  211  221  231 #> s[5]    0    0    0    0    0  111  121  131 #> x[1]    0    0    1    0    0  110  120  130 #> x[2]    0    0    0    1    0  210  220  230 #> x[3]    0    0    0    0    1  110  120  130 rbind(a1, as.stsp(a2))         # => stsp object #> statespace realization [3,3] with s = 5 states #>      s[1] s[2] s[3] s[4] s[5] u[1] u[2] u[3] #> s[1]    0    0    1    0    0  111  121  131 #> s[2]    0    0    0    1    0  211  221  231 #> s[3]    0    0    0    0    0  112  122  132 #> s[4]    0    0    0    0    0  212  222  232 #> s[5]    0    0    0    0    0  111  121  131 #> x[1]    1    0    0    0    0  110  120  130 #> x[2]    0    1    0    0    0  210  220  230 #> x[3]    0    0    0    0    1  110  120  130 rbind(a1, pseries(a2))         # pseries object  #> ( 3 x 3 ) impulse response with maximum lag = 5  #>      lag=0 [,1]  [,2]  [,3] lag=1 [,1]  [,2]  [,3] lag=2 [,1]  [,2]  [,3] #> [1,]        110   120   130        111   121   131        112   122   132 #> [2,]        210   220   230        211   221   231        212   222   232 #> [3,]        110   120   130        111   121   131          0     0     0 #>      lag=3 [,1]  [,2]  [,3] lag=4 [,1]  [,2]  [,3] lag=5 [,1]  [,2]  [,3] #> [1,]          0     0     0          0     0     0          0     0     0 #> [2,]          0     0     0          0     0     0          0     0     0 #> [3,]          0     0     0          0     0     0          0     0     0 rbind(zvalues(a1), a2)        # zvalues object #> ( 3 x 3 ) frequency response #>      z[1] [,1]   [,2]   [,3]          z[2] [,1]               [,2] #> [1,]    333+0i 363+0i 393+0i  53.6910-171.3992i  58.6910-186.7876i #> [2,]    633+0i 663+0i 693+0i 103.6910-325.2834i 108.6910-340.6718i #> [3,]    221+0i 241+0i 261+0i 144.3009-105.5673i 157.3911-115.0778i #>                    [,3]           z[3] [,1]                [,2] #> [1,]  63.6910-202.1761i  54.80902+41.27417i  59.80902+44.90688i #> [2,] 113.6910-356.0602i 104.80902+77.60129i 109.80902+81.23401i #> [3,] 170.4812-124.5884i  20.19911-65.24416i  22.10894-71.12202i #>                     [,3]           z[4] [,1]                [,2] #> [1,]  64.80902+48.53959i  54.80902-41.27417i  59.80902-44.90688i #> [2,] 114.80902+84.86672i 104.80902-77.60129i 109.80902-81.23401i #> [3,]  24.01877-76.99987i  20.19911+65.24416i  22.10894+71.12202i #>                     [,3]          z[5] [,1]               [,2] #> [1,]  64.80902-48.53959i  53.6910+171.3992i  58.6910+186.7876i #> [2,] 114.80902-84.86672i 103.6910+325.2834i 108.6910+340.6718i #> [3,]  24.01877+76.99987i 144.3009+105.5673i 157.3911+115.0778i #>                    [,3] #> [1,]  63.6910+202.1761i #> [2,] 113.6910+356.0602i #> [3,] 170.4812+124.5884i  a2 = test_polm(dim = c(2,1), degree = 3)  cbind(a1, a2) #> ( 2 x 4 ) matrix polynomial with degree <= 3  #>      z^0 [,1]  [,2]  [,3]  [,4] z^1 [,1]  [,2]  [,3]  [,4] z^2 [,1]  [,2]  [,3] #> [1,]      110   120   130   110      111   121   131   111      112   122   132 #> [2,]      210   220   230   210      211   221   231   211      212   222   232 #>       [,4] z^3 [,1]  [,2]  [,3]  [,4] #> [1,]   112        0     0     0   113 #> [2,]   212        0     0     0   213 cbind(lmfd(diag(2), a1), a2) #> statespace realization [2,4] with s = 7 states #>      s[1] s[2] s[3] s[4] s[5] s[6] s[7] u[1] u[2] u[3] u[4] #> s[1]    0    0    0    0    0    0    0  112  122  132    0 #> s[2]    0    0    0    0    0    0    0  212  222  232    0 #> s[3]    1    0    0    0    0    0    0  111  121  131    0 #> s[4]    0    1    0    0    0    0    0  211  221  231    0 #> s[5]    0    0    0    0    0    0    0    0    0    0    1 #> s[6]    0    0    0    0    1    0    0    0    0    0    0 #> s[7]    0    0    0    0    0    1    0    0    0    0    0 #> x[1]    0    0    1    0  111  112  113  110  120  130  110 #> x[2]    0    0    0    1  211  212  213  210  220  230  210 cbind(a1, as.stsp(a2)) #> statespace realization [2,4] with s = 7 states #>      s[1] s[2] s[3] s[4] s[5] s[6] s[7] u[1] u[2] u[3] u[4] #> s[1]    0    0    1    0    0    0    0  111  121  131    0 #> s[2]    0    0    0    1    0    0    0  211  221  231    0 #> s[3]    0    0    0    0    0    0    0  112  122  132    0 #> s[4]    0    0    0    0    0    0    0  212  222  232    0 #> s[5]    0    0    0    0    0    0    0    0    0    0    1 #> s[6]    0    0    0    0    1    0    0    0    0    0    0 #> s[7]    0    0    0    0    0    1    0    0    0    0    0 #> x[1]    1    0    0    0  111  112  113  110  120  130  110 #> x[2]    0    1    0    0  211  212  213  210  220  230  210 cbind(a1, pseries(a2)) #> ( 2 x 4 ) impulse response with maximum lag = 5  #>      lag=0 [,1]  [,2]  [,3]  [,4] lag=1 [,1]  [,2]  [,3]  [,4] lag=2 [,1]  [,2] #> [1,]        110   120   130   110        111   121   131   111        112   122 #> [2,]        210   220   230   210        211   221   231   211        212   222 #>       [,3]  [,4] lag=3 [,1]  [,2]  [,3]  [,4] lag=4 [,1]  [,2]  [,3]  [,4] #> [1,]   132   112          0     0     0   113          0     0     0     0 #> [2,]   232   212          0     0     0   213          0     0     0     0 #>      lag=5 [,1]  [,2]  [,3]  [,4] #> [1,]          0     0     0     0 #> [2,]          0     0     0     0 cbind(zvalues(a1), a2) #> ( 2 x 4 ) frequency response #>      z[1] [,1]   [,2]   [,3]   [,4]         z[2] [,1]              [,2] #> [1,]    333+0i 363+0i 393+0i 446+0i  53.691-171.3992i  58.691-186.7876i #> [2,]    633+0i 663+0i 693+0i 846+0i 103.691-325.2834i 108.691-340.6718i #>                   [,3]               [,4]           z[3] [,1] #> [1,]  63.691-202.1761i -37.7279-104.9795i  54.80902+41.27417i #> [2,] 113.691-356.0602i -68.6296-200.0851i 104.80902+77.60129i #>                     [,2]                [,3]                 [,4] #> [1,]  59.80902+44.90688i  64.80902+48.53959i  89.72794- 66.19522i #> [2,] 109.80902+81.23401i 114.80902+84.86672i 170.62964-124.97374i #>                z[4] [,1]                [,2]                [,3] #> [1,]  54.80902-41.27417i  59.80902-44.90688i  64.80902-48.53959i #> [2,] 104.80902-77.60129i 109.80902-81.23401i 114.80902-84.86672i #>                      [,4]         z[5] [,1]              [,2]              [,3] #> [1,]  89.72794+ 66.19522i  53.691+171.3992i  58.691+186.7876i  63.691+202.1761i #> [2,] 170.62964+124.97374i 103.691+325.2834i 108.691+340.6718i 113.691+356.0602i #>                    [,4] #> [1,] -37.7279+104.9795i #> [2,] -68.6296+200.0851i  # the following exmpales throw an error if (FALSE) { rbind(a1, a2)   # the number of columns does not coincide  cbind(pseries(a1), zvalues(a2)) # there is no automatic coercion                                  # from pseries to zvalues }"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/blaschke.html","id":null,"dir":"Reference","previous_headings":"","what":"Blaschke Factors — blaschke","title":"Blaschke Factors — blaschke","text":"Blaschke factor \\(\\alpha\\) rational function $$B(z) := \\frac{1-\\bar{\\alpha}z}{-\\alpha + z}$$ -pass function pole \\(z=\\alpha\\) zero \\(z=1/\\bar{\\alpha}\\). function blaschke(alpha) returns rational \\((1 \\times 1)\\) matrix lmfd form. Clearly \\(B(z)\\) complex coefficients, \\(\\alpha\\) complex.  call blaschke2(alpha, row=NULL) computes product Blaschke factors \\(\\alpha\\) \\(\\bar{\\alpha}\\), .e. rational function $$B_{s}(z) :=  \\frac{1-2\\Re(\\alpha)z + |\\alpha|^2 z^2}{|\\alpha|^2 -2\\Re(\\alpha) z + z^2}$$  blaschke2 called optional argument w  (non zero complex vector length 2)  blaschke2 constructs \\((2 \\times 2)\\) rational,  -pass matrix form  $$B_{2}(z) := ^{-1}(z) b(z)$$  \\((z), b(z)\\)  two \\((2 \\times 2)\\) polynomial  matrices (real coefficients) degree one.  matrix constructed column space  \\((\\alpha)\\) spanned  \\(\\bar{w}\\)  column space  \\((\\bar{\\alpha})\\) spanned vector \\(w\\).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/blaschke.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Blaschke Factors — blaschke","text":"","code":"blaschke(alpha)  blaschke2(alpha, w = NULL, tol = 100 * .Machine$double.eps)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/blaschke.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Blaschke Factors — blaschke","text":"alpha complex real scalar, represents \\(\\alpha\\). w NULL (complex) vector length 2. tol Tolerance (used decide whether alpha  modulus equal one).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/blaschke.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Blaschke Factors — blaschke","text":"lmfd object, represents constructed          \"Blaschke factors\"  \\(B(z)\\), \\(B_s(z)\\) \\(B_2(z)\\).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/blaschke.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Blaschke Factors — blaschke","text":"routine blaschke2 throws error \\(\\alpha\\)   complex (.e. imaginary part zero). \\(\\alpha\\) close   unit circle blaschke2(alpha, w) simply returns   lmfd representation bivariate identity matrix.   \\(w\\) \\(\\bar{w}\\) almost linearly dependent,   error thrown.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/blaschke.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Blaschke Factors — blaschke","text":"","code":"# Blaschke factor with a real alpha (B = blaschke(1.5)) #> ( 1 x 1 ) left matrix fraction description a^(-1)(z) b(z) with degrees (p = 1, q = 1) #> left factor a(z): #>      z^0 [,1] z^1 [,1] #> [1,]     -1.5        1 #> right factor b(z): #>      z^0 [,1] z^1 [,1] #> [1,]        1     -1.5 zvalues(B) %>% abs() #> ( 1 x 1 ) frequency response #>      z[1] [,1] z[2] [,1] z[3] [,1] z[4] [,1] z[5] [,1] #> [1,]         1         1         1         1         1  # Blaschke factor with a complex alpha (B = blaschke(complex(real = 1.5, imaginary = 0.5))) #> ( 1 x 1 ) left matrix fraction description a^(-1)(z) b(z) with degrees (p = 1, q = 1) #> left factor a(z): #>       z^0 [,1] z^1 [,1] #> [1,] -1.5-0.5i     1+0i #> right factor b(z): #>      z^0 [,1]  z^1 [,1] #> [1,]     1+0i -1.5+0.5i zvalues(B) %>% abs() #> ( 1 x 1 ) frequency response #>      z[1] [,1] z[2] [,1] z[3] [,1] z[4] [,1] z[5] [,1] #> [1,]         1         1         1         1         1  # product of the Blaschke factors at alpha and Conj(alpha)  # this gives a scalar, rational, all-pass matrix with real coefficients (B = blaschke2(complex(real = 1.5, imaginary = 0.5))) #> ( 1 x 1 ) left matrix fraction description a^(-1)(z) b(z) with degrees (p = 2, q = 2) #> left factor a(z): #>      z^0 [,1] z^1 [,1] z^2 [,1] #> [1,]      2.5       -3        1 #> right factor b(z): #>      z^0 [,1] z^1 [,1] z^2 [,1] #> [1,]        1       -3      2.5 zvalues(B) %>% abs() #> ( 1 x 1 ) frequency response #>      z[1] [,1] z[2] [,1] z[3] [,1] z[4] [,1] z[5] [,1] #> [1,]         1         1         1         1         1  ############################################################# # a \"bivariate\" Blaschke factor   # case 1: alpha is \"outside the unit circle\" ################ (alpha = complex(real = 1.5, imaginary = 0.5)) #> [1] 1.5+0.5i (w = complex(real = c(0.1,0.9), imaginary = c(0.75,-0.5))) #> [1] 0.1+0.75i 0.9-0.50i  (B = blaschke2(alpha, w = w)) #> ( 2 x 2 ) left matrix fraction description a^(-1)(z) b(z) with degrees (p = 1, q = 1) #> left factor a(z): #>      z^0 [,1]  [,2]   z^1 [,1]       [,2] #> [1,]        1     0 -0.6786207 -0.1579310 #> [2,]        0     1  0.2924138 -0.5213793 #> right factor b(z): #>       z^0 [,1]       [,2]  z^1 [,1]      [,2] #> [1,] 0.6616180 -0.2854763 -0.976275  0.114544 #> [2,] 0.2214899  0.5090096  0.000000 -1.024302 # B(z) is all-pass  print(zvalues(B) %r% Ht(zvalues(B)), digits = 3) #> ( 2 x 2 ) frequency response #>      z[1] [,1]  [,2] z[2] [,1]  [,2] z[3] [,1]  [,2] z[4] [,1]  [,2] z[5] [,1] #> [1,]      1+0i  0+0i      1+0i  0+0i      1+0i  0+0i      1+0i  0+0i      1+0i #> [2,]      0+0i  1+0i      0+0i  1+0i      0+0i  1+0i      0+0i  1+0i      0+0i #>       [,2] #> [1,]  0+0i #> [2,]  1+0i  # B(z) has poles at z=alpha, z=Conj(alpha) and  # zeroes at z=1/alpha and z=1/Conj(alpha) poles(B) #> [1] 1.5-0.5i 1.5+0.5i zeroes(B) #> [1] 0.6-0.2i 0.6+0.2i  # The column space of a(alpha) is spanned by the vector Conj(w). max(abs( Conj(c(-w[2], w[1])) %*% zvalue(B$a, alpha) )) #> [1] 1.475229e-16  # case 2: alpha is \"inside the unit circle\" ################# (alpha = 1 / complex(real = 1.5, imaginary = 0.5)) #> [1] 0.6-0.2i (w = complex(real = c(0.1,0.9), imaginary = c(0.75,-0.5))) #> [1] 0.1+0.75i 0.9-0.50i  (B = blaschke2(alpha, w = w)) #> ( 2 x 2 ) left matrix fraction description a^(-1)(z) b(z) with degrees (p = 1, q = 1) #> left factor a(z): #>        z^0 [,1]       [,2] z^1 [,1]  [,2] #> [1,] -0.6786207 -0.1579310        1     0 #> [2,]  0.2924138 -0.5213793        0     1 #> right factor b(z): #>      z^0 [,1]      [,2]   z^1 [,1]       [,2] #> [1,] 0.976275 -0.114544 -0.6616180  0.2854763 #> [2,] 0.000000  1.024302 -0.2214899 -0.5090096 # B(z) is all-pass  print(zvalues(B) %r% Ht(zvalues(B)), digits = 3) #> ( 2 x 2 ) frequency response #>      z[1] [,1]  [,2] z[2] [,1]  [,2] z[3] [,1]  [,2] z[4] [,1]  [,2] z[5] [,1] #> [1,]      1+0i  0+0i      1+0i  0+0i      1+0i  0+0i      1+0i  0+0i      1+0i #> [2,]      0+0i  1+0i      0+0i  1+0i      0+0i  1+0i      0+0i  1+0i      0+0i #>       [,2] #> [1,]  0+0i #> [2,]  1+0i  # B(z) has poles at z=alpha, z=Conj(alpha) and  # zeroes at z=1/alpha and z=1/Conj(alpha) poles(B) #> [1] 0.6-0.2i 0.6+0.2i zeroes(B) #> [1] 1.5-0.5i 1.5+0.5i  # The column space of a(alpha) is spanned by the vector Conj(w). max(abs( Conj(c(-w[2], w[1])) %*% zvalue(B$a, alpha) )) #> [1] 1.494683e-16  # case 3: alpha is \"on the unit circle\" ##################### alpha = alpha / Mod(alpha) blaschke2(alpha) %>% print(digits = 2) #> ( 1 x 1 ) left matrix fraction description a^(-1)(z) b(z) with degrees (p = 2, q = 2) #> left factor a(z): #>      z^0 [,1] z^1 [,1] z^2 [,1] #> [1,]        1     -1.9        1 #> right factor b(z): #>      z^0 [,1] z^1 [,1] z^2 [,1] #> [1,]        1     -1.9        1 blaschke2(alpha, w = w) %>% print(digits = 2) #> ( 2 x 2 ) left matrix fraction description a^(-1)(z) b(z) with degrees (p = 0, q = 0) #> left factor a(z): #>      z^0 [,1]  [,2] #> [1,]        1     0 #> [2,]        0     1 #> right factor b(z): #>      z^0 [,1]  [,2] #> [1,]        1     0 #> [2,]        0     1"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/bmatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Block matrices — bmatrix","title":"Block matrices — bmatrix","text":"helper function coerces array (block) matrix.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/bmatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Block matrices — bmatrix","text":"","code":"bmatrix(x, rows = NULL, cols = NULL)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/bmatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Block matrices — bmatrix","text":"x Vector, matrix array. Vectors coerced one dimensional arrays matrices course treated 2-dimensional arrays. rows, cols integer vectors. two vectors define partition \"dimensions\" (1,...,n), n number dimensions x (.e. length(dim(x))). either two missing, complement used. least one arguments \"rows\" \"cols\" given.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/bmatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Block matrices — bmatrix","text":"matrix","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/bmatrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Block matrices — bmatrix","text":"","code":"x = 1:4 bmatrix(x, rows = 1, cols = integer(0)) # returns an (4,1) matrix #>      [,1] #> [1,]    1 #> [2,]    2 #> [3,]    3 #> [4,]    4 bmatrix(x, cols = 1, rows = NULL)       # returns an (1,4) matrix #>      [,1] [,2] [,3] [,4] #> [1,]    1    2    3    4  x = test_array(dim = c(2,3)) bmatrix(x, cols = 2)    # returns x    (is equivalent to bmatrix(x, rows = 1, cols = 2)) #>      [,1] [,2] [,3] #> [1,]   11   12   13 #> [2,]   21   22   23 bmatrix(x, rows = 2)    # returns t(x) (is equivalent to bmatrix(x, rows = 2, cols = 1)) #>      [,1] [,2] #> [1,]   11   21 #> [2,]   12   22 #> [3,]   13   23 bmatrix(x, rows = integer(0))   # returns an (1,6) matrix #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]   11   21   12   22   13   23  x = test_array(dim = c(2,3,4)) bmatrix(x, rows = 1)   # is equivalent to: bmatrix(x, rows = 1, cols = c(2,3)) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] #> [1,]  111  121  131  112  122  132  113  123  133   114   124   134 #> [2,]  211  221  231  212  222  232  213  223  233   214   224   234 bmatrix(x, rows = 1, cols = c(3,2)) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] #> [1,]  111  112  113  114  121  122  123  124  131   132   133   134 #> [2,]  211  212  213  214  221  222  223  224  231   232   233   234 bmatrix(x, cols = 2)   # is equivalent to: bmatrix(x, rows = c(1,3), cols = 2) #>      [,1] [,2] [,3] #> [1,]  111  121  131 #> [2,]  211  221  231 #> [3,]  112  122  132 #> [4,]  212  222  232 #> [5,]  113  123  133 #> [6,]  213  223  233 #> [7,]  114  124  134 #> [8,]  214  224  234 bmatrix(x, rows = 1:3) # is equivalent to: bmatrix(x, cols = integer(0)) #>       [,1] #>  [1,]  111 #>  [2,]  211 #>  [3,]  121 #>  [4,]  221 #>  [5,]  131 #>  [6,]  231 #>  [7,]  112 #>  [8,]  212 #>  [9,]  122 #> [10,]  222 #> [11,]  132 #> [12,]  232 #> [13,]  113 #> [14,]  213 #> [15,]  123 #> [16,]  223 #> [17,]  133 #> [18,]  233 #> [19,]  114 #> [20,]  214 #> [21,]  124 #> [22,]  224 #> [23,]  134 #> [24,]  234 bmatrix(x, rows = c(3,1,2)) #>       [,1] #>  [1,]  111 #>  [2,]  112 #>  [3,]  113 #>  [4,]  114 #>  [5,]  211 #>  [6,]  212 #>  [7,]  213 #>  [8,]  214 #>  [9,]  121 #> [10,]  122 #> [11,]  123 #> [12,]  124 #> [13,]  221 #> [14,]  222 #> [15,]  223 #> [16,]  224 #> [17,]  131 #> [18,]  132 #> [19,]  133 #> [20,]  134 #> [21,]  231 #> [22,]  232 #> [23,]  233 #> [24,]  234  if (FALSE) { # the examples below throw an error bmatrix(x, rows = 1, cols = 2) bmatrix(x, rows = c(1,2), cols = c(2,3)) bmatrix(x, rows = c(1,2,1), cols = 3) }"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/btext.html","id":null,"dir":"Reference","previous_headings":"","what":"Write ","title":"Write ","text":"tool writes text \"colored\" box one margins plot region.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/btext.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write ","text":"","code":"btext(   text,   side = 3,   cex = 1,   col = \"black\",   size = cex,   bg = \"lightgray\",   border = \"lightgray\",   parse_text = FALSE )"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/btext.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write ","text":"text character expression. side side plot (1=bottom, 2=left, 3=top, 4=right). cex character expansion factor. col color use (text). size determines size box (\"line\" units) bg, border background border color box. parse_text yes procedure tries coerce text expression.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/btext.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write ","text":"(invisible) vector \"box\" corner center coordinates.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/reference/btext.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write ","text":"","code":"if (FALSE) { plot(1:10, axes = FALSE) graphics::box() btext('hallo', side = 1) btext('Sigma[11]', side = 2, bg = 'lightblue') btext('Sigma[11]', side = 3, bg = NA, border = 'black', size = 1.2, parse_text = TRUE) btext(expression(Sigma[11]), side = 4, bg = 'orange', border = 'black', cex = 1.5) }"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/btoeplitz.html","id":null,"dir":"Reference","previous_headings":"","what":"Block Toeplitz matrix — btoeplitz","title":"Block Toeplitz matrix — btoeplitz","text":"Construct block Toeplitz matrix two 3-dimensional arrays R C. array R determines first block row C first block column result. \\((,j)\\)-th block Toeplitz matrix R[,,j-+1] \\(j\\geq \\) C[,,-j+1] \\(j < \\). particular, note \\((1,1)\\) block set R[,,1] (C[,,1] ignored).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/btoeplitz.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Block Toeplitz matrix — btoeplitz","text":"","code":"btoeplitz(R, C)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/btoeplitz.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Block Toeplitz matrix — btoeplitz","text":"R Array dimensions \\((p,q,n)\\). Corresponds first (block-) row, containing \\(n\\) matrices dimension \\((p \\times q)\\). vector coerced \\((1,1,n)\\) dimensional array \\((p,q)\\) matrix interpreted \\((p,q,1)\\) dimensional array. C Array dimensions \\((p,q,m)\\). Corresponds first (block-) column, containing \\(m\\) matrices dimension \\((p \\times q)\\). vector coerced \\((1,1,m)\\) dimensional array \\((p,q)\\) matrix interpreted \\((p,q,1)\\) dimensional array.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/btoeplitz.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Block Toeplitz matrix — btoeplitz","text":"Matrix size \\(( pm \\times qn )\\).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/btoeplitz.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Block Toeplitz matrix — btoeplitz","text":"argument R provided C set C = aperm(R,c(2,1,3))). btoeplitz(R = X) equivalent btoeplitz(R = X, C = aperm(X,c(2,1,3))). Analogously btoeplitz(C = X) equivalent btoeplitz(R = aperm(X,c(2,1,3)), C = X). cases \\(p=q\\) must hold. constructed Toeplitz matrix symmetric X[,,1] symmetric. Note also even case C supplied \"R wins\" rule holds, .e. btoeplitz(C = X) sets \\((1,1)\\) block equal t(X[,,1]).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/btoeplitz.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Block Toeplitz matrix — btoeplitz","text":"","code":"btoeplitz(0:3) #>      [,1] [,2] [,3] [,4] #> [1,]    0    1    2    3 #> [2,]    1    0    1    2 #> [3,]    2    1    0    1 #> [4,]    3    2    1    0 btoeplitz(0:3,-(0:3)) #>      [,1] [,2] [,3] [,4] #> [1,]    0    1    2    3 #> [2,]   -1    0    1    2 #> [3,]   -2   -1    0    1 #> [4,]   -3   -2   -1    0  btoeplitz(R = test_array(dim=c(2,3,3)), C = -test_array(dim = c(2,3,2))) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] #> [1,]  111  121  131  112  122  132  113  123  133 #> [2,]  211  221  231  212  222  232  213  223  233 #> [3,] -112 -122 -132  111  121  131  112  122  132 #> [4,] -212 -222 -232  211  221  231  212  222  232 btoeplitz(R = test_array(dim=c(2,2,1)), C = test_array(dim=c(2,2,0))) #>      [,1] [,2] btoeplitz(R = test_array(dim=c(2,2,3))) #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]  111  121  112  122  113  123 #> [2,]  211  221  212  222  213  223 #> [3,]  112  212  111  121  112  122 #> [4,]  122  222  211  221  212  222 #> [5,]  113  213  112  212  111  121 #> [6,]  123  223  122  222  211  221 btoeplitz(C = -test_array(dim=c(2,2,3))) #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,] -111 -211 -112 -212 -113 -213 #> [2,] -121 -221 -122 -222 -123 -223 #> [3,] -112 -122 -111 -211 -112 -212 #> [4,] -212 -222 -121 -221 -122 -222 #> [5,] -113 -123 -112 -122 -111 -211 #> [6,] -213 -223 -212 -222 -121 -221 # create a symmetric matrix X = test_array(dim= c(2,2,3)) X[,,1] = (X[,,1] + t(X[,,1]))/2 btoeplitz(R = X) #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]  111  166  112  122  113  123 #> [2,]  166  221  212  222  213  223 #> [3,]  112  212  111  166  112  122 #> [4,]  122  222  166  221  212  222 #> [5,]  113  213  112  212  111  166 #> [6,]  123  223  122  222  166  221 btoeplitz(C = X) #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]  111  166  112  212  113  213 #> [2,]  166  221  122  222  123  223 #> [3,]  112  122  111  166  112  212 #> [4,]  212  222  166  221  122  222 #> [5,]  113  123  112  122  111  166 #> [6,]  213  223  212  222  166  221  if (FALSE) { # the following examples throw an error btoeplitz(R = test_array(dim=c(2,1,3)), C = -test_array(dim = c(2,2,2))) btoeplitz(R = test_array(dim=c(2,1,3))) btoeplitz(C = test_array(dim=c(2,1,3))) }"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/check.html","id":null,"dir":"Reference","previous_headings":"","what":"Check Properties of Rational Matrices — check objects","title":"Check Properties of Rational Matrices — check objects","text":"Check Properties Rational Matrices","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/check.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check Properties of Rational Matrices — check objects","text":"","code":"is.stable(x, ...)  # S3 method for ratm is.stable(x, ...)  is.miniphase(x, ...)  # S3 method for ratm is.miniphase(x, ...)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/check.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check Properties of Rational Matrices — check objects","text":"x rational matrix object, .e. polm, lmfd,  stsp, pseries, zvalues object. ... used.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/check.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check Properties of Rational Matrices — check objects","text":"Boolean. Note .stable, .miniphase return NA objects type pseries zvalues.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/check.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check Properties of Rational Matrices — check objects","text":"","code":"a = test_polm(dim = c(2,2), deg = 1, random = TRUE) b = test_polm(dim = c(2,3), deg = 1, random = TRUE) c = lmfd(a,b)  is.stable(a) #> [1] TRUE is.stable(c) #> [1] FALSE is.stable(as.stsp(c)) #> [1] FALSE is.stable(pseries(c)) #> [1] NA  is.miniphase(b[,1:2]) #> [1] FALSE is.miniphase(as.stsp(c)[,1:2]) #> [1] FALSE  if (FALSE) { is.miniphase(b) is.miniphase(c) }"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/col_end_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Column End Matrix of a Polynomial Matrix — col_end_matrix","title":"Column End Matrix of a Polynomial Matrix — col_end_matrix","text":"column end matrix \\((m,n)\\)-dimensional polynomial matrix  \\((z)=a_0 + a_1 z + \\cdots + a_p z^p\\) defined follows.  Suppose maximum degree elements \\(\\)-th column \\(p_i\\).  column end matrix \\((m,n)\\) matrix \\(\\)-th column equal  \\(\\)-th column coefficient matrix \\(a_{p_i}\\). column  \\((z)\\) zero, elements corresponding column column end matrix set NA's.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/col_end_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Column End Matrix of a Polynomial Matrix — col_end_matrix","text":"","code":"col_end_matrix(x)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/col_end_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Column End Matrix of a Polynomial Matrix — col_end_matrix","text":"x polynomial matrix, .e. object class polm.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/col_end_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Column End Matrix of a Polynomial Matrix — col_end_matrix","text":"column end matrix.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/col_end_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Column End Matrix of a Polynomial Matrix — col_end_matrix","text":"","code":"x = polm(array(c(0,1,1,0,                  0,0,1,0,                  0,0,0,1,                  0,0,0,0), dim = c(2,2,4))) x #> ( 2 x 2 ) matrix polynomial with degree <= 3  #>      z^0 [,1]  [,2] z^1 [,1]  [,2] z^2 [,1]  [,2] z^3 [,1]  [,2] #> [1,]        0     1        0     1        0     0        0     0 #> [2,]        1     0        0     0        0     1        0     0 degree(x) #>      [,1] [,2] #> [1,]   -1    1 #> [2,]    0    2 degree(x, 'columns') #> [1] 0 2 col_end_matrix(x) #>      [,1] [,2] #> [1,]    0    0 #> [2,]    1    1"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/col_reduce.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a Column Reduced Polynomial Matrix — col_reduce","title":"Construct a Column Reduced Polynomial Matrix — col_reduce","text":"Let \\((z)\\) square (non singular) polynomial matrix.  helper function constructs unimodular transformation matrix \\(v(z)\\) \\((z) v^{-1}(z)\\) column reduced (.e. column end matrix full rank). Algorithmic implementation described e.g. (Wolovich 1974)  Theorem 2.5.7, page 27, (Krishnarao Chen 1984) , (Geurts Praagman 1996)  show KC implementations fails degree unimodular matrix \\(v^{-1}(z)\\) exceeds degree \\((z)\\) (page 4 GP). implementations use elementary column operations obtain zero columns column-end-matrix (order reduce degree matrix polynomial), implementation uses svd. examples taken (Geurts Praagman 1996)  (Krishnarao Chen 1984) .","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/col_reduce.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a Column Reduced Polynomial Matrix — col_reduce","text":"","code":"col_reduce(a, tol = sqrt(.Machine$double.eps), debug = FALSE)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/col_reduce.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a Column Reduced Polynomial Matrix — col_reduce","text":"polm object, represents square, polynomial matrix  \\((z)\\). tol Double. Tolerance parameter. Default set sqrt(.Machine$double.eps). debug Logical, default FALSE. TRUE, diagnostic messages printed.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/col_reduce.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct a Column Reduced Polynomial Matrix — col_reduce","text":"List components (polm object) transformed (column reduced) matrix. v,v_inv (polm objects) unimodular matrices \\(v(z)\\) \\(v^{-1}(z)\\) \\((z) v^{-1}(z)\\) column reduced . col_degrees vector column degrees transformed matrix.      Note columns permuted transformed matrix *non-increasing* column degrees. col_end_matrix column end matrix transformed matrix.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/col_reduce.html","id":"possible-improvements-","dir":"Reference","previous_headings":"","what":"Possible \"Improvements\"","title":"Construct a Column Reduced Polynomial Matrix — col_reduce","text":"clear whether changes improvements... First: rank deficiency column-end-matrix detected SVD, one column \"reduced\" zero (even rank deficiency larger one).  Fewer SVDs calculated  might better reduce columns zero pertain (numerically) zero eigenvalues.  Second: pivoting mechanism QR decomposition might useful single columns set zero. might preferable SVD.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/col_reduce.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Construct a Column Reduced Polynomial Matrix — col_reduce","text":"Wolovich WA (1974). Linear multivariable systems,  Applied mathematical sciences. Springer-Verlag. ISBN 9783540901013.  Krishnarao , Chen CT (1984). “Two polynomial matrix operations.” IEEE Transactions Automatic Control, 29(4), 346-348.  Geurts AJ, Praagman C (1996). “Column Reduction Polynomial Matrices; Remarks Algorithm Wolovich.” European Journal Control, 2(2), 152-157. doi:10.1016/S0947-3580(96)70039-0 .","code":""},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/reference/col_reduce.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct a Column Reduced Polynomial Matrix — col_reduce","text":"","code":"# ############################################################################# # define a simple utility function for the computation of the rank of a matrix  # compare e.g. Matrix::rankMatrix rkM = function(x) {   m = nrow(x)   n = ncol(x)   tol = max(m,n) * .Machine$double.eps      if (min(m,n) == 0) return(0L)   s = svd(x, 0, 0)$d   return(sum(s >= tol*max(s))) } # #############################################################################  z = polm(c(0,1))  # Example 2.5.4 in W. A. Wolovich, Linear Multivariable Systems ############### a = matrix(c(-3,2,0,1,2,3,0,0,2), nrow = 3, ncol = 3) +     matrix(c(0,4,0,0,0,1,2,0,-3), nrow = 3, ncol = 3) * z +      matrix(c(1,0,-1,0,0,0,0,0,0), nrow = 3, ncol = 3) * z^2  # Original Matrix: print(a, format = 'c') #> ( 3 x 3 ) matrix polynomial with degree <= 2  #>           [,1]   [,2]    [,3] #> [1,]  -3 + z^2      1      2z #> [2,]    2 + 4z      2       0 #> [3,]      -z^2  3 + z  2 - 3z  # Its column end matrix (and its rank) and column degrees col_end_matrix(a) #>      [,1] [,2] [,3] #> [1,]    1    0    2 #> [2,]    0    0    0 #> [3,]   -1    1   -3 col_end_matrix(a) %>% svd() %>% .$d #> [1] 3.9516798 0.6198604 0.0000000 degree(a, \"c\") #> [1] 2 1 1  # After column reduction: out = col_reduce(a) print(out$a, format = 'c', digits = 2) #> ( 3 x 3 ) matrix polynomial with degree <= 1  #>        [,1]    [,2]       [,3] #> [1,]      1      2z  -3 - 0.5z #> [2,]      2       0     2 + 3z #> [3,]  3 + z  2 - 3z      -2.5z  print(out$col_degrees) #> [1] 1 1 1 print(out$col_end_matrix) #>      [,1] [,2] [,3] #> [1,]    0    2 -0.5 #> [2,]    0    0  3.0 #> [3,]    1   -3 -2.5 print(out$col_end_matrix %>% svd() %>% .$d) #> [1] 4.6460685 2.7744157 0.4654726  # Check correctness: all.equal(polm(diag(3)), prune(out$v %r% out$v_inv)) #> [1] TRUE all.equal(prune(a), prune(out$a %r% out$v)) #> [1] TRUE      # Random example: col degrees = (0,1,-1): throws an error ##################################### a = test_polm(dim = c(3,3), degree = c(0,1,-1), random = TRUE, digits = 2) print(a, format = 'c') #> ( 3 x 3 ) matrix polynomial with degree <= 1  #>        [,1]           [,2]  [,3] #> [1,]   0.72  -0.78 - 1.15z     0 #> [2,]  -0.34  -0.73 + 0.42z     0 #> [3,]   0.44   -0.1 - 0.65z     0   if (FALSE) { # this throws an error, since a(z) is singular out = col_reduce(a) }   # Random example: Generic matrices are row reduced ############################################ a = test_polm(dim = c(3,3), degree = c(2,1,0), random = TRUE, digits = 2) print(a, format = 'c') #> ( 3 x 3 ) matrix polynomial with degree <= 2  #>                          [,1]           [,2]   [,3] #> [1,]   -1.2 + 1.06z + 0.75z^2  -0.96 - 0.44z  -1.06 #> [2,]  -0.08 - 1.24z + 0.72z^2  -0.68 + 0.94z  -0.06 #> [3,]   -0.68 + 0.3z + 1.84z^2  -1.26 + 0.51z  -0.05   # Column reduction: out = col_reduce(a)  print(out$a, format = 'c', digits = 2) #> ( 3 x 3 ) matrix polynomial with degree <= 2  #>                          [,1]           [,2]   [,3] #> [1,]   -1.2 + 1.06z + 0.75z^2  -0.96 - 0.44z  -1.06 #> [2,]  -0.08 - 1.24z + 0.72z^2  -0.68 + 0.94z  -0.06 #> [3,]   -0.68 + 0.3z + 1.84z^2  -1.26 + 0.51z  -0.05  print(out$col_degrees) #> [1] 2 1 0 print(out$col_end_matrix) #>      [,1]  [,2]  [,3] #> [1,] 0.75 -0.44 -1.06 #> [2,] 0.72  0.94 -0.06 #> [3,] 1.84  0.51 -0.05 print(out$col_end_matrix %>% svd() %>% .$d) #> [1] 2.2520889 1.2636184 0.5146496  # Check: all.equal(polm(diag(3)), prune(out$v %r% out$v_inv)) #> [1] TRUE all.equal(prune(a), prune(out$a %r% out$v)) #> [1] TRUE   # Random example: Column end matrix has rank 2 ################################ col_end_matrix = matrix(round(rnorm(2*3),1), nrow = 3, ncol = 2) %*%                   matrix(round(rnorm(2*3),1), nrow = 2, ncol = 3) a = test_polm(dim = c(3,3), degree = c(2,1,0), random = TRUE,                 digits = 2, col_end_matrix = col_end_matrix) print(a, format = 'c') #> ( 3 x 3 ) matrix polynomial with degree <= 2  #>                          [,1]          [,2]   [,3] #> [1,]    0.73 + 0.9z - 2.39z^2  0.16 + 0.75z  -4.73 #> [2,]  -0.56 + 1.33z - 2.11z^2  -0.47 - 2.4z   0.38 #> [3,]     -0.85 - 0.62z - 2z^2  1.77 - 1.69z  -0.51  a %>% degree(\"c\") #> [1] 2 1 0 print(a %>% col_end_matrix) #>       [,1]  [,2]  [,3] #> [1,] -2.39  0.75 -4.73 #> [2,] -2.11 -2.40  0.38 #> [3,] -2.00 -1.69 -0.51 print(a %>% col_end_matrix %>% svd() %>% .$d) #> [1] 5.550524e+00 3.913041e+00 2.986539e-16  # Column reduction: out = col_reduce(a)  print(out$a, format = 'c', digits = 2) #> ( 3 x 3 ) matrix polynomial with degree <= 1  #>               [,1]           [,2]   [,3] #> [1,]  0.16 + 0.75z   0.73 + 0.74z  -4.73 #> [2,]  -0.47 - 2.4z  -0.56 + 1.79z   0.38 #> [3,]  1.77 - 1.69z  -0.85 - 2.36z  -0.51  print(out$col_degrees) #> [1] 1 1 0 print(out$col_end_matrix) #>       [,1]       [,2]  [,3] #> [1,]  0.75  0.7425806 -4.73 #> [2,] -2.40  1.7924194  0.38 #> [3,] -1.69 -2.3614516 -0.51 print(out$col_end_matrix %>% svd() %>% .$d) #> [1] 4.884202 3.030118 2.873952  # Check: all.equal(polm(diag(3)), prune(out$v %r% out$v_inv)) #> [1] TRUE all.equal(prune(a), prune(out$a %r% out$v)) #> [1] TRUE   # Random example: Column end matrix has rank 1 ################################  col_end_matrix = matrix(round(rnorm(3),1), nrow = 3, ncol = 1) %*%                   matrix(round(rnorm(3),1), nrow = 1, ncol = 3) a = test_polm(dim = c(3,3), degree = c(2,1,1), random = TRUE,                 digits = 2, col_end_matrix = col_end_matrix) print(a, format = 'c') #> ( 3 x 3 ) matrix polynomial with degree <= 2  #>                          [,1]   [,2]           [,3] #> [1,]  -0.29 - 2.19z - 0.91z^2  -0.12  -1.54 - 0.78z #> [2,]    1.6 + 0.26z - 0.49z^2  -2.59  -0.46 - 0.42z #> [3,]   0.41 - 0.29z + 1.19z^2   0.75   0.25 + 1.02z  a %>% degree(\"c\") #> [1] 2 0 1 a %>% col_end_matrix() %>% svd() %>% .$d #> [1] 3.022858 1.567428 0.000000  # Column reduction: out = col_reduce(a, debug = FALSE)  print(out$a, format = 'c', digits = 2) #> ( 3 x 3 ) matrix polynomial with degree <= 1  #>                [,1]           [,2]   [,3] #> [1,]  -1.54 - 0.78z  -0.29 - 0.39z  -0.12 #> [2,]  -0.46 - 0.42z     1.6 + 0.8z  -2.59 #> [3,]   0.25 + 1.02z   0.41 - 0.58z   0.75  print(out$col_degrees) #> [1] 1 1 0 print(out$col_end_matrix) #>       [,1]       [,2]  [,3] #> [1,] -0.78 -0.3933333 -0.12 #> [2,] -0.42  0.7966667 -2.59 #> [3,]  1.02 -0.5816667  0.75 print(out$col_end_matrix %>% svd() %>% .$d) #> [1] 2.9572265 1.1070065 0.5169848  # Check: all.equal(polm(diag(3)), prune(out$v %r% out$v_inv)) #> [1] TRUE all.equal(prune(a), prune(out$a %r% out$v)) #> [1] TRUE  #################################################################################  # PG, Ex 1: Jordan Normal Form type (Unimodular matrix) ########## # Result: Works fine here (does not work with KC implementation) m0 = diag(3) m1 = matrix(c(0,1,0,                  0,0,1,                  0,0,0), nrow = 3, byrow = TRUE)  # Polymat: (a = polm(array(c(m0,m1), dim = c(3,3,2)))) #> ( 3 x 3 ) matrix polynomial with degree <= 1  #>      z^0 [,1]  [,2]  [,3] z^1 [,1]  [,2]  [,3] #> [1,]        1     0     0        0     1     0 #> [2,]        0     1     0        0     0     1 #> [3,]        0     0     1        0     0     0 a %>% print(format = \"c\") #> ( 3 x 3 ) matrix polynomial with degree <= 1  #>       [,1]  [,2]  [,3] #> [1,]     1     z     0 #> [2,]     0     1     z #> [3,]     0     0     1  a %>% degree(\"c\") #> [1] 0 1 1  # Column reduced a_red = col_reduce(a) a_red$a #> ( 3 x 3 ) matrix polynomial with degree <= 0  #>      z^0 [,1]  [,2]  [,3] #> [1,]        1     0     0 #> [2,]        0     1     0 #> [3,]        0     0     1 degree(a_red$a, \"c\") #> [1] 0 0 0  #################################################################################  # PG, Ex 2: Nothing special ########## # Result: Same as PG  a = test_polm(dim = c(2,2), degree = -1) a[1,1] = polm(c(4,12,13,6,1)) a[1,2] = polm(c(-2,-5,-4,-1)) a[2,2] = polm(c(2,1)) a #> ( 2 x 2 ) matrix polynomial with degree <= 4  #>      z^0 [,1]  [,2] z^1 [,1]  [,2] z^2 [,1]  [,2] z^3 [,1]  [,2] z^4 [,1]  [,2] #> [1,]        4    -2       12    -5       13    -4        6    -1        1     0 #> [2,]        0     2        0     1        0     0        0     0        0     0 a %>% print(format = \"c\") #> ( 2 x 2 ) matrix polynomial with degree <= 4  #>                               [,1]                  [,2] #> [1,]  4 + 12z + 13z^2 + 6z^3 + z^4  -2 - 5z - 4z^2 - z^3 #> [2,]                             0                 2 + z  col_end_matrix(a) #>      [,1] [,2] #> [1,]    1   -1 #> [2,]    0    0 degree(a, \"c\") #> [1] 4 3  # Column reduction: a_red = col_reduce(a) a_red$a #> ( 2 x 2 ) matrix polynomial with degree <= 3  #>      z^0 [,1]  [,2] z^1 [,1]  [,2] z^2 [,1]  [,2] z^3 [,1]  [,2] #> [1,]       -2     0       -5     0       -4     0       -1     0 #> [2,]        2     4        1     4        0     1        0     0 a_red$a %>% print(format = \"c\") #> ( 2 x 2 ) matrix polynomial with degree <= 3  #>                       [,1]          [,2] #> [1,]  -2 - 5z - 4z^2 - z^3             0 #> [2,]                 2 + z  4 + 4z + z^2  degree(a_red$a, \"c\") #> [1] 3 2  #################################################################################  # PG, Ex 3: Unimodular matrix ########## # Result: Works, but different matrices, v_inv (U(s) in PG notation is slightly \"smaller\" here)  a = test_polm(dim = c(3,3), degree = -1) a[1,1] = polm(c(0,0,0,0,1)) a[1,2] = polm(c(0,0,1)) a[1,3] = polm(c(1,0,0,0,0,0,1)) a[2,1] = polm(c(0,0,1)) a[2,2] = polm(1) a[2,3] = polm(c(0,0,0,0,1)) a[3,1] = polm(1) a[3,3] = polm(1) a #> ( 3 x 3 ) matrix polynomial with degree <= 6  #>      z^0 [,1]  [,2]  [,3] z^1 [,1]  [,2]  [,3] z^2 [,1]  [,2]  [,3] z^3 [,1] #> [1,]        0     0     1        0     0     0        0     1     0        0 #> [2,]        0     1     0        0     0     0        1     0     0        0 #> [3,]        1     0     1        0     0     0        0     0     0        0 #>       [,2]  [,3] z^4 [,1]  [,2]  [,3] z^5 [,1]  [,2]  [,3] z^6 [,1]  [,2]  [,3] #> [1,]     0     0        1     0     0        0     0     0        0     0     1 #> [2,]     0     0        0     0     1        0     0     0        0     0     0 #> [3,]     0     0        0     0     0        0     0     0        0     0     0 a %>% print(format = \"c\") #> ( 3 x 3 ) matrix polynomial with degree <= 6  #>       [,1]  [,2]     [,3] #> [1,]   z^4   z^2  1 + z^6 #> [2,]   z^2     1      z^4 #> [3,]     1     0        1  col_end_matrix(a) #>      [,1] [,2] [,3] #> [1,]    1    1    1 #> [2,]    0    0    0 #> [3,]    0    0    0 degree(a, \"c\") #> [1] 4 2 6  # Column reduction: a_red = col_reduce(a) a_red$a #> ( 3 x 3 ) matrix polynomial with degree <= 0  #>      z^0 [,1]  [,2]  [,3] #> [1,]        0     1     0 #> [2,]        0     0     1 #> [3,]        1     1     0 a_red$a %>% print(format = \"c\") #> ( 3 x 3 ) matrix polynomial with degree <= 0  #>       [,1]  [,2]  [,3] #> [1,]     0     1     0 #> [2,]     0     0     1 #> [3,]     1     1     0  degree(a_red$a, \"c\") #> [1] 0 0 0  # Verify the column-reduced matrix time v(z) is equal to original one: with(a_red, a %r% v) %>% print(format = \"c\") #> ( 3 x 3 ) matrix polynomial with degree <= 6  #>       [,1]  [,2]     [,3] #> [1,]   z^4   z^2  1 + z^6 #> [2,]   z^2     1      z^4 #> [3,]     1     0        1  a %>% print(format = \"c\") #> ( 3 x 3 ) matrix polynomial with degree <= 6  #>       [,1]  [,2]     [,3] #> [1,]   z^4   z^2  1 + z^6 #> [2,]   z^2     1      z^4 #> [3,]     1     0        1   # Unimodular matrix transforming the column-reduced matrix to original one: a_red$v %>% print(format = \"c\") #> ( 3 x 3 ) matrix polynomial with degree <= 6  #>          [,1]  [,2]     [,3] #> [1,]  1 - z^4  -z^2     -z^6 #> [2,]      z^4   z^2  1 + z^6 #> [3,]      z^2     1      z^4   # Verify that original matrix a(z) times v^{-1}(z) is column-reduced: PRUNING NECESSARY! (a %r% a_red$v_inv) %>% print(format = \"c\") #> ( 3 x 3 ) matrix polynomial with degree <= 8  #>       [,1]                         [,2]                         [,3] #> [1,]     0  1 - 8.88178419700125e-16z^6      8.88178419700125e-16z^8 #> [2,]     0     -8.88178419700125e-16z^4  1 + 8.88178419700125e-16z^6 #> [3,]     1                            1                            0  prune(a %r% a_red$v_inv) %>% print(format = \"c\") #> ( 3 x 3 ) matrix polynomial with degree <= 0  #>       [,1]  [,2]  [,3] #> [1,]     0     1     0 #> [2,]     0     0     1 #> [3,]     1     1     0  a_red$v_inv %>% print(format = \"c\")  #> ( 3 x 3 ) matrix polynomial with degree <= 6  #>       [,1]  [,2]           [,3] #> [1,]     1     0            z^2 #> [2,]  -z^2  -z^4  1 - z^4 + z^6 #> [3,]     0     1           -z^2   #################################################################################  # PG, Ex 4: PG's \"singular case\" ########## # Result: Different results! #   If eps = 10^(-9) is chosen,  #   then this algorithm breaks down because the a[0] is recognized as singular!  #   If eps = 10^(-4) is chosen (as is done in PG),  #   we obtain a result which is different from the one in PG   # Original matrix (could be argued to be numerically singular at a[0], depending on tolerance!) a = test_polm(dim = c(3,3), degree = -1) eps = 10^(-4) a[1,1] = polm(c(0,0,1,1)) a[1,2] = polm(c(1,eps)) a[1,3] = polm(1) a[2,1] = polm(c(0,0,2)) a[2,2] = polm(-1) a[2,3] = polm(-1) a[3,1] = polm(c(0,0,3)) a[3,2] = polm(1) a[3,3] = polm(1) a #> ( 3 x 3 ) matrix polynomial with degree <= 3  #>      z^0 [,1]  [,2]  [,3] z^1 [,1]  [,2]  [,3] z^2 [,1]  [,2]  [,3] z^3 [,1] #> [1,]        0     1     1        0 1e-04     0        1     0     0        1 #> [2,]        0    -1    -1        0 0e+00     0        2     0     0        0 #> [3,]        0     1     1        0 0e+00     0        3     0     0        0 #>       [,2]  [,3] #> [1,]     0     0 #> [2,]     0     0 #> [3,]     0     0 a %>% print(format = \"c\") #> ( 3 x 3 ) matrix polynomial with degree <= 3  #>            [,1]        [,2]  [,3] #> [1,]  z^2 + z^3  1 + 1e-04z     1 #> [2,]       2z^2          -1    -1 #> [3,]       3z^2           1     1  col_end_matrix(a) #>      [,1]  [,2] [,3] #> [1,]    1 1e-04    1 #> [2,]    0 0e+00   -1 #> [3,]    0 0e+00    1 col_end_matrix(a) %>% svd() %>% .$d #> [1] 1.847759e+00 7.653669e-01 1.355253e-20 degree(a, \"c\") #> [1] 3 1 0  # Column reduction: Note that there is a column with \"small length\".  #   It depends on the tolerance whether this column is considered to be zero. #   Also, note the singular values of the column-end-matrix of the reduced polymat!      a_red = col_reduce(a) a_red$a #> ( 3 x 3 ) matrix polynomial with degree <= 2  #>      z^0 [,1]  [,2]  [,3] z^1 [,1]  [,2]  [,3] z^2 [,1]  [,2]  [,3] #> [1,]        0     1     1        0 1e-04     0    -9999     0     0 #> [2,]        0    -1    -1        0 0e+00     0    10002     0     0 #> [3,]        0     1     1        0 0e+00     0    -9997     0     0 a_red$a %>% print(format = \"c\") #> ( 3 x 3 ) matrix polynomial with degree <= 2  #>                       [,1]        [,2]  [,3] #> [1,]  -9999.00000001665z^2  1 + 1e-04z     1 #> [2,]   10002.0000000166z^2          -1    -1 #> [3,]  -9997.00000001665z^2           1     1  a_red$a %>% print(format = \"c\", digits = 3) #> ( 3 x 3 ) matrix polynomial with degree <= 2  #>           [,1]  [,2]  [,3] #> [1,]  -9999z^2     1     1 #> [2,]  10002z^2    -1    -1 #> [3,]  -9997z^2     1     1   a_red$a %>% col_end_matrix() #>       [,1]  [,2] [,3] #> [1,] -9999 1e-04    1 #> [2,] 10002 0e+00   -1 #> [3,] -9997 0e+00    1 a_red$a %>% col_end_matrix() %>% svd() %>% .$d #> [1] 1.731935e+04 3.560566e-04 8.108103e-05 a_red$a %>% degree(\"c\") #> [1] 2 1 0  # Col-reduced matrix time v(z) = original:  # It works up to a small numerical issue in the (1,1) element  with(a_red, a %r% v) %>% print(format = \"c\") #> ( 3 x 3 ) matrix polynomial with degree <= 3  #>                            [,1]        [,2]  [,3] #> [1,]  z^2 + 1.00000000000166z^3  1 + 1e-04z     1 #> [2,]                       2z^2          -1    -1 #> [3,]                       3z^2           1     1  a %>% print(format = \"c\") #> ( 3 x 3 ) matrix polynomial with degree <= 3  #>            [,1]        [,2]  [,3] #> [1,]  z^2 + z^3  1 + 1e-04z     1 #> [2,]       2z^2          -1    -1 #> [3,]       3z^2           1     1   # Check unimodular matrix taking the col-reduced matrix back to original: # Small (i.e. unproblematic) numerical issue in the (2,1)-element) which is also reflected above. a_red$v %>% print(format = \"c\") #> ( 3 x 3 ) matrix polynomial with degree <= 2  #>                      [,1]  [,2]  [,3] #> [1,]                    1     0     0 #> [2,]  10000.0000000166z^2     1     0 #> [3,]                    0     0     1   # Original times v^{-1}(z) = col-reduced: # Works fine, up to small (non-problematic) issue in (1,3)-element a_red$a %>% print(format = \"c\") #> ( 3 x 3 ) matrix polynomial with degree <= 2  #>                       [,1]        [,2]  [,3] #> [1,]  -9999.00000001665z^2  1 + 1e-04z     1 #> [2,]   10002.0000000166z^2          -1    -1 #> [3,]  -9997.00000001665z^2           1     1  (a %r% a_red$v_inv) %>% print(format = \"c\") #> ( 3 x 3 ) matrix polynomial with degree <= 3  #>                                                 [,1]        [,2]  [,3] #> [1,]  -9999.00000001665z^2 - 1.66489044772788e-12z^3  1 + 1e-04z     1 #> [2,]                             10002.0000000166z^2          -1    -1 #> [3,]                            -9997.00000001665z^2           1     1   # Matrix transforming the original to column-reduced: # Small (unproblematic) issue in (2,3)-element a_red$v_inv %>% print(format = \"c\") #> ( 3 x 3 ) matrix polynomial with degree <= 2  #>                       [,1]  [,2]  [,3] #> [1,]                     1     0     0 #> [2,]  -10000.0000000166z^2     1     0 #> [3,]                     0     0     1   # Algebraic result given in PG: Different from the one obtained here! #### # The element (3,1) of matrix R(s) in PG seems to be incorrect.  # Changing this element below results in a column-reduced matrix. eta = 1/eps  r = test_polm(dim = c(3,3), degree = -1) r[1,1] = polm(c(0,-3*eta)) r[1,2] = polm(c(1)) r[1,3] = polm(1) r[2,1] = polm(c(0,3*eta)) r[2,2] = polm(c(-1, eps)) r[2,3] = polm(-1) r[3,1] = polm(c(1,-3*eta,5)) r[3,2] = polm(c(1,-eps)) r[3,3] = polm(1) r #> ( 3 x 3 ) matrix polynomial with degree <= 2  #>      z^0 [,1]  [,2]  [,3] z^1 [,1]   [,2]  [,3] z^2 [,1]  [,2]  [,3] #> [1,]        0     1     1   -30000  0e+00     0        0     0     0 #> [2,]        0    -1    -1    30000  1e-04     0        0     0     0 #> [3,]        1     1     1   -30000 -1e-04     0        5     0     0 # PG: Col-reduced r %>% print(format = \"c\") #> ( 3 x 3 ) matrix polynomial with degree <= 2  #>                    [,1]         [,2]  [,3] #> [1,]            -30000z            1     1 #> [2,]             30000z  -1 + 1e-04z    -1 #> [3,]  1 - 30000z + 5z^2   1 - 1e-04z     1  # Here: Col-reduced a_red$a %>% print(format = \"c\") #> ( 3 x 3 ) matrix polynomial with degree <= 2  #>                       [,1]        [,2]  [,3] #> [1,]  -9999.00000001665z^2  1 + 1e-04z     1 #> [2,]   10002.0000000166z^2          -1    -1 #> [3,]  -9997.00000001665z^2           1     1   u = test_polm(dim = c(3,3), degree = -1) u[1,1] = polm(c(1)) u[1,2] = polm(c(0)) u[1,3] = polm(0) u[2,1] = polm(c(0,-3*eta,-eta)) u[2,2] = polm(c(1)) u[2,3] = polm(0) u[3,1] = polm(c(0,0,eta+2)) u[3,2] = polm(c(0,-eps)) u[3,3] = polm(1) u #> ( 3 x 3 ) matrix polynomial with degree <= 2  #>      z^0 [,1]  [,2]  [,3] z^1 [,1]   [,2]  [,3] z^2 [,1]  [,2]  [,3] #> [1,]        1     0     0        0  0e+00     0        0     0     0 #> [2,]        0     1     0   -30000  0e+00     0   -10000     0     0 #> [3,]        0     0     1        0 -1e-04     0    10002     0     0 u %>% print(format = \"c\") #> ( 3 x 3 ) matrix polynomial with degree <= 2  #>                     [,1]     [,2]  [,3] #> [1,]                   1        0     0 #> [2,]  -30000z - 10000z^2        1     0 #> [3,]            10002z^2  -1e-04z     1   # Check whether their result makes sense: # Column-reduced matrix r is different from a %r% u!!!  # This mistake can be corrected by adjusting element (3,1) of r a %>% print(format = \"c\") #> ( 3 x 3 ) matrix polynomial with degree <= 3  #>            [,1]        [,2]  [,3] #> [1,]  z^2 + z^3  1 + 1e-04z     1 #> [2,]       2z^2          -1    -1 #> [3,]       3z^2           1     1   a %r% u #> ( 3 x 3 ) matrix polynomial with degree <= 2  #>      z^0 [,1]  [,2]  [,3] z^1 [,1]   [,2]  [,3] z^2 [,1]  [,2]  [,3] #> [1,]        0     1     1   -30000  0e+00     0        0     0     0 #> [2,]        0    -1    -1    30000  1e-04     0        0     0     0 #> [3,]        0     1     1   -30000 -1e-04     0        5     0     0 (a %r% u) %>% print(format = \"c\") #> ( 3 x 3 ) matrix polynomial with degree <= 2  #>                 [,1]         [,2]  [,3] #> [1,]         -30000z            1     1 #> [2,]          30000z  -1 + 1e-04z    -1 #> [3,]  -30000z + 5z^2   1 - 1e-04z     1  (a %r% u) %>% col_end_matrix() #>      [,1]   [,2] [,3] #> [1,]    0  0e+00    1 #> [2,]    0  1e-04   -1 #> [3,]    5 -1e-04    1 (a %r% u) %>% col_end_matrix() %>% svd() %>% .$d #> [1] 5.107156e+00 1.384541e+00 7.071068e-05 (a %r% u) %>% degree(\"c\") #> [1] 2 1 0  r #> ( 3 x 3 ) matrix polynomial with degree <= 2  #>      z^0 [,1]  [,2]  [,3] z^1 [,1]   [,2]  [,3] z^2 [,1]  [,2]  [,3] #> [1,]        0     1     1   -30000  0e+00     0        0     0     0 #> [2,]        0    -1    -1    30000  1e-04     0        0     0     0 #> [3,]        1     1     1   -30000 -1e-04     0        5     0     0 r %>% print(format = \"c\") #> ( 3 x 3 ) matrix polynomial with degree <= 2  #>                    [,1]         [,2]  [,3] #> [1,]            -30000z            1     1 #> [2,]             30000z  -1 + 1e-04z    -1 #> [3,]  1 - 30000z + 5z^2   1 - 1e-04z     1   ######################### # Change an element in r r2 = r r2[3,1] = polm(c(0,-3*eta,5)) r2 %>% print(format = \"c\") #> ( 3 x 3 ) matrix polynomial with degree <= 2  #>                 [,1]         [,2]  [,3] #> [1,]         -30000z            1     1 #> [2,]          30000z  -1 + 1e-04z    -1 #> [3,]  -30000z + 5z^2   1 - 1e-04z     1  r2 %>% col_end_matrix() #>      [,1]   [,2] [,3] #> [1,]    0  0e+00    1 #> [2,]    0  1e-04   -1 #> [3,]    5 -1e-04    1 r2 %>% col_end_matrix() %>% svd() %>% .$d #> [1] 5.107156e+00 1.384541e+00 7.071068e-05 r2 %>% col_end_matrix() %>% rkM() #> [1] 3 r2 %>% degree(\"c\") #> [1] 2 1 0  (a %r% u) %>% print(format = \"c\") #> ( 3 x 3 ) matrix polynomial with degree <= 2  #>                 [,1]         [,2]  [,3] #> [1,]         -30000z            1     1 #> [2,]          30000z  -1 + 1e-04z    -1 #> [3,]  -30000z + 5z^2   1 - 1e-04z     1     #################################################################################  # PG, Ex 5: Breaks down in PG, but they give an algebraic solution ########## # Result: Works here!  #  Different result as algebraic solution indicated in PG (up to column permutation). #  Of course, the obtained result is also column-reduced! #  The unimodular matrix (which column-reduces the original polynomial matrix) is different   a = test_polm(dim = c(4,4), degree = -1) eps = 10^(-9) a[1,1] = polm(c(1,1,1)) a[1,2] = polm(c(0,eps)) a[1,3] = polm(c(0,0,0,1)) a[1,4] = polm(c(1,0,0,1)) a[2,1] = polm(c(0,2)) a[2,2] = polm(0) a[2,3] = polm(c(1,0,0,2)) a[2,4] = a[2,3] a[3,1] = polm(c(1,3)) a[3,2] = polm(3) a[3,3] = polm(c(3,0,3)) a[3,4] = a[3,3] a[4,1] = polm(c(0,4)) a[4,2] = polm(c(0)) a[4,3] = polm(c(1,0,0,4)) a[4,4] = a[4,3] a #> ( 4 x 4 ) matrix polynomial with degree <= 3  #>      z^0 [,1]  [,2]  [,3]  [,4] z^1 [,1]  [,2]  [,3]  [,4] z^2 [,1]  [,2]  [,3] #> [1,]        1     0     0     1        1 1e-09     0     0        1     0     0 #> [2,]        0     0     1     1        2 0e+00     0     0        0     0     0 #> [3,]        1     3     3     3        3 0e+00     0     0        0     0     3 #> [4,]        0     0     1     1        4 0e+00     0     0        0     0     0 #>       [,4] z^3 [,1]  [,2]  [,3]  [,4] #> [1,]     0        0     0     1     1 #> [2,]     0        0     0     2     2 #> [3,]     3        0     0     0     0 #> [4,]     0        0     0     4     4  # Original matrix, its column-end-matrix with its singular values, and its column degrees a %>% print(format = \"c\") #> ( 4 x 4 ) matrix polynomial with degree <= 3  #>              [,1]    [,2]      [,3]      [,4] #> [1,]  1 + z + z^2  1e-09z       z^3   1 + z^3 #> [2,]           2z       0  1 + 2z^3  1 + 2z^3 #> [3,]       1 + 3z       3  3 + 3z^2  3 + 3z^2 #> [4,]           4z       0  1 + 4z^3  1 + 4z^3  col_end_matrix(a) #>      [,1]  [,2] [,3] [,4] #> [1,]    1 1e-09    1    1 #> [2,]    0 0e+00    2    2 #> [3,]    0 0e+00    0    0 #> [4,]    0 0e+00    4    4 col_end_matrix(a) %>% svd() %>% .$d #> [1] 6.484499e+00 9.753345e-01 5.849050e-25 0.000000e+00 col_end_matrix(a) %>% rkM() #> [1] 2 degree(a, \"c\") #> [1] 2 1 3 3  # Column-reduction: a_red = col_reduce(a) a_red$a #> ( 4 x 4 ) matrix polynomial with degree <= 1  #>      z^0 [,1]  [,2]  [,3]  [,4] z^1 [,1]  [,2]  [,3]  [,4] #> [1,]        1     0     1     0        1     0     0     0 #> [2,]        0     0     0     1        2     0     0     0 #> [3,]        1     3     0     3        3     0     0     0 #> [4,]        0     0     0     1        4     0     0     0 a_red$a %>% print(format = \"c\") #> ( 4 x 4 ) matrix polynomial with degree <= 1  #>         [,1]  [,2]  [,3]  [,4] #> [1,]   1 + z     0     1     0 #> [2,]      2z     0     0     1 #> [3,]  1 + 3z     3     0     3 #> [4,]      4z     0     0     1  col_end_matrix(a_red$a) #>      [,1] [,2] [,3] [,4] #> [1,]    1    0    1    0 #> [2,]    2    0    0    1 #> [3,]    3    3    0    3 #> [4,]    4    0    0    1 col_end_matrix(a_red$a) %>% svd() %>% .$d #> [1] 6.5378222 2.6726142 0.9977857 0.3441475 degree(a_red$a, \"c\") #> [1] 1 0 0 0  # Check whether col-reduced matrix times unimodular v(z) = original: # Works with small (non-problematic) numerical mistakes. # Brutal pruning \"solves\" it # Similar for the unimodular matrix v(z) itself with(a_red, a %r% v) %>% print(format = \"c\") #> ( 4 x 4 ) matrix polynomial with degree <= 3  #>              [,1]  [,2]                                                   [,3]                                                       [,4] #> [1,]  1 + z + z^2     0  1.30185189290517e-16z - 5.35948625484577e-16z^2 + z^3  1 + 1.30185189290517e-16z - 5.35948625484577e-16z^2 + z^3 #> [2,]           2z     0                     1 + 2.60370378581034e-16z^2 + 2z^3                         1 + 2.60370378581034e-16z^2 + 2z^3 #> [3,]       1 + 3z     3                       3 + 1.30185189290517e-16z + 3z^2                           3 + 1.30185189290517e-16z + 3z^2 #> [4,]           4z     0                     1 + 5.20740757162067e-16z^2 + 4z^3                         1 + 5.20740757162067e-16z^2 + 4z^3  with(a_red, a %r% v) %>% prune(brutal = TRUE) %>% print(format = \"c\") #> ( 4 x 4 ) matrix polynomial with degree <= 3  #>              [,1]  [,2]      [,3]      [,4] #> [1,]  1 + z + z^2     0       z^3   1 + z^3 #> [2,]           2z     0  1 + 2z^3  1 + 2z^3 #> [3,]       1 + 3z     3  3 + 3z^2  3 + 3z^2 #> [4,]           4z     0  1 + 4z^3  1 + 4z^3  a_red$v %>% print(format = \"c\") #> ( 4 x 4 ) matrix polynomial with degree <= 3  #>       [,1]  [,2]                            [,3]                               [,4] #> [1,]     1     0     1.30185189290517e-16z + z^2        1.30185189290517e-16z + z^2 #> [2,]     0     1      0.666666666666667z^2 - z^3         0.666666666666667z^2 - z^3 #> [3,]   z^2     0  -z^2 + 1.92296268638356e-16z^3  1 - z^2 + 1.92296268638356e-16z^3 #> [4,]     0     0                               1                                  1  a_red$v %>% prune(brutal = TRUE) %>% print(format = \"c\") #> ( 4 x 4 ) matrix polynomial with degree <= 3  #>       [,1]  [,2]                        [,3]                        [,4] #> [1,]     1     0                         z^2                         z^2 #> [2,]     0     1  0.666666666666667z^2 - z^3  0.666666666666667z^2 - z^3 #> [3,]   z^2     0                        -z^2                     1 - z^2 #> [4,]     0     0                           1                           1   # Check whether original times v^{-1}(z) = col-reduced: # Same as above: non-problematic numerical mistakes, \"solved\" by brutally pruning # Same for unimodular v^{-1}(z) (a %r% a_red$v_inv) %>% print(format = \"c\") #> ( 4 x 4 ) matrix polynomial with degree <= 4  #>                                  [,1]    [,2]  [,3]                                                                                                  [,4] #> [1,]  1 + z - 4.44089209850063e-16z^2  1e-09z     1  -1.30185189290517e-16z + 5.35948625484577e-16z^2 - 6.66666943871519e-10z^3 + 1.00000052682958e-09z^4 #> [2,]                               2z       0     0                                                                           1 - 2.60370378581034e-16z^2 #> [3,]                           1 + 3z       3     0                         3 - 1.30185189290517e-16z - 4.44089209850063e-16z^2 + 2.22044604925031e-16z^4 #> [4,]                               4z       0     0                                                                           1 - 5.20740757162067e-16z^2  (a %r% a_red$v_inv) %>% prune(brutal = TRUE) %>% print(format = \"c\") #> ( 4 x 4 ) matrix polynomial with degree <= 1  #>         [,1]  [,2]  [,3]  [,4] #> [1,]   1 + z     0     1     0 #> [2,]      2z     0     0     1 #> [3,]  1 + 3z     3     0     3 #> [4,]      4z     0     0     1  a_red$a %>% print(format = \"c\") #> ( 4 x 4 ) matrix polynomial with degree <= 1  #>         [,1]  [,2]  [,3]  [,4] #> [1,]   1 + z     0     1     0 #> [2,]      2z     0     0     1 #> [3,]  1 + 3z     3     0     3 #> [4,]      4z     0     0     1  a_red$v_inv %>% print(format = \"c\") #> ( 4 x 4 ) matrix polynomial with degree <= 4  #>       [,1]  [,2]  [,3]                                     [,4] #> [1,]     1     0     0             -1.30185189290517e-16z - z^2 #> [2,]     0     1     0              -0.666666666666667z^2 + z^3 #> [3,]   z^2     0    -1  1 - z^2 + 6.21110793478396e-17z^3 - z^4 #> [4,]  -z^2     0     1      z^2 - 6.21110793478396e-17z^3 + z^4  a_red$v_inv %>% prune(brutal = TRUE) %>% print(format = \"c\") #> ( 4 x 4 ) matrix polynomial with degree <= 4  #>       [,1]  [,2]  [,3]                         [,4] #> [1,]     1     0     0                         -z^2 #> [2,]     0     1     0  -0.666666666666667z^2 + z^3 #> [3,]   z^2     0    -1                1 - z^2 - z^4 #> [4,]  -z^2     0     1                    z^2 + z^4   # Krishnarao and Chen example #####################  (a = polm(array(c(4,0,-2,2,                     12, 0, -5, 1,                       13,0,1,0,                      2,0,0,0), dim = c(2,2,4)))) #> ( 2 x 2 ) matrix polynomial with degree <= 3  #>      z^0 [,1]  [,2] z^1 [,1]  [,2] z^2 [,1]  [,2] z^3 [,1]  [,2] #> [1,]        4    -2       12    -5       13     1        2     0 #> [2,]        0     2        0     1        0     0        0     0 out = col_reduce(a) out$a #> ( 2 x 2 ) matrix polynomial with degree <= 2  #>      z^0 [,1]  [,2] z^1 [,1]  [,2] z^2 [,1]  [,2] #> [1,]       -2     4       -5    16        1    23 #> [2,]        2     0        1    -4        0    -2 a %r% out$v_inv #> ( 2 x 2 ) matrix polynomial with degree <= 2  #>      z^0 [,1]  [,2] z^1 [,1]  [,2] z^2 [,1]  [,2] #> [1,]       -2     4       -5    16        1    23 #> [2,]        2     0        1    -4        0    -2 with(out, a %r% v) #> ( 2 x 2 ) matrix polynomial with degree <= 3  #>      z^0 [,1]  [,2] z^1 [,1]  [,2] z^2 [,1]  [,2] z^3 [,1]  [,2] #> [1,]        4    -2       12    -5       13     1        2     0 #> [2,]        0     2        0     1        0     0        0     0  # Majid: Ex 3 ################  (m0 = matrix(c(-3,1,0, 2,2,0,   0,3,2), nrow = 3, byrow = TRUE)) #>      [,1] [,2] [,3] #> [1,]   -3    1    0 #> [2,]    2    2    0 #> [3,]    0    3    2 (m1 = matrix(c(0,0,2,   4,0,0,   0,1,-3), nrow = 3, byrow = TRUE)) #>      [,1] [,2] [,3] #> [1,]    0    0    2 #> [2,]    4    0    0 #> [3,]    0    1   -3 (m2 = matrix(c(1,0,0,   0,0,0,   -1,0,0), nrow = 3, byrow = TRUE)) #>      [,1] [,2] [,3] #> [1,]    1    0    0 #> [2,]    0    0    0 #> [3,]   -1    0    0 m = polm(array(c(m0,m1,m2), dim = c(3,3,3))) m %>% print(format = \"c\") #> ( 3 x 3 ) matrix polynomial with degree <= 2  #>           [,1]   [,2]    [,3] #> [1,]  -3 + z^2      1      2z #> [2,]    2 + 4z      2       0 #> [3,]      -z^2  3 + z  2 - 3z  m %>% col_end_matrix() #>      [,1] [,2] [,3] #> [1,]    1    0    2 #> [2,]    0    0    0 #> [3,]   -1    1   -3 m %>% col_end_matrix() %>% svd() %>% .$d #> [1] 3.9516798 0.6198604 0.0000000 m %>% degree(\"c\") #> [1] 2 1 1  (out = col_reduce(m)) #> $a #> ( 3 x 3 ) matrix polynomial with degree <= 1  #>      z^0 [,1]  [,2]  [,3] z^1 [,1]  [,2]  [,3] #> [1,]        1     0    -3        0     2  -0.5 #> [2,]        2     0     2        0     0   3.0 #> [3,]        3     2     0        1    -3  -2.5 #>  #> $v #> ( 3 x 3 ) matrix polynomial with degree <= 1  #>      z^0 [,1]  [,2]  [,3] z^1 [,1]  [,2]  [,3] #> [1,]        0     1     0      0.5     0     0 #> [2,]        0     0     1      0.5     0     0 #> [3,]        1     0     0      0.0     0     0 #>  #> $v_inv #> ( 3 x 3 ) matrix polynomial with degree <= 1  #>      z^0 [,1]  [,2]  [,3] z^1 [,1]  [,2]  [,3] #> [1,]        0     0     1        0     0   0.0 #> [2,]        1     0     0        0     0  -0.5 #> [3,]        0     1     0        0     0  -0.5 #>  #> $col_degrees #> [1] 1 1 1 #>  #> $col_end_matrix #>      [,1] [,2] [,3] #> [1,]    0    2 -0.5 #> [2,]    0    0  3.0 #> [3,]    1   -3 -2.5 #>    # Majid: Ex 4 ################3 (m0 = matrix(c(1,0,   0,1), nrow = 2, byrow = TRUE)) #>      [,1] [,2] #> [1,]    1    0 #> [2,]    0    1 (m1 = matrix(c(0,0,   2,0), nrow = 2, byrow = TRUE)) #>      [,1] [,2] #> [1,]    0    0 #> [2,]    2    0 (m2 = matrix(c(1,1,   0,0), nrow = 2, byrow = TRUE)) #>      [,1] [,2] #> [1,]    1    1 #> [2,]    0    0 (m3 = matrix(c(2,0,   0,0), nrow = 2, byrow = TRUE)) #>      [,1] [,2] #> [1,]    2    0 #> [2,]    0    0 m = polm(array(c(m0,m1,m2,m3), dim = c(2,2,4))) m %>% print(format = \"c\") #> ( 2 x 2 ) matrix polynomial with degree <= 3  #>                 [,1]  [,2] #> [1,]  1 + z^2 + 2z^3   z^2 #> [2,]              2z     1  m %>% col_end_matrix() #>      [,1] [,2] #> [1,]    2    1 #> [2,]    0    0 m %>% col_end_matrix() %>% svd() %>% .$d #> [1] 2.236068 0.000000 m %>% degree(\"c\") #> [1] 3 2  (out = col_reduce(m)) #> $a #> ( 2 x 2 ) matrix polynomial with degree <= 2  #>      z^0 [,1]  [,2] z^1 [,1]  [,2] z^2 [,1]  [,2] #> [1,]        0     1        0     0        1     0 #> [2,]        1    -1        0     0        0     0 #>  #> $v #> ( 2 x 2 ) matrix polynomial with degree <= 1  #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]        1     1        2     0 #> [2,]        1     0        0     0 #>  #> $v_inv #> ( 2 x 2 ) matrix polynomial with degree <= 1  #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]        0     1        0     0 #> [2,]        1    -1        0    -2 #>  #> $col_degrees #> [1] 2 0 #>  #> $col_end_matrix #>      [,1] [,2] #> [1,]    1    1 #> [2,]    0   -1 #>"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/companion_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Companion Matrix of a Polynomial Matrix — companion_matrix","title":"Companion Matrix of a Polynomial Matrix — companion_matrix","text":"Computes companion matrix square (\\(m,m)\\)-dimensional), matrix polynomial  $$(z) = a_0 + a_1 z + \\cdots + a_p z^p$$ companion matrix e.g. used determine zeroes polynomial matrix, see zeroes.   Note function throws error, constant term \\(a_0\\) singular. check whether leading coefficients zero.  results \\((mp,mp)\\)-dimensional matrix, even \\(a_p\\) zero.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/companion_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Companion Matrix of a Polynomial Matrix — companion_matrix","text":"","code":"companion_matrix(a)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/companion_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Companion Matrix of a Polynomial Matrix — companion_matrix","text":"square polynomial matrix, .e. object class polm.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/companion_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Companion Matrix of a Polynomial Matrix — companion_matrix","text":"(companion) matrix dimensions \\((mp,mp)\\).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/companion_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Companion Matrix of a Polynomial Matrix — companion_matrix","text":"","code":"companion_matrix(polm(c(1,0,0,0.5,0))) # scalar polynomial #>      [,1] [,2] [,3] [,4] #> [1,]    0    0 -0.5    0 #> [2,]    1    0  0.0    0 #> [3,]    0    1  0.0    0 #> [4,]    0    0  1.0    0 companion_matrix(polm(diag(3)))        # zero degree polynomial  #> <0 x 0 matrix> companion_matrix(polm(dbind(d = 3, diag(2), -test_array(dim = c(2,2,1))))) #>      [,1] [,2] #> [1,]  111  121 #> [2,]  211  221 companion_matrix(polm(dbind(d = 3, diag(2), -test_array(dim = c(2,2,2))))) #>      [,1] [,2] [,3] [,4] #> [1,]  111  121  112  122 #> [2,]  211  221  212  222 #> [3,]    1    0    0    0 #> [4,]    0    1    0    0  if (FALSE) { # the following examples throw an error companion_matrix(polm(c(0,0,0,0.5))) # constant term is zero companion_matrix(polm(test_array(dim = c(2,1,3)))) # non-square polynomial companion_matrix(polm(test_array(dim = c(2,2,0)))) # zero polynomial }"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/convolve_3D.html","id":null,"dir":"Reference","previous_headings":"","what":"Convolution of Matrix-valued Sequences — convolve_3D","title":"Convolution of Matrix-valued Sequences — convolve_3D","text":"Compute convolution two (matrix valued) sequences  \\(a_0, a_1, \\ldots\\)   \\(b_0, b_1, \\ldots\\), .e.  $$c_k = \\sum_{j=0}^{k} a_j b_{k-j}$$","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/convolve_3D.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convolution of Matrix-valued Sequences — convolve_3D","text":"","code":"convolve_3D(a, b, truncate = FALSE)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/convolve_3D.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convolution of Matrix-valued Sequences — convolve_3D","text":"3D array dimension (m,n,p+1) b 3D array dimension (n,o,q+1) truncate (boolean) TRUE output sequence  length \\(\\min(p,q)+1\\),  otherwise sequence length \\(p+q+1\\).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/convolve_3D.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convolution of Matrix-valued Sequences — convolve_3D","text":"3D array dimension (m,o,r+1), r=p+q  truncate==FALSE r = min(p,q) otherwise.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/reference/convolve_3D.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convolution of Matrix-valued Sequences — convolve_3D","text":"","code":"a = test_array(dim = c(3,2,2), random = TRUE) b = test_array(dim = c(2,1,3), random = TRUE) convolve_3D(a,b) #> , , 1 #>  #>             [,1] #> [1,] -0.04573248 #> [2,] -1.16752041 #> [3,] -0.19858214 #>  #> , , 2 #>  #>            [,1] #> [1,]  0.1942967 #> [2,] -1.7620809 #> [3,]  0.1544305 #>  #> , , 3 #>  #>           [,1] #> [1,] 0.3459509 #> [2,] 0.8085344 #> [3,] 0.4368286 #>  #> , , 4 #>  #>             [,1] #> [1,] -0.26982911 #> [2,] -0.49584090 #> [3,]  0.01477829 #>  convolve_3D(a,b,TRUE) #> , , 1 #>  #>             [,1] #> [1,] -0.04573248 #> [2,] -1.16752041 #> [3,] -0.19858214 #>  #> , , 2 #>  #>            [,1] #> [1,]  0.1942967 #> [2,] -1.7620809 #> [3,]  0.1544305 #>"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/ctr_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Controllability and Observability Matrix — ctr_matrix","title":"Controllability and Observability Matrix — ctr_matrix","text":"controllability matrix statespace realisation \\(k(z)=C(-Az^{-1})^{-1}B + D\\)  matrix $$ [B,AB,\\dots,^{o-1}B] $$ observability matrix  $$ [C','C',\\dots,(')^{o-1}C']' $$","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/ctr_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Controllability and Observability Matrix — ctr_matrix","text":"","code":"ctr_matrix(A, B, o = NULL)  obs_matrix(A, C, o = NULL)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/ctr_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Controllability and Observability Matrix — ctr_matrix","text":"either stsp object square \\((s,s)\\) dimensional matrix. B \\((s,n)\\) dimensional matrix. argument ignored  stsp object. o (non negative) integer. default value \\(o=s\\). C \\((m,s)\\) dimensional matrix. argument ignored  stsp object.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/ctr_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Controllability and Observability Matrix — ctr_matrix","text":"Controllability observability matrix.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/dbind.html","id":null,"dir":"Reference","previous_headings":"","what":"Bind Arrays — dbind","title":"Bind Arrays — dbind","text":"dbind(d, x, y, ...) concatenates/binds arbitrary number arrays x, y,... along dimension d. matrices, dbind(d = 1, x, y, ...) (essentially) equivalent rbind dbind(d = 2, x, y, ...) corresponds cbind. number dimensions argument, x say,  less d, argument treated array dimension c(dim(x),1,..,1).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/dbind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bind Arrays — dbind","text":"","code":"dbind(d = 1, ...)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/dbind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bind Arrays — dbind","text":"d Integer. Concatenate arrays along dimension d. ... arrays.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/dbind.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bind Arrays — dbind","text":"Array","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/dbind.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bind Arrays — dbind","text":"procedure makes effort keep dimnames attribute arguments.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/dbind.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bind Arrays — dbind","text":"","code":"x = test_array(dim = c(2,3,1)) y = test_array(dim = c(2,3,1), dimnames = TRUE) z = test_array(dim = c(2,3,3), dimnames = TRUE)  # Bind along dimension 1 (row-binding for matrices) dbind(1, x) #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,]  111  121  131 #> [2,]  211  221  231 #>  dbind(1, x, y) #> , , C = C=1 #>  #>       B #> A      B=1 B=2 B=3 #>   [1,] 111 121 131 #>   [2,] 211 221 231 #>   [3,] 111 121 131 #>   [4,] 211 221 231 #>   # Bind along dimension 2 (col-binding for matrices) dbind(2, x, y) #> , , C = C=1 #>  #>      B #> A     [,1] [,2] [,3] [,4] [,5] [,6] #>   A=1  111  121  131  111  121  131 #>   A=2  211  221  231  211  221  231 #>   # Bind along dimension 3 dbind(3, x, y) #> , , 1 #>  #>      B #> A     B=1 B=2 B=3 #>   A=1 111 121 131 #>   A=2 211 221 231 #>  #> , , 2 #>  #>      B #> A     B=1 B=2 B=3 #>   A=1 111 121 131 #>   A=2 211 221 231 #>  dbind(3, x, y, z) #> , , 1 #>  #>      B #> A     B=1 B=2 B=3 #>   A=1 111 121 131 #>   A=2 211 221 231 #>  #> , , 2 #>  #>      B #> A     B=1 B=2 B=3 #>   A=1 111 121 131 #>   A=2 211 221 231 #>  #> , , 3 #>  #>      B #> A     B=1 B=2 B=3 #>   A=1 111 121 131 #>   A=2 211 221 231 #>  #> , , 4 #>  #>      B #> A     B=1 B=2 B=3 #>   A=1 112 122 132 #>   A=2 212 222 232 #>  #> , , 5 #>  #>      B #> A     B=1 B=2 B=3 #>   A=1 113 123 133 #>   A=2 213 223 233 #>   # Example that throws an error if (FALSE) { dbind(1, x, y, z) # throws an error, since the array x,y,z are not compatible }"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/default_colmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Default Color Palette — default_colmap","title":"Default Color Palette — default_colmap","text":"Default color palette.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/default_colmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Default Color Palette — default_colmap","text":"","code":"default_colmap(n)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/default_colmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Default Color Palette — default_colmap","text":"n integer","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/default_colmap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Default Color Palette — default_colmap","text":"(character) vector length n color codes (\"#RRGGBB\").","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/default_colmap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Default Color Palette — default_colmap","text":"","code":"default_colmap(3) #> [1] \"#F8766D\" \"#00BA38\" \"#619CFF\""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/degree.html","id":null,"dir":"Reference","previous_headings":"","what":"Polynomial Degree — degree","title":"Polynomial Degree — degree","text":"Compute polynomial degrees (elements) polynomial matrix.  Note (scalar) polynomial zero coefficients degree  set \\(-1\\).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/degree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Polynomial Degree — degree","text":"","code":"degree(x, which = c(\"elements\", \"rows\", \"columns\", \"matrix\"))"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/degree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Polynomial Degree — degree","text":"x polynomial matrix, .e. object class polm. (character string) decides whether matrix respectives degrees  entries matrix, vector respective maximal  degrees row column, simply maximum degree  elements polynomial matrix computed.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/degree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Polynomial Degree — degree","text":"outcome depends parameter : elements matrix degrees respective elements                 polynomial matrix. rows vector maximum degrees within row. columns vector maximum degrees within column. matrix maximum degrees elements matrix.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/degree.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Polynomial Degree — degree","text":"main advantage setting degree zero polynomial \\(-1\\) rather -Inf indexing assigning programmatically easier:  E.g., p[,,(deg+2):(max_deg+1)] = 0 (obvious notation) also works deg = -1. multiplying zero polynomials, make difference whether one needs check deg = -Inf deg = -1.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/degree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Polynomial Degree — degree","text":"","code":"x = polm(array(c(0,1,1,0,                  0,0,1,0,                  0,0,0,1,                  0,0,0,0), dim = c(2,2,4))) x #> ( 2 x 2 ) matrix polynomial with degree <= 3  #>      z^0 [,1]  [,2] z^1 [,1]  [,2] z^2 [,1]  [,2] z^3 [,1]  [,2] #> [1,]        0     1        0     1        0     0        0     0 #> [2,]        1     0        0     0        0     1        0     0 degree(x) #>      [,1] [,2] #> [1,]   -1    1 #> [2,]    0    2 degree(x, 'rows') #> [1] 1 2 degree(x, 'columns') #> [1] 0 2 degree(x, 'matrix') #> [1] 2"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/derivative.html","id":null,"dir":"Reference","previous_headings":"","what":"Derivative of a rational Matrix — derivative","title":"Derivative of a rational Matrix — derivative","text":"Computes derivative rational matrix \\(k(z)\\) (repect complex variable \\(z\\)).  Note computing derivative impulse response object decreases number lags one!","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/derivative.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Derivative of a rational Matrix — derivative","text":"","code":"derivative(obj, ...)  # S3 method for lpolm derivative(obj, ...)  # S3 method for polm derivative(obj, ...)  # S3 method for lmfd derivative(obj, ...)  # S3 method for rmfd derivative(obj, ...)  # S3 method for stsp derivative(obj, ...)  # S3 method for pseries derivative(obj, ...)  # S3 method for zvalues derivative(obj, ...)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/derivative.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Derivative of a rational Matrix — derivative","text":"obj object class polm,  stsp  pseries. ... used","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/derivative.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Derivative of a rational Matrix — derivative","text":"object class argument obj","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/derivative.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Derivative of a rational Matrix — derivative","text":"","code":"# create random (3 by 2) polynomial matrix with degree 2 K = test_polm(dim = c(3,2), degree = 2) derivative(K) #> ( 3 x 2 ) matrix polynomial with degree <= 1  #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]      111   121      224   244 #> [2,]      211   221      424   444 #> [3,]      311   321      624   644 derivative(derivative(K)) #> ( 3 x 2 ) matrix polynomial with degree <= 0  #>      z^0 [,1]  [,2] #> [1,]      224   244 #> [2,]      424   444 #> [3,]      624   644 derivative(derivative(derivative(K))) #> ( 3 x 2 ) matrix polynomial with degree <= -1   # note: computing the derivative of the impulse response  # decreases \"lag.max\" by one! all.equal(pseries(derivative(K)), derivative(pseries(K, lag.max = 6))) #> [1] TRUE  # create statespace realization of a random (3 by 2) rational matrix # with statespace dimension s = 4 K = test_stsp(dim = c(2,2), s = 4, bpoles = 1) all.equal(pseries(derivative(K)), derivative(pseries(K, lag.max = 6))) #> [1] TRUE  if (FALSE) { # 'lmfd' objects and 'zvalues' objects are not supported derivative(test_lmfd(dim = c(3,3), degrees = c(1,1))) derivative(zvalues(K)) }"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/dim.html","id":null,"dir":"Reference","previous_headings":"","what":"Dimensions of Objects — dim methods","title":"Dimensions of Objects — dim methods","text":"Retrieve dimension degrees rational matrix objects.  E.g. polynomial matrix \\(x(z)\\) (.e. polm object), dim(x) returns vector  c(m,n,p),  m,n respective number rows columns matrix p (polynomial) degree matrix.  Laurent polynomial, additional element vector c(m,n,p,min_deg) returned dim(x) pertaining (possibly negative) minimal degree.  rational matrix RMFD form \\(x(z)=d(z)c^{-1}(z)\\) (.e. rmfd object), dim(x) returns vector c(m,n,p,q), m,n respective number rows columns matrix  p,q (polynomial) degrees polynomial matrices \\(c(z)\\) \\(d(z)\\) respectively.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/dim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dimensions of Objects — dim methods","text":"","code":"# S3 method for polm dim(x)  # S3 method for lpolm dim(x)  # S3 method for lmfd dim(x)  # S3 method for rmfd dim(x)  # S3 method for stsp dim(x)  # S3 method for pseries dim(x)  # S3 method for zvalues dim(x)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/dim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dimensions of Objects — dim methods","text":"x Object type polm, lmfd,  rmfd, stsp, pseries,  zvalues.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/dim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dimensions of Objects — dim methods","text":"Returns named vector integers (m,n always refer number          rows columns rational matrix) c(m,n,p,min_deg Laurent polynomial matrices    (.e. lpolm objects). c(m,n,p) polynomial matrices    (.e. polm objects). c(m,n,p,q) left matrix fraction descriptions    (.e. lmfd objects). c(m,n,p,q) right matrix fraction descriptions    (.e. rmfd objects). c(m,n,s) state space representations    (.e. stsp objects). c(m,n,lag.max) power series expansions     (.e. pseries objects). c(m,n,n.f) frequency response functions    (.e. zvalues objects).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/extract.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Parts of a Rational Matrix — extract","title":"Extract Parts of a Rational Matrix — extract","text":"subsetting operation x[,] rational matrices works analogously subsetting  ordinary matrices. However, operator partly implemented  lmfd lmfd objects. See details .  $ operator may used extract polynomial factors left/right  matrix fraction description (lmfd, rmfd object). Furthermore   one may retrieve parameter matrices \\(,B,C,D\\) state space representation  (stsp object). zvalues object, may  access complex numbers rational matrix evaluated.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/extract.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Parts of a Rational Matrix — extract","text":"","code":"# S3 method for polm [(x, i, j)  # S3 method for lpolm [(x, i, j)  # S3 method for lmfd [(x, i, j)  # S3 method for rmfd [(x, i, j)  # S3 method for stsp [(x, i, j)  # S3 method for pseries [(x, i, j)  # S3 method for zvalues [(x, i, j)  # S3 method for lmfd $(x, name)  # S3 method for rmfd $(x, name)  # S3 method for stsp $(x, name)  # S3 method for zvalues $(x, name)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/extract.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Parts of a Rational Matrix — extract","text":"x rational matrix, .e. polm, lpolm,  lmfd, rmfd, stsp,  pseries zvalues object. , j indices (integer boolean vector) name character: ,B,C,D stsp objects,  ,b lmfd objects,  c,d rmfd objects  z,f zvalues objects.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/extract.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Parts of a Rational Matrix — extract","text":"subsetting operation x[,j] returns rational matrix class  input x. mode output $ operator depends  \"component\" rational matrix extracted. See details .","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/extract.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract Parts of a Rational Matrix — extract","text":"x[] x[,] simply return original object. x[] returns \"vector\", .e. \\((s,1)\\) dimensional matrix. x[,], x[,j] x[,j] return rational matrix        rows selected columns selected j. Note: lmfd objects (rmfd objects)        extraction columns (respectively rows) implemented. Therefore,        e.g. x[,] throws error x lmfd object. Note \"named\" arguments supported (order simplify coding). order finer control, one may e.g. use unclass(x)[,,]. x$, x$b returns left, respectively right factor        LMFD \\(x(z) = ^{-1}(z)b(z)\\). (x lmfd object). x$c, x$d returns right, respectively left factor        RMFD  \\(x(z) = d(z)c^{-1}(z)\\). (x rmfd object.) x$, x$B, x$C, x$D return        parameter matrices statespace realization         \\(x(z) = D + z (- Az)^{-1}B\\). (x stsp object.) x zvalues object,        x$z returns vector complex points        rational matrix \\(x\\) evaluated. Furthermore x$f gives        corresponding \"frequencies\", .e. x$f = -Arg(x$z)/(2*pi).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/extract.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Parts of a Rational Matrix — extract","text":"","code":"# polynomial matrices  a = test_polm(dim = c(3,2), degree = 1) a[]          # returns a #> ( 3 x 2 ) matrix polynomial with degree <= 1  #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]      110   120      111   121 #> [2,]      210   220      211   221 #> [3,]      310   320      311   321 a[,]         # returns a #> ( 3 x 2 ) matrix polynomial with degree <= 1  #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]      110   120      111   121 #> [2,]      210   220      211   221 #> [3,]      310   320      311   321 a[c(1,3,6)]  # returns a \"vector\" with the (1,1), (3,1) and (3,2) element of a #> ( 3 x 1 ) matrix polynomial with degree <= 1  #>      z^0 [,1] z^1 [,1] #> [1,]      110      111 #> [2,]      310      311 #> [3,]      320      321 a[1,]        # returns the first row of a  #> ( 1 x 2 ) matrix polynomial with degree <= 1  #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]      110   120      111   121 a[,2]        # returns the second column of a  #> ( 3 x 1 ) matrix polynomial with degree <= 1  #>      z^0 [,1] z^1 [,1] #> [1,]      120      121 #> [2,]      220      221 #> [3,]      320      321 a[c(TRUE,FALSE,TRUE),c(FALSE, TRUE)] # returns a 2 by 1 matrix  #> ( 2 x 1 ) matrix polynomial with degree <= 1  #>      z^0 [,1] z^1 [,1] #> [1,]      120      121 #> [2,]      320      321 a[c(1,1),c(2,1)] # returns a 2 by 2 matrix  #> ( 2 x 2 ) matrix polynomial with degree <= 1  #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]      120   110      121   111 #> [2,]      120   110      121   111 # check with pseries/zvalues all.equal(pseries(a[c(1,1),c(2,1)]), pseries(a)[c(1,1),c(2,1)]) #> [1] TRUE all.equal(zvalues(a[c(1,1),c(2,1)]), zvalues(a)[c(1,1),c(2,1)]) #> [1] TRUE  if (FALSE) { a[i=1, j=2] # throws an error, since \"named\" arguments are not allowed. }  # the subsetting operator [,] is only implemented for \"lmfd\" columns (l = test_lmfd(dim = c(2,2), degrees = c(1,1))) #> ( 2 x 2 ) left matrix fraction description a^(-1)(z) b(z) with degrees (p = 1, q = 1) #> left factor a(z): #>      z^0 [,1]  [,2]  z^1 [,1]       [,2] #> [1,]        1     0 -0.508120  1.1940164 #> [2,]        0     1  1.522162 -0.3834481 #> right factor b(z): #>       z^0 [,1]       [,2]   z^1 [,1]        [,2] #> [1,] 0.1037656 -0.6731001  0.3615888 -0.07595836 #> [2,] 0.5933128 -0.4091040 -0.5718296 -0.15546109 l[,1] #> ( 2 x 1 ) left matrix fraction description a^(-1)(z) b(z) with degrees (p = 1, q = 1) #> left factor a(z): #>      z^0 [,1]  [,2]  z^1 [,1]       [,2] #> [1,]        1     0 -0.508120  1.1940164 #> [2,]        0     1  1.522162 -0.3834481 #> right factor b(z): #>       z^0 [,1]   z^1 [,1] #> [1,] 0.1037656  0.3615888 #> [2,] 0.5933128 -0.5718296  # the subsetting operator [,] is only implemented for \"rmfd\" rows (r = test_rmfd(dim = c(2,2), degrees = c(1,1))) #> ( 2 x 2 ) right matrix fraction description d(z) c^(-1)(z) with degrees deg(c(z)) = p = 1, deg(d(z)) = q = 1 #> left factor d(z): #>       z^0 [,1]       [,2]  z^1 [,1]      [,2] #> [1,] 0.8725699  0.6300639 -1.597295 0.3466716 #> [2,] 0.2503713 -1.2707216 -1.493156 0.6419091 #> right factor c(z): #>      z^0 [,1]  [,2]    z^1 [,1]       [,2] #> [1,]        1     0 -0.01638416 -0.2491380 #> [2,]        0     1 -0.52904209  0.2335864 r[1,] #> ( 1 x 2 ) right matrix fraction description d(z) c^(-1)(z) with degrees deg(c(z)) = p = 1, deg(d(z)) = q = 1 #> left factor d(z): #>       z^0 [,1]      [,2]  z^1 [,1]      [,2] #> [1,] 0.8725699 0.6300639 -1.597295 0.3466716 #> right factor c(z): #>      z^0 [,1]  [,2]    z^1 [,1]       [,2] #> [1,]        1     0 -0.01638416 -0.2491380 #> [2,]        0     1 -0.52904209  0.2335864"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/extract_matrix_.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper for Extracting indices — extract_matrix_","title":"Helper for Extracting indices — extract_matrix_","text":"Linear indices extracting elements matrix obtained,  depending dimension matrix, number arguments n_args, missingness is_missing arguments, contents j.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/extract_matrix_.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper for Extracting indices — extract_matrix_","text":"","code":"extract_matrix_(m, n, n_args, is_missing, i, j)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/extract_matrix_.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper for Extracting indices — extract_matrix_","text":"m Integer. Output dimension. n Integer. Input dimension. n_args Integer. One, two. Corresponds case one set indices two sets given. Corresponds x[] x[,j] is_missing Boolean vector dimension n_args, .e. one two.  TRUE function used fo x[] x[,] First set indices. Can integers booleans. j Second set indices. Like .","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/extract_matrix_.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper for Extracting indices — extract_matrix_","text":"Indices (integers) used extract relevant elements","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/extract_matrix_.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Helper for Extracting indices — extract_matrix_","text":"input checks performed internal function.  Consequently, input combination contradictory without alerting user.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/extract_matrix_.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Helper for Extracting indices — extract_matrix_","text":"","code":"# x[,] extract_matrix_(6, 5,                  n_args = 2,                 is_missing = c(TRUE, TRUE),                 i = 1:3,                 j = c(2,5)) #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    1    7   13   19   25 #> [2,]    2    8   14   20   26 #> [3,]    3    9   15   21   27 #> [4,]    4   10   16   22   28 #> [5,]    5   11   17   23   29 #> [6,]    6   12   18   24   30                  # x[i,j] extract_matrix_(6, 5,                  n_args = 2,                 is_missing = c(FALSE, FALSE),                 i = 1:3,                 j = c(2,5)) #>      [,1] [,2] #> [1,]    7   25 #> [2,]    8   26 #> [3,]    9   27                  # x[,j] extract_matrix_(6, 5,                  n_args = 2,                 is_missing = c(TRUE, FALSE),                 i = 1:3,                 j = c(2,5)) #>      [,1] [,2] #> [1,]    7   25 #> [2,]    8   26 #> [3,]    9   27 #> [4,]   10   28 #> [5,]   11   29 #> [6,]   12   30                  # x[i,] extract_matrix_(6, 5,                  n_args = 2,                 is_missing = c(FALSE, TRUE),                 i = 1:3,                 j = c(2,5)) #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    1    7   13   19   25 #> [2,]    2    8   14   20   26 #> [3,]    3    9   15   21   27                  # x[i], j is ignored if available (doesn't happen because it will not be called in this way) extract_matrix_(6, 5,                  n_args = 1,                 is_missing = c(FALSE, TRUE),                 i = 1:10,                 j = c(2,5)) #>       [,1] #>  [1,]    1 #>  [2,]    2 #>  [3,]    3 #>  [4,]    4 #>  [5,]    5 #>  [6,]    6 #>  [7,]    7 #>  [8,]    8 #>  [9,]    9 #> [10,]   10                  # x[i], j is ignored if available (doesn't happen because it will not be called in this way) extract_matrix_(6, 5,                  n_args = 1,                 is_missing = c(FALSE, TRUE),                 i = c(3,6,7,1),                 j = c(2,5)) #>      [,1] #> [1,]    3 #> [2,]    6 #> [3,]    7 #> [4,]    1"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/get_fwd.html","id":null,"dir":"Reference","previous_headings":"","what":"Forward and Backward Bracket — get_fwd","title":"Forward and Backward Bracket — get_fwd","text":"lpolm object input, get_bwd discards coefficient matrices pertaining negative powers returns lpolm object min_deg = 0. Similarly, get_fwd discards coefficient matrices pertaining non-negative powers, also returns lpolm object.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/get_fwd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Forward and Backward Bracket — get_fwd","text":"","code":"get_fwd(lpolm_obj)  get_bwd(lpolm_obj)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/get_fwd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Forward and Backward Bracket — get_fwd","text":"lpolm_obj Laurent polynomial object lpolm","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/get_fwd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Forward and Backward Bracket — get_fwd","text":"Laurent polynomial object lpolm without non-negative coefficients without negative","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/get_fwd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Forward and Backward Bracket — get_fwd","text":"Obtain forward backward part Laurent polynomial, .e. apply \\([.]_-\\) \\([.]_+\\)  $$(z) = a_{-q} z^{-q} + \\cdots + a_{-1} z^{-1} + a_0 + a_1 z^1 + \\cdots + a_p z^p$$ obtain get_fwd $$[(z)]_- = a_{-q} z^{-q} + \\cdots + a_{-1} z^{-1}$$ get_bwd $$[(z)]_+ = a_0 + a_1 z^1 + \\cdots + a_p z^p$$","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/get_fwd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Forward and Backward Bracket — get_fwd","text":"","code":"(lp = test_lpolm(degree_max = 2, degree_min = -2)) #> ( 1 x 1 ) Laurent polynomial matrix with degree <= 2, and minimal degree >= -2 #>      z^-2 [,1] z^-1 [,1]   z^0 [,1]   z^1 [,1]  z^2 [,1] #> [1,]  1.033749 0.4735916 0.04601319 -0.4984208 -1.334598 get_fwd(lp) #> ( 1 x 1 ) Laurent polynomial matrix with degree <= -1, and minimal degree >= -2 #>      z^-2 [,1] z^-1 [,1] #> [1,]  1.033749 0.4735916 (lp = test_lpolm(degree_max = 2, degree_min = -2)) #> ( 1 x 1 ) Laurent polynomial matrix with degree <= 2, and minimal degree >= -2 #>       z^-2 [,1] z^-1 [,1]  z^0 [,1]  z^1 [,1]    z^2 [,1] #> [1,] -0.5845376 0.2459016 0.8264307 0.6999749 0.009480139 get_bwd(lp) #> ( 1 x 1 ) Laurent polynomial matrix with degree <= 2, and minimal degree >= 0 #>       z^0 [,1]  z^1 [,1]    z^2 [,1] #> [1,] 0.8264307 0.6999749 0.009480139  (lp = lpolm(1:3, min_deg = 2)) #> ( 1 x 1 ) Laurent polynomial matrix with degree <= 4, and minimal degree >= 2 #>      z^2 [,1] z^3 [,1] z^4 [,1] #> [1,]        1        2        3 get_bwd(lp) #> ( 1 x 1 ) Laurent polynomial matrix with degree <= 4, and minimal degree >= 0 #>      z^0 [,1] z^1 [,1] z^2 [,1] z^3 [,1] z^4 [,1] #> [1,]        0        0        1        2        3  (lp = lpolm(1:3, min_deg = -1)) #> ( 1 x 1 ) Laurent polynomial matrix with degree <= 1, and minimal degree >= -1 #>      z^-1 [,1] z^0 [,1] z^1 [,1] #> [1,]         1        2        3 get_bwd(lp) #> ( 1 x 1 ) Laurent polynomial matrix with degree <= 1, and minimal degree >= 0 #>      z^0 [,1] z^1 [,1] #> [1,]        2        3  (lp = lpolm(1:3, min_deg = -5)) #> ( 1 x 1 ) Laurent polynomial matrix with degree <= -3, and minimal degree >= -5 #>      z^-5 [,1] z^-4 [,1] z^-3 [,1] #> [1,]         1         2         3 get_bwd(lp) #> ( 1 x 1 ) Laurent polynomial matrix with degree <= -1, and minimal degree >= 0"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/get_subfigure_layout.html","id":null,"dir":"Reference","previous_headings":"","what":"Subfigure Layout — get_subfigure_layout","title":"Subfigure Layout — get_subfigure_layout","text":"device split (m--n) array (sub-) figures. tool computes corresponding figure region margins (sub-) figures.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/get_subfigure_layout.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subfigure Layout — get_subfigure_layout","text":"","code":"get_subfigure_layout(margins)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/get_subfigure_layout.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subfigure Layout — get_subfigure_layout","text":"margins named list slots bottom, left, top right determine margins sub-figures. E.g. bottom m-dimensional vector bottom[] gives bottom margin (\"line units\") sub-figures -th row.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/get_subfigure_layout.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Subfigure Layout — get_subfigure_layout","text":"list slots omi 4-dimensional vector \"outer margin\" inches. mar (m,n,4)-dimensional array, mar[,j,] contains            margins (\"line\" units) (,j)-th sub-figure. fig (m,n,4)-dimensional array, fig[,j,] contains            coordinates (\"NDC\" units) figure region            (,j)-th sub-figure.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/reference/grammians.html","id":null,"dir":"Reference","previous_headings":"","what":"Grammians — grammians","title":"Grammians — grammians","text":"procedure computes \"grammians\" statespace realization, may e.g. used  balancing statespace realization.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/grammians.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Grammians — grammians","text":"","code":"grammians(   obj,   which = c(\"lyapunov\", \"minimum phase\", \"ctr\", \"obs\", \"obs_inv\", \"ctr_inv\") )"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/grammians.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Grammians — grammians","text":"obj (stsp object) rational matrix statespace form. (character string) specifies type Grammian(s) computed.See  details.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/grammians.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Grammians — grammians","text":"Either selected Grammian (one 'ctr', 'obs', 'ctr_inv', 'obs_inv')          list two components P Q (case = 'lyapunov' = 'miniumum phase').","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/grammians.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Grammians — grammians","text":"controllability Grammian \\(P\\) (stable) statespace realization  $$K(z) = C(Iz^{-1} - )^{-1}B + D$$  solution  Lyapunov equation \\(P = APA' + BB'\\). observability Grammian solution  Lyapunov equation \\(Q = 'QA + C'C\\). statespace realization stable  (moduli eigenvalues less one) \\(P,Q\\) positive  semidefinite  \\(P\\) non singular statespace realization controllable  \\(Q\\) non singular statespace realization observable.  Hence grammians may also used check whether statespace realization minimal  (controllable observable). rational matrix (strictly) minimum phase (.e. \\(K(z)\\) square, invertible  matrix eigenvalues matrix \\((- BD^{-1}C)\\) moduli less one)  may also compute controllability observability Grammian  statespace realization  $$K^{-1}(z) = -D^{-1}C (Iz^{-1} - (- BD^{-1}C))^{-1}BD^{-1} + D^{-1}.$$  inverse matrix \\(K^{-1}(z)\\). grammians similar interpretation. described grammians may selected setting parameter  'ctr', 'obs', 'ctr_in' 'obs_inv' respectively. balancing statespace realization one needs suitable pair grammians.  Two popular choices implemented: = 'lyapunov' procedure  returns controllability observability Grammian = 'minimum phase'  controllability matrix system observability Grammian inverse system  returned. procedure throws error state space realization stable, respectively  minimum phase.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/reference/grammians.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Grammians — grammians","text":"","code":"# create a random, (3 by 2) rational matrix,  # with a stable and minimum phase statespüace realization obj = test_stsp(dim = c(3,2), s = 5, bpoles = 1, bzeroes = 1) gr = grammians(obj, which = 'lyapunov') gr #> $P #>             [,1]        [,2]       [,3]        [,4]        [,5] #> [1,]  0.32775483 -0.17964544  0.2725058 -0.07260366 -0.19710672 #> [2,] -0.17964544  0.49851755 -0.2198610  0.12244840 -0.02287397 #> [3,]  0.27250577 -0.21986096  0.8822231 -0.25291616 -0.51535842 #> [4,] -0.07260366  0.12244840 -0.2529162  0.54401521  0.09663245 #> [5,] -0.19710672 -0.02287397 -0.5153584  0.09663245  0.44587725 #>  #> $Q #>           [,1]       [,2]        [,3]       [,4]        [,5] #> [1,] 1.4927016  0.2620439  0.44920371  0.2408703  1.04007162 #> [2,] 0.2620439  1.7815496  0.29608224 -0.6569566  0.47312261 #> [3,] 0.4492037  0.2960822  1.38271026 -0.3677217 -0.05605608 #> [4,] 0.2408703 -0.6569566 -0.36772172  0.9102619  0.37241741 #> [5,] 1.0400716  0.4731226 -0.05605608  0.3724174  2.29004445 #>   # we could also compute these grammians seperately  all.equal(gr$P, grammians(obj,'ctr')) #> [1] TRUE all.equal(gr$Q, grammians(obj,'obs')) #> [1] TRUE  # create a random (3 by 3) rational matrix,  # with a stable and minimum phase statespüace realization # Note: for the choice \"minimum phase\" the rational matrix  # must be square and invertible. obj = test_stsp(dim = c(3,3), s = 5, bpoles = 1, bzeroes = 1) gr = grammians(obj, which = 'minimum phase') gr #> $P #>             [,1]        [,2]        [,3]       [,4]        [,5] #> [1,]  1.00795687 -0.67326964 -0.03598985  0.7187124 -0.09349528 #> [2,] -0.67326964  1.72101599  0.46772876 -0.8312145  0.01020235 #> [3,] -0.03598985  0.46772876  0.49727748 -0.4605188 -0.14528297 #> [4,]  0.71871236 -0.83121454 -0.46051879  1.2349619  0.07202310 #> [5,] -0.09349528  0.01020235 -0.14528297  0.0720231  0.44457805 #>  #> $Q #>            [,1]         [,2]        [,3]         [,4]       [,5] #> [1,]  4.4738420  0.635833809  0.48471647 -1.557353187 -1.8806980 #> [2,]  0.6358338  0.444292336  0.06511815 -0.004909387 -0.3505099 #> [3,]  0.4847165  0.065118147  0.11294231 -0.222718691 -0.1254783 #> [4,] -1.5573532 -0.004909387 -0.22271869  1.223094897  0.8292980 #> [5,] -1.8806980 -0.350509869 -0.12547830  0.829298033  1.6631605 #>   # we could also compute these grammians seperately  all.equal(gr$P, grammians(obj,'ctr')) #> [1] TRUE all.equal(gr$Q, grammians(obj,'obs_inv')) #> [1] TRUE"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/hankel2mu.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute right-Kronecker Indices for given Hankel Matrix — hankel2mu","title":"Compute right-Kronecker Indices for given Hankel Matrix — hankel2mu","text":"(internal) helper functions determines right-Kronecker indices  given Hankel matrix impulse response coefficients.  checks parameters! particular, note  Hankel matrix must attribute order=c(m,n,f,p)  describes block size \\((m,n)\\) number  block rows (\\(f\\)) block columns (\\(p\\)).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/hankel2mu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute right-Kronecker Indices for given Hankel Matrix — hankel2mu","text":"","code":"hankel2mu(H, tol = sqrt(.Machine$double.eps))"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/hankel2mu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute right-Kronecker Indices for given Hankel Matrix — hankel2mu","text":"H Block Hankel matrix, computed e.g. pseries2hankel. tol tolerance parameter, used qr.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/hankel2mu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute right-Kronecker Indices for given Hankel Matrix — hankel2mu","text":"Integer vector right-Kronecker indices.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/hankel2nu.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute left-Kronecker Indices for given Hankel Matrix — hankel2nu","title":"Compute left-Kronecker Indices for given Hankel Matrix — hankel2nu","text":"(internal) helper functions determines left-Kronecker indices  given Hankel matrix impulse response coefficients.  checks parameters! particular, note  Hankel matrix must attribute order=c(m,n,f,p)  describes block size \\((m,n)\\) number  block rows (\\(f\\)) block columns (\\(p\\)).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/hankel2nu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute left-Kronecker Indices for given Hankel Matrix — hankel2nu","text":"","code":"hankel2nu(H, tol = sqrt(.Machine$double.eps))"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/hankel2nu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute left-Kronecker Indices for given Hankel Matrix — hankel2nu","text":"H Block Hankel matrix, computed e.g. pseries2hankel. tol tolerance parameter, used qr.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/hankel2nu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute left-Kronecker Indices for given Hankel Matrix — hankel2nu","text":"Integer vector Kronecker indices.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/hnf.html","id":null,"dir":"Reference","previous_headings":"","what":"Hermite Normal Form — hnf","title":"Hermite Normal Form — hnf","text":"Calculate column Hermite (default) row Hermite form  polynomial matrix \\((z)\\), using either (elementary) row operations (default)  column operations.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/hnf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hermite Normal Form — hnf","text":"","code":"hnf(a, from_left = TRUE, tol = sqrt(.Machine$double.eps), debug = FALSE)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/hnf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hermite Normal Form — hnf","text":"Matrix polynomial, .e. object class polm. from_left Logical. Default set TRUE, case unimodular row-transformations used obtain  column Hermite normal form, .e. \\((z) = u(z) h(z)\\). FALSE, unimodular column-transformations used obtain row Hermite  normal form, .e. \\((z) = h(z) u(z)\\). tol Tolerance parameter. Default set sqrt(.Machine$double.eps). debug Logical. TRUE, diagnostic messages printed.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/hnf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hermite Normal Form — hnf","text":"list following slots. h polm object represents triangular matrix \\(h(z)\\).                  Depending from_left matrix \\(h(z)\\) either quasi-upper-                  quasi-lower-triangular. u_inv polm object, represents unimodular matrix                  transform \\((z)\\) desired normal form,                  .e. \\(h(z) = u^{-1}(z) (z)\\)  \\(h(z) = (z)u^{-1}(z)\\). u polm object, represents unimodular matrix \\(u(z)\\)                  \\((z) = u(z) h(z)\\)  \\((z) = h(z)u(z)\\).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/hnf.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hermite Normal Form — hnf","text":"\\((m,n)\\) dimensional polynomial matrix \\((z)\\) rank \\(r\\)  (considered rational matrix) exists unimodular matrix \\(u(z)\\)  indices \\(j(1)<j(2)<\\cdots<j(r)\\)  \\(h(z)= u^{-1}(z) (z)\\) \"quasi-upper-triangular\" sense \\(h_{ij()}\\) monic (coefficient pertaining highest        degree equal one), elements \\(h_{ij()}\\) lower polynomial degree        \\(h_{ij()}\\) \\(h_{,j}\\) zero \\(>r\\) \\(j < j()\\). matrix \\(h(z)\\) called row Hermite form \\((z)\\). matrix \\(u^{-1}(z)\\)  corresponds sequence elementary row operations renders \\((z)\\)  desired upper-triangular form. Quite analogously one may transform matrix \\((z)\\) elementary column operations  \"quasi-lower-triangular\" form \\(h(z) = (z)u^{-1}(z)\\). corresponding normal form  called row Hermite form. detailed description, see e.g.,  (Kailath 1980)  (page 375, Theorem 375)  package vignette \"Rational Matrices\".","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/hnf.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Hermite Normal Form — hnf","text":"Kailath T (1980). Linear Systems. Prentice Hall, Englewood Cliffs, New Jersey.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/hnf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hermite Normal Form — hnf","text":"","code":"##################################################################### # Generate polynomial matrix square = test_polm(dim = c(2,2), degree = 3) # wide matrix, where all elements have a common factor (1-z) wide = test_polm(dim = c(2,3), degree = 2) * polm(c(1,-1)) # tall matrix with a \"right factor\" ((2 x2) random polynomial matrix) tall = test_polm(dim = c(3,2), degree = 1) %r%            test_polm(dim = c(2,2), degree = 1, random = TRUE, digits = 1)  a = tall  # choose one of the above cases  ############################ # column Hermite form out = hnf(a) print(out$h, digits = 2, format = 'c') #> ( 3 x 2 ) matrix polynomial with degree <= 4  #>       [,1]                                    [,2] #> [1,]     1        1.53 - 0.07z - 0.79z^2 + 0.75z^3 #> [2,]     0  2.68 + 2.97z - 1.09z^2 - 0.39z^3 + z^4 #> [3,]     0                                       0   # check result(s) all.equal(a, prune(out$u %r% out$h)) #> [1] TRUE all.equal(polm(diag(dim(a)[1])), prune(out$u_inv %r% out$u)) #> [1] TRUE if (dim(a)[1] == dim(a)[2]) {   rbind(sort(zeroes(a)), sort(zeroes(out$h))) }  ############################ # row Hermite form out = hnf(a, from_left = FALSE) print(out$h, digits = 2, format = 'c') #> ( 3 x 2 ) matrix polynomial with degree <= 4  #>                                       [,1]                                     [,2] #> [1,]                                     1                                        0 #> [2,]  -42.97 - 4.52z + 22.86z^2 - 16.59z^3   2.68 + 2.97z - 1.09z^2 - 0.39z^3 + z^4 #> [3,]  -86.93 - 9.04z + 45.71z^2 - 33.18z^3  5.36 + 5.95z - 2.19z^2 - 0.77z^3 + 2z^4   # check result(s) all.equal(a, prune(out$h %r% out$u)) #> [1] TRUE all.equal(polm(diag(dim(a)[2])), prune(out$u_inv %r% out$u)) #> [1] TRUE if (dim(a)[1] == dim(a)[2]) {   rbind(sort(zeroes(a)), sort(zeroes(out$h))) }"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/idx_trafo.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform between Linear Index and Matrix Indices — idx_trafo","title":"Transform between Linear Index and Matrix Indices — idx_trafo","text":"functions MATLAB. ind2sub() transforms linear index row column index matrix given size. sub2ind() transforms matrix index, (row, col) linear index (terms columns).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/idx_trafo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform between Linear Index and Matrix Indices — idx_trafo","text":"","code":"ind2sub(dim, ind)  sub2ind(dim, row, col)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/idx_trafo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform between Linear Index and Matrix Indices — idx_trafo","text":"dim Integer vector size 2. Matrix dimensions. ind Integer. Linear index. row Integer. Row index. col Integer. Column index.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/idx_trafo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform between Linear Index and Matrix Indices — idx_trafo","text":"ind2sub() returns given linear index, matrix index (row, col).  sub2ind() returns given matrix index (row, col), linear index (column-major).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/idx_trafo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform between Linear Index and Matrix Indices — idx_trafo","text":"","code":"A = matrix(1:(3*4), 3, 4) A #>      [,1] [,2] [,3] [,4] #> [1,]    1    4    7   10 #> [2,]    2    5    8   11 #> [3,]    3    6    9   12  ind2sub(c(3,4), 7) #> [1] 1 3 sub2ind(c(3,4), 2, 3) #> [1] 8"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/inflate_object.html","id":null,"dir":"Reference","previous_headings":"","what":"Inflate a scalar to an (m x n) matrix with identical entries — inflate_object","title":"Inflate a scalar to an (m x n) matrix with identical entries — inflate_object","text":"Used elementwise group operations Ops.ratm *inflate* scalar ratm object can , e.g., elementwise added. used upgrade_objects called therefore relevant polm, lpolm, stsp, pseries, zvalues words, one inflate lmfd rmfd objects.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/inflate_object.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inflate a scalar to an (m x n) matrix with identical entries — inflate_object","text":"","code":"inflate_object(e, m, n)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/inflate_object.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inflate a scalar to an (m x n) matrix with identical entries — inflate_object","text":"e Object type polm, lpolm,  stsp, pseries, zvalues m Integer. Output dimension scalar inflated. n Integer. Output dimension scalar inflated.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/inflate_object.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inflate a scalar to an (m x n) matrix with identical entries — inflate_object","text":"Object type *inflated* dimension","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/inflate_object.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Inflate a scalar to an (m x n) matrix with identical entries — inflate_object","text":"","code":"(lp = test_lpolm(degree_max = 1, degree_min = -1)) #> ( 1 x 1 ) Laurent polynomial matrix with degree <= 1, and minimal degree >= -1 #>       z^-1 [,1] z^0 [,1] z^1 [,1] #> [1,] -0.1508111  1.53411 1.938096 inflate_object(lp, 2, 2) #> ( 2 x 2 ) Laurent polynomial matrix with degree <= 1, and minimal degree >= -1 #>       z^-1 [,1]       [,2] z^0 [,1]    [,2] z^1 [,1]     [,2] #> [1,] -0.1508111 -0.1508111  1.53411 1.53411 1.938096 1.938096 #> [2,] -0.1508111 -0.1508111  1.53411 1.53411 1.938096 1.938096  (ss = test_stsp(s = 1)) #> statespace realization [1,1] with s = 1 states #>            s[1]       u[1] #> s[1]  1.0721054 -0.9162056 #> x[1] -0.1784693  1.0000000 inflate_object(ss, 2, 2) #> statespace realization [2,2] with s = 2 states #>            s[1]       s[2]       u[1]       u[2] #> s[1]  1.0721054  0.0000000 -0.9162056 -0.9162056 #> s[2]  0.0000000  1.0721054 -0.9162056 -0.9162056 #> x[1] -0.1784693  0.0000000  1.0000000  1.0000000 #> x[2]  0.0000000 -0.1784693  1.0000000  1.0000000"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/is.coprime.html","id":null,"dir":"Reference","previous_headings":"","what":"Left Prime and Left Coprime Polynomials — is.coprime","title":"Left Prime and Left Coprime Polynomials — is.coprime","text":"Check whether polynomial left prime pair two polynomials left coprime. check uses (singular) pencil associated polynomial(s). details  see vignette Technical Details.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/is.coprime.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Left Prime and Left Coprime Polynomials — is.coprime","text":"","code":"is.coprime(   a,   b = NULL,   tol = sqrt(.Machine$double.eps),   only.answer = TRUE,   debug = FALSE )"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/is.coprime.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Left Prime and Left Coprime Polynomials — is.coprime","text":", b lmfd rmfd object,  represents left matrix fraction description, say \\(p^{-1}(z) q(z)\\),  right MFD, say \\(r(z) s^{-1}(z)\\),  procedure tests whether pair \\((p(z),q(z))\\) \\((t(r(z)),t(q(z)))\\)left coprime. Otherwise arguments b (b NULL) must represent two compatible polynomial matrices,  .e. , b must polm objects (objects may coerced polm objects).  b NULL, procedures checks whether \\((z)\\) left prime, otherwise pair \\(((z),b(z))\\) checked left coprimeness. tol tolerance parameter, used decide rank certain matrices. .answer TRUE, just return logical (TRUE FALSE).  Otherwise list additional information returned. debug TRUE, print diagnostic information.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/is.coprime.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Left Prime and Left Coprime Polynomials — is.coprime","text":".answer true logical (TRUE FALSE) returned.   Otherwise, list following slots returned. detailed description    items given vignette Technical Details. answer boolean ,B matrices represent pencil \\((-Bz)\\) (staircase form) used               check left (co-)prime condition. m,n Two integer vectors code structure staircase form. zeroes available, vector zeroes matrix \\(((z),b(z))\\).                  \\((,b)\\) common zeroes (left coprime case)                  zeroes empty numeric vector. case                  \\(((z),b(z))\\) rank deficient \\(z \\C\\)                  coded z=NA.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/is.coprime.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Left Prime and Left Coprime Polynomials — is.coprime","text":"procedure returns different objects, depending parameter .answer.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/is.coprime.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Left Prime and Left Coprime Polynomials — is.coprime","text":"","code":"# Ex 1: Two coprime polynomials ##################################################  # Generate two random (2 x 2) polynomial matrices with degree 2 set.seed(1803) a = test_polm(dim = c(2,2), degree = 2, random = TRUE, digits = 1) b = test_polm(dim = c(2,2), degree = 2, random = TRUE, digits = 1)  # Output: \"only.answer = TRUE\" is.coprime(a, b, debug = FALSE, only.answer = TRUE) #> [1] TRUE  # Output: \"only.answer = FALSE\" out = is.coprime(a, b, debug = FALSE, only.answer = FALSE) str(out) #> List of 6 #>  $ answer: logi TRUE #>  $ A     : num [1:6, 1:8] -1.67e-17 -1.00 0.00 0.00 0.00 ... #>  $ B     : num [1:6, 1:8] 0 0 0 0 0 0 0 0 0 0 ... #>  $ zeroes: num(0)  #>  $ m     : int [1:3] 2 2 2 #>  $ n     : num [1:3] 2 2 4 out$answer #> [1] TRUE out$zeroes #> numeric(0)  # we could equivalently use the syntax:  is.coprime(cbind(a,b)) #> [1] TRUE is.coprime(lmfd(a,b)) #> [1] TRUE  # Ex 2: Two non-coprime polynomials with a finite number of common zeros ############# # Dimensions of a, b, and the common factor r dim = 3 deg_aa = 1 deg_bb = 1 deg_r = 1  # Generate random polynomial matrices a0 = a b0 = b # generate common factor  r = test_polm(dim = c(2,2), degree = 1, random = TRUE, digits = 1)  # Generate polynomials with a common factor a = r %r% a0 b = r %r% b0  out = is.coprime(a, b, debug = FALSE, only.answer = FALSE) out$answer #> [1] FALSE out$zeroes #> [1] -0.8401447  0.5105993   # Ex 3: Two non-coprime polynomials: Everywhere rank deficient ###################  # generate a common factor of rank 1  r = test_polm(dim = c(2,1), degree = 1, random = TRUE, digits = 1) %r%      test_polm(dim = c(1,2), degree = 1, random = TRUE, digits = 1)  # Rank deficient matrices with common factor a = r %r% a0 b = r %r% b0  out = is.coprime(a,b, only.answer = FALSE) out$answer #> [1] FALSE out$zeroes #> [1] NA   # Ex 4: Right-MFD ####  c = test_polm(dim = c(2,2), degree = 2, random = TRUE, digits = 1) d = test_polm(dim = c(2,2), degree = 2, random = TRUE, digits = 1)  # Output: \"only.answer = TRUE\" is.coprime(t(c), t(d), debug = FALSE, only.answer = TRUE) #> [1] TRUE  # Output: \"only.answer = FALSE\" out = is.coprime(t(c), t(d), debug = FALSE, only.answer = FALSE) str(out) #> List of 6 #>  $ answer: logi TRUE #>  $ A     : num [1:6, 1:8] -1.00 3.42e-17 0.00 0.00 0.00 ... #>  $ B     : num [1:6, 1:8] 0 0 0 0 0 0 0 0 0 0 ... #>  $ zeroes: num(0)  #>  $ m     : int [1:3] 2 2 2 #>  $ n     : num [1:3] 2 2 4 out$answer #> [1] TRUE out$zeroes #> numeric(0)  # we could equivalently use the syntax:  is.coprime(rbind(c,d)) #> [1] FALSE is.coprime(rmfd(c,d)) #> [1] TRUE  # reset seed set.seed(NULL)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/is.html","id":null,"dir":"Reference","previous_headings":"","what":"Check Objects — is.class methods","title":"Check Objects — is.class methods","text":"Check argument valid object.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/is.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check Objects — is.class methods","text":"","code":"is.polm(x)  is.lpolm(x)  is.lmfd(x)  is.rmfd(x)  is.stsp(x)  is.pseries(x)  is.zvalues(x)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/is.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check Objects — is.class methods","text":"x object","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/is.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check Objects — is.class methods","text":"TRUE argument valid object.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/is.minimal.html","id":null,"dir":"Reference","previous_headings":"","what":"Check the Minimality of a Statespace Realization — is.minimal","title":"Check the Minimality of a Statespace Realization — is.minimal","text":"Check whether statespace realization rational matrix minimal.  procedure constructs Hankel matrix impulse response coefficients \\(s\\) block rows \\(s\\) block columns,  \\(s\\) statespace dimension given statespace realization.  statespace realization minimal Hankel matrix rank \\(s\\).  Therefore procedure returns TRUE \\(s\\)-th singular values Hankel matrix larger tol.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/is.minimal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check the Minimality of a Statespace Realization — is.minimal","text":"","code":"is.minimal(x, ...)  # S3 method for stsp is.minimal(x, tol = sqrt(.Machine$double.eps), only.answer = TRUE, ...)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/is.minimal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check the Minimality of a Statespace Realization — is.minimal","text":"x (stsp object) rational matrix statespace form. ... used. tol tolerance parameter, used decide rank  Hankel matrix impulse response coefficients. .answer TRUE, just return logical (TRUE FALSE).  Otherwise list additional information returned.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/is.minimal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check the Minimality of a Statespace Realization — is.minimal","text":".answer true logical (TRUE FALSE) returned.   Otherwise, list following slots returned. answer boolean . H Hankel matrix impulse response coefficients (s block rows s block columns). sv singular values H. s0 (integer) (estimate ) rank H, .e. minimal statespace dimension.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/is.minimal.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check the Minimality of a Statespace Realization — is.minimal","text":"procedure check whether statespace realization observable / controllable. end one may compute observability/controllability matrices (obs_matrix, ctr_matrix) corresponding Grammians (grammians).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/is.minimal.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Check the Minimality of a Statespace Realization — is.minimal","text":"procedure returns different objects, depending parameter .answer.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/reference/is.minimal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check the Minimality of a Statespace Realization — is.minimal","text":"","code":"x = test_stsp(dim = c(2,2), s = 2) is.minimal(x) #> [1] TRUE # note that operations on \"stsp\" objects may return non minimal realizations #  is.minimal(rbind(x, x), only.answer = FALSE)[c('answer','sv','s0')] #> $answer #> [1] FALSE #>  #> $sv #> [1] 1.357924e+02 3.260048e+01 8.597267e-15 3.250070e-15 1.659556e-15 #> [6] 6.167484e-16 2.478128e-16 1.823865e-16 #>  #> $s0 #> [1] 2 #>  is.minimal(x %r% (x^(-1)), only.answer = FALSE)[c('answer','sv','s0')] #> $answer #> [1] FALSE #>  #> $sv #> [1] 5.178273e-13 1.906038e-13 3.646667e-14 1.637282e-14 4.089410e-15 #> [6] 2.729690e-15 7.686616e-16 4.135715e-16 #>  #> $s0 #> [1] 0 #>   is.minimal(test_stsp(dim = c(2,0), s = 2)) #> [1] FALSE is.minimal(test_stsp(dim = c(0,2), s = 0)) #> [1] TRUE"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/iseq.html","id":null,"dir":"Reference","previous_headings":"","what":"Sequence generation — iseq","title":"Sequence generation — iseq","text":"opposed standard seq command function iseq returns empty vector starting value larger end value.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/iseq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sequence generation — iseq","text":"","code":"iseq(from = 1, to = 1)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/iseq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sequence generation — iseq","text":", starting end values sequence.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/iseq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sequence generation — iseq","text":"iseq returns empty integer vector less  seq(,) else.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/iseq.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sequence generation — iseq","text":"general seq_len sequence need start 1.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/iseq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sequence generation — iseq","text":"","code":"iseq(0,1) # => c(0,1) #> [1] 0 1 iseq(1,0) # => integer(0) #> integer(0) seq(1,0)  # => c(1,0) #> [1] 1 0"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/line2inch.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert 'line units' to inches — line2inch","title":"Convert 'line units' to inches — line2inch","text":"Convert 'line units' inches","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/line2inch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert 'line units' to inches — line2inch","text":"","code":"line2inch()"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/line2inch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert 'line units' to inches — line2inch","text":"scalar","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/line2inch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert 'line units' to inches — line2inch","text":"","code":"line2inch() #> [1] 0.2 par(cex = 2, mex = 2) line2inch() #> [1] 0.8"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/lmfd.html","id":null,"dir":"Reference","previous_headings":"","what":"Constructor for Left Matrix Fraction Descriptions (LMFDs) — lmfd","title":"Constructor for Left Matrix Fraction Descriptions (LMFDs) — lmfd","text":"Left Matrix Fraction Description (LMFD) rational matrix, \\(x(z)\\) say, pair \\(((z),b(z))\\) polynomial matrices, \\(x(z) = ^{-1}(z) b(z)\\).  polynomial matrix \\((z)\\) must square invertible.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/lmfd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for Left Matrix Fraction Descriptions (LMFDs) — lmfd","text":"","code":"lmfd(a, b)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/lmfd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor for Left Matrix Fraction Descriptions (LMFDs) — lmfd","text":", b polm objects, objects may coerced polm object, via x = polm(x). Either two arguments may omitted.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/lmfd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Constructor for Left Matrix Fraction Descriptions (LMFDs) — lmfd","text":"object class lmfd.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/lmfd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Constructor for Left Matrix Fraction Descriptions (LMFDs) — lmfd","text":"Suppose \\(x(z)=^{-1}(z) b(z)\\) \\((m,n)\\)-dimensional matrix  \\((z)\\) \\(b(z)\\) degrees \\(p\\) \\(q\\) respectively.  corresponding lmfd object stores coefficients polynomials \\((z), b(z)\\)  \\((m,m(p+1)+n(q+1))\\) dimensional (real complex valued) matrix together  attribute order = c(m,n,p,q) class attribute c(\"lmfd\", \"ratm\"). valid LMFD require \\(m>0\\) \\(p\\geq 0\\).","code":""},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/reference/lmfd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Constructor for Left Matrix Fraction Descriptions (LMFDs) — lmfd","text":"","code":"### (1 x 1) rational matrix x(z) = (1+z+z^2)^(-1) (3+2z+z^2) lmfd(c(1,1,1), c(3,2,1)) %>% print(format = 'c') #> ( 1 x 1 ) left matrix fraction description a^(-1)(z) b(z) with degrees (p = 2, q = 2) #> left factor a(z): #>              [,1] #> [1,]  1 + z + z^2  #> right factor b(z): #>               [,1] #> [1,]  3 + 2z + z^2   ### (1 x 1) rational matrix x(z) = (3+2z+z^2) lmfd(b = c(3,2,1)) %>% print(format = 'c') #> ( 1 x 1 ) left matrix fraction description a^(-1)(z) b(z) with degrees (p = 0, q = 2) #> left factor a(z): #>       [,1] #> [1,]     1  #> right factor b(z): #>               [,1] #> [1,]  3 + 2z + z^2   ### (1 x 1) rational matrix x(z) = (1+z+z^2)^(-1) lmfd(c(1,1,1)) %>% print(format = 'c') #> ( 1 x 1 ) left matrix fraction description a^(-1)(z) b(z) with degrees (p = 2, q = 0) #> left factor a(z): #>              [,1] #> [1,]  1 + z + z^2  #> right factor b(z): #>       [,1] #> [1,]     1   ### (2 x 3) rational matrix with degrees p=1, q=1 x = lmfd(array(rnorm(2*2*2), dim = c(2,2,2)),           array(rnorm(2*3*2), dim = c(2,3,2))) is.lmfd(x) #> [1] TRUE dim(x) #> m n p q  #> 2 3 1 1  str(x) #> ( 2 x 3 ) left matrix fraction description with degrees (p = 1, q = 1) print(x, digits = 2) #> ( 2 x 3 ) left matrix fraction description a^(-1)(z) b(z) with degrees (p = 1, q = 1) #> left factor a(z): #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]     0.66  0.75    -1.01 -0.35 #> [2,]    -1.14  0.28     0.41  0.18 #> right factor b(z): #>      z^0 [,1]  [,2]  [,3] z^1 [,1]  [,2]  [,3] #> [1,]     0.05 -0.05  1.17    -0.54  0.37 -0.29 #> [2,]     0.46 -0.32  1.71    -2.97 -0.54  1.71  if (FALSE) { ### the following calls to lmfd() throw an error  lmfd() # no arguments! lmfd(a = test_polm(dim = c(2,3), degree = 1))  # a(z) must be square  lmfd(a = test_polm(dim = c(2,2), degree = -1)) # a(z) must have degree >= 0 }"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/lpolm.html","id":null,"dir":"Reference","previous_headings":"","what":"Constructor for Laurent Polynomial Matrices — lpolm","title":"Constructor for Laurent Polynomial Matrices — lpolm","text":"lpolm objects represent Laurent polynomial matrices form $$(z) = a_{-q} z^{-q} + \\cdots + a_{-1} z^{-1} + a_0 + a_1 z + \\cdots + a_p z^p$$ \\((z)\\) \\((m,n)\\) dimensional Laurent polynomial matrix (.e. coefficients \\(a_i\\) \\((m,n)\\) dimensional real complex valued matrices), lpolm object stores coefficients  (m,n,q+p+1)-dimensional (numeric complex) array \\(a_{-q}, \\ldots, a_{-1}, a_{0}, a_{1}, \\ldots, a_{p}\\), together class attribute c(\"lpolm\",\"ratm\").   constructor function lpolm(, min_deg) takes integer min_deg (default zero)  (numeric complex) vector, matrix 3-dimensional array returns lpolm object.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/lpolm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for Laurent Polynomial Matrices — lpolm","text":"","code":"lpolm(a, min_deg = 0)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/lpolm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor for Laurent Polynomial Matrices — lpolm","text":"either (numeric complex) vector, matrix 3-D array. vector coerced scalar  (.e. \\((1,1)\\)-dimensional) polynomial matrix gives Laurent polynomial matrix whose coefficient matrix degree min_deg. min_deg Integer. Default set zero. Smallest degree Laurent polynomial. Negative Laurent polynomials coerced polm objects (.polm throws error).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/lpolm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Constructor for Laurent Polynomial Matrices — lpolm","text":"object class c(\"lpolm\", \"ratm\").          non-negative, object still class.          However, can coerced object class c(\"polm\", \"ratm\") using .polm","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/lpolm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Constructor for Laurent Polynomial Matrices — lpolm","text":"dimensions 3-dimensional array may also zero.  particular, third dimension zero, lpolm object interpreted zero Laurent polynomial. class special sense possible upgrade lmfd, rmfd, stsp, pseries object. important methods functions class look \"see also\" section. Note functions written polm objects: degree, col_end_matrix, normal forms like snf, hnf, whf.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/reference/lpolm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Constructor for Laurent Polynomial Matrices — lpolm","text":"","code":"# (1 x 1) Laurent polynomial matrix a(z) =  3z^{-2} + 2z^{-1} + 1 lpolm(3:1, min_deg = -2) #> ( 1 x 1 ) Laurent polynomial matrix with degree <= 0, and minimal degree >= -2 #>      z^-2 [,1] z^-1 [,1] z^0 [,1] #> [1,]         3         2        1  # Non-negative minimal degrees are allowed too (no implicit coercion to polm object) lpolm(3:1, min_deg = 2) #> ( 1 x 1 ) Laurent polynomial matrix with degree <= 4, and minimal degree >= 2 #>      z^2 [,1] z^3 [,1] z^4 [,1] #> [1,]        3        2        1  lpolm(matrix(1:4,2,2), min_deg = -2) #> ( 2 x 2 ) Laurent polynomial matrix with degree <= -2, and minimal degree >= -2 #>      z^-2 [,1]  [,2] #> [1,]         1     3 #> [2,]         2     4"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/lyapunov.html","id":null,"dir":"Reference","previous_headings":"","what":"Lyapunov Equation — lyapunov","title":"Lyapunov Equation — lyapunov","text":"function solves Lyapunov equation $$P = P ' + Q$$ \\(,Q\\) real valued, square matrices \\(Q\\) symmetric. Lyapunov equation unique solution  \\(\\lambda_i()\\lambda_j() \\neq 1\\) holds  eigenvalues \\(\\).   \\(\\) stable (.e. spectral radius \\(\\) less one) \\(Q\\) positive semidefinite solution \\(P\\) also positive semidefinite.  procedure uses Schur decomposition(s) \\(\\) computes  solution \"column column\", see (Kitagawa 1977; Hammarling 1982) .","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/lyapunov.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lyapunov Equation — lyapunov","text":"","code":"lyapunov(A, Q, non_stable = c(\"ignore\", \"warn\", \"stop\"), attach_lambda = FALSE)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/lyapunov.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lyapunov Equation — lyapunov","text":", Q \\((m,m)\\) matrices. Note routine silently assumes \\(Q\\) symmetric (hence solution \\(P\\) also symmetric). non_stable (character string) indicates , \\(\\) stable. attach_lambda (boolean) yes, eigenvalues \\(\\) attached solution \\(P\\) attribute.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/lyapunov.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lyapunov Equation — lyapunov","text":"P (\\((m,m)\\) matrix)  solution Lyapunov equation.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/lyapunov.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Lyapunov Equation — lyapunov","text":"Kitagawa G (1977). “algorithm solving matrix equation X = FXF T + S.” International Journal Control, 25(5), 745-753. doi:10.1080/00207177708922266 , http://dx.doi.org/10.1080/00207177708922266,  http://dx.doi.org/10.1080/00207177708922266 . Hammarling SJ (1982). “Numerical solution stable, nonnegative definite Lyapunov equation.” IMA Journal Numerical Analysis, 2(3), 303--323. ISSN 0272-4979 (print), 1464-3642 (electronic).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/lyapunov.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lyapunov Equation — lyapunov","text":"","code":"# A is stable and Q is positve definite m = 4 A = diag(runif(m, min = -0.9, max = 0.9)) V = matrix(rnorm(m*m), nrow = m, ncol = m) A = V %*% A %*% solve(V) B = matrix(rnorm(m*m), nrow = m, ncol = m) Q = B %*% t(B) P = lyapunov(A, Q) all.equal(P, A %*% P %*% t(A) + Q) #> [1] TRUE  # unstable matrix A A = diag(runif(m, min = -0.9, max = 0.9)) A[1,1] = 2 V = matrix(rnorm(m*m), nrow = m, ncol = m) A = V %*% A %*% solve(V) P = lyapunov(A, Q) all.equal(P, A %*% P %*% t(A) + Q) #> [1] TRUE # note that the solution P (in general) is not positive semidefinite eigen(P, only.values= TRUE, symmetric = TRUE)$values #> [1]  5.729012  3.120075  1.164436 -2.142780  # attach the eigenvalues of A to the solution P P = lyapunov(A, Q, attach = TRUE) print(P) #>              [,1]       [,2]        [,3]         [,4] #> [1,]  1.572362919  2.9506443 -0.04349985 -0.001071111 #> [2,]  2.950644264  1.3786048  0.14435260 -2.338061527 #> [3,] -0.043499847  0.1443526  2.20749042 -1.324831614 #> [4,] -0.001071111 -2.3380615 -1.32483161  2.712285089 #> attr(,\"lambda\") #> [1]  2.00000000+0i  0.28921194+0i  0.03068143+0i -0.03096243+0i  # issue a warning message P = lyapunov(A, Q, non_stable = 'warn') #> Warning: \"A\" matrix is not stable  if (FALSE) { # throw an error P = lyapunov(A, Q, non_stable = 'stop') }"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/lyapunov_Jacobian.html","id":null,"dir":"Reference","previous_headings":"","what":"Jacobian of the Solution of the Lyapunov Equation — lyapunov_Jacobian","title":"Jacobian of the Solution of the Lyapunov Equation — lyapunov_Jacobian","text":"(internal helper) function considers solution Lyapunov equation $$P = P ' + Q$$ \\(,Q\\) real valued, square matrices \\(Q\\) symmetric.  directional derivative \\(P\\) along (matrices) \\(dA\\), \\(dQ\\)  given solution Lyapunov Equation:  $$dP = dP ' + dA P ' + P dA' + dQ$$","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/lyapunov_Jacobian.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Jacobian of the Solution of the Lyapunov Equation — lyapunov_Jacobian","text":"","code":"lyapunov_Jacobian(A, Q, dA, dQ, non_stable = c(\"ignore\", \"warn\", \"stop\"))"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/lyapunov_Jacobian.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Jacobian of the Solution of the Lyapunov Equation — lyapunov_Jacobian","text":", Q \\((m,m)\\) matrices. Note routine silently assumes \\(Q\\) symmetric (hence solution \\(P\\) also symmetric). dA, dQ \\((m^2,n)\\) matrices. column \\(dA\\), \\(dQ\\) determines  direction along derivative computed. Note routine  silently assumes column \\(dQ\\) represents symmetric matrix (hence \\(dP\\) also symmetric). non_stable (character string) indicates , \\(\\) stable.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/lyapunov_Jacobian.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Jacobian of the Solution of the Lyapunov Equation — lyapunov_Jacobian","text":"List slots P (\\((m^2,n)\\)-dimensional matrix) Solution lyapunov equation J (\\((m^2,n)\\)-dimensional matrix) Jacobian vectorised solution          Lyapunov equation. column \\(J\\)           directional derivative \\(vec(P)\\) along respective columns           \\(dA\\) \\(dQ\\). lambda Eigenvalues \\(\\). is_stable (boolean) \\(\\) stable ?","code":""},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/reference/lyapunov_Jacobian.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Jacobian of the Solution of the Lyapunov Equation — lyapunov_Jacobian","text":"","code":"m = 5  A = matrix(rnorm(m^2), nrow = m, ncol = m) Q = crossprod(matrix(rnorm(m^2), nrow = m, ncol = m)) P = lyapunov(A, Q) all.equal(Q, P - A %*% P %*% t(A)) #> [1] TRUE  n = 6 dA = matrix(rnorm((m^2)*n), nrow = m^2, ncol = n) dQ = matrix(rnorm((m^2)*n), nrow = m^2, ncol = n) for (i in (1:n)) {   # make sure that each column of dQ corresponds to a symmetric matrix!   junk = matrix(dQ[,i], nrow = m, ncol = m)   junk = junk + t(junk)   dQ[,i] = junk } out = lyapunov_Jacobian(A, Q, dA, dQ) all.equal(out$P, P) #> [1] TRUE   eps = 1e-8 theta = rnorm(n) matrix(out$J %*% theta, nrow = m, ncol = m) #>            [,1]        [,2]       [,3]      [,4]       [,5] #> [1,] -612.62057  -28.330498  -79.65568 -400.4749 -447.03020 #> [2,]  -28.33050    2.248446  113.72092  269.5614 -139.72418 #> [3,]  -79.65568  113.720920   -8.32006 -153.0816  -88.88545 #> [4,] -400.47494  269.561449 -153.08156 -118.1101 -290.71174 #> [5,] -447.03020 -139.724183  -88.88545 -290.7117 -284.57288  # compute the derivative via \"finite differences\" dP = lyapunov(A + matrix(dA %*% theta, nrow = m, ncol = m)*eps,                Q + matrix(dQ %*% theta, nrow = m, ncol = m)*eps) all.equal(matrix(out$J %*% theta, nrow = m, ncol = m),            (dP - P)/eps, scale = mean(abs(out$J)), tol = 1e-6) #> [1] \"Mean scaled difference: 7.431809e-06\""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/make_allpass.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an All-Pass Rational Matrix — make_allpass","title":"Create an All-Pass Rational Matrix — make_allpass","text":"Create square, -pass rational matrix statespace  form given \\(,B\\).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/make_allpass.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an All-Pass Rational Matrix — make_allpass","text":"","code":"make_allpass(A, B)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/make_allpass.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an All-Pass Rational Matrix — make_allpass","text":"square \\((s,s)\\) matrix B \\((s,m)\\) matrix","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/make_allpass.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an All-Pass Rational Matrix — make_allpass","text":"stsp object represents -pass          rational matrix.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/make_allpass.html","id":"notes","dir":"Reference","previous_headings":"","what":"Notes","title":"Create an All-Pass Rational Matrix — make_allpass","text":"function intended internal helper function  thus check inputs. See also reflect_poles  reflect_zeroes. \\(,C\\) given can use t(make_allpass(t(), t(C))).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/make_allpass.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an All-Pass Rational Matrix — make_allpass","text":"","code":"m = 2 s = 6 A = matrix(rnorm(s*s), nrow = s, ncol = s) B = matrix(rnorm(s*m), nrow = s, ncol = m)  K = make_allpass(A, B) all.equal(cbind(A,B), cbind(K$A, K$B)) #> [1] TRUE # check that K(z) is all-pass Kf = zvalues(K) all.equal(zvalues(polm(diag(m))) + complex(imaginary = 0),            Kf %r% Ht(Kf) + complex(imaginary = 0)) #> [1] TRUE  # if (A,C) is given, we proceed as follows: C = matrix(stats::rnorm(m*s), nrow = m, ncol = s) K = t(make_allpass(t(A), t(C))) all.equal(rbind(A,C), rbind(K$A, K$C)) #> [1] TRUE # check that K(z) is all-pass Kf = zvalues(K) all.equal(zvalues(polm(diag(m))) + complex(imaginary = 0),            Kf %r% Ht(Kf) + complex(imaginary = 0)) #> [1] TRUE"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/match_vectors.html","id":null,"dir":"Reference","previous_headings":"","what":"Match Two Vectors — match_vectors","title":"Match Two Vectors — match_vectors","text":"Given two vectors x,y length \\(p \\leq q\\) respectively,  routine match_vectors returns integer vector  j, unique elements, x matches y[j]  best possible. procedure uses \"Munkres\" algorithm  solving assignment problem. procedure throws error length  x larger length y.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/match_vectors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match Two Vectors — match_vectors","text":"","code":"match_vectors(x, y = Conj(x))"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/match_vectors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Match Two Vectors — match_vectors","text":"x, y two vectors length \\(p \\leq q\\) respectively.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/match_vectors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Match Two Vectors — match_vectors","text":"\\(p\\)-dimensional integer vector j (unique elements).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/match_vectors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Match Two Vectors — match_vectors","text":"","code":"# Match the roots of two polynomials a1 and a2 p = 5 a1 = rnorm(p+1) a2 = a1 + rnorm(p+1)*(1e-6) # a2 is a \"noisy\" copy of a1 z1 = polyroot(a1) z2 = polyroot(a2)[order(stats::rnorm(p))] # reshuffle the roots of a2 j = match_vectors(z1, z2) print(data.frame(z1 = z1, j = j, `z2[j]` = z2[j], d = z1-z2[j])) #>                    z1 j                z2.j.                          d #> 1  0.226683+1.157318i 5  0.2266827+1.157318i  6.457278e-07+2.66144e-08i #> 2 -0.700311+0.000000i 4 -0.7003123+0.000000i  1.246715e-06+0.00000e+00i #> 3  0.226683-1.157318i 3  0.2266827-1.157318i  6.457278e-07-2.66144e-08i #> 4  1.225857-0.000000i 2  1.2258563-0.000000i  1.021267e-06-0.00000e+00i #> 5 -2.320736-0.000000i 1 -2.3207233-0.000000i -1.266492e-05-0.00000e+00i  # A polynomial with real coefficients has pairs of complex conjugate roots. # However, the roots returned by \"polyroot\" in general do not have this  # property! # Match the roots and their complex conjugates j = match_vectors(z1, Conj(z1)) print(data.frame(z = z1, j = j, `Conj(z[j])` = Conj(z1[j]),                   d = z1-Conj(z1[j]))) #>                     z j          Conj.z.j..                           d #> 1  0.226683+1.157318i 3  0.226683+1.157318i  1.348921e-14-6.661338e-15i #> 2 -0.700311+0.000000i 2 -0.700311-0.000000i  0.000000e+00+3.235485e-14i #> 3  0.226683-1.157318i 1  0.226683-1.157318i -1.348921e-14-6.661338e-15i #> 4  1.225857-0.000000i 4  1.225857+0.000000i  0.000000e+00-1.411610e-14i #> 5 -2.320736-0.000000i 5 -2.320736+0.000000i  0.000000e+00-4.857942e-15i"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/munkres.html","id":null,"dir":"Reference","previous_headings":"","what":"Munkres Assignment Algorithm — munkres","title":"Munkres Assignment Algorithm — munkres","text":"algorithm solves assignment problem: Given set \\(m\\) \"agents\"  \\(n\\) \"tasks\" agent-task specific costs. Find assignment tasks agents  total cost minimal, given following restrictions. task may assigned  one agent agent may assigned one task. total  \\(k=\\min(m,n)\\) assignments required. (E.g. less agents tasks agent gets \"job\", however, \\(n-m\\) tasks remain unaccomplished. )","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/munkres.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Munkres Assignment Algorithm — munkres","text":"","code":"munkres(C)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/munkres.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Munkres Assignment Algorithm — munkres","text":"C (\\((m,n)\\) numeric matrix) \\(C_{ij}\\) represents cost assigning \\(j\\)-th \"job\" \\(\\)-th \"agent\".","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/munkres.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Munkres Assignment Algorithm — munkres","text":"List slots (\\((k,2)\\) dimensional (integer) matrix \\(k=\\min(m,n)\\). matrix           represents optimal assignment. \\(=1,\\ldots,k\\) task                 [,2] assigned agent [,1]. c Total cost (optimal) assignment             c = C[[1,1], [1,2]] + ... + C[[k,1], [k,2]]. C cost matrix.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/munkres.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Munkres Assignment Algorithm — munkres","text":"original references (Munkres 1956)    (Bourgeois Lassalle 1971)  non-square case.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/munkres.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Munkres Assignment Algorithm — munkres","text":"Munkres J (1956). “Algorithms Assignment Transportation Problems.” Journal Society Industrial Applied Mathematics, 5(1). Bourgeois F, Lassalle J (1971). “extension Munkres algorithm assignment problem rectangular matrices.” Commun. ACM, 14, 802-804.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/reference/munkres.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Munkres Assignment Algorithm — munkres","text":"","code":"C = matrix(c (0, 0, 0, 0, 0, 1, 3, 3, 0, 5, 5, 9, 0, 1, 3, 7),             nrow = 4, ncol = 4, byrow = TRUE) out = munkres(C) print(out) #> $a #>      [,1] [,2] #> [1,]    1    4 #> [2,]    2    3 #> [3,]    3    1 #> [4,]    4    2 #>  #> $c #> [1] 4 #>  #> $C #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    0    0 #> [2,]    0    1    3    3 #> [3,]    0    5    5    9 #> [4,]    0    1    3    7 #>"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"Re-export pipe operator %>% turn function composition series imperative statements. extensive description, see function `%>%` package magrittr.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs First argument function right-hand-side pipe operator. rhs Function whose first argument given left-hand-side argument lhs pipe operator.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pipe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pipe operator — %>%","text":"","code":"x = array(stats::rnorm(2*1*3, sd = 0.01), dim = c(2,1,3)) # Instead of pseries(polm(x)) #> ( 2 x 1 ) impulse response with maximum lag = 5  #>        lag=0 [,1]   lag=1 [,1]  lag=2 [,1] lag=3 [,1] lag=4 [,1] lag=5 [,1] #> [1,] -0.003326397 -0.001879204 0.017050906          0          0          0 #> [2,]  0.011131196 -0.003883467 0.002481095          0          0          0 # you can write x %>% polm() %>% pseries() #> ( 2 x 1 ) impulse response with maximum lag = 5  #>        lag=0 [,1]   lag=1 [,1]  lag=2 [,1] lag=3 [,1] lag=4 [,1] lag=5 [,1] #> [1,] -0.003326397 -0.001879204 0.017050906          0          0          0 #> [2,]  0.011131196 -0.003883467 0.002481095          0          0          0"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Methods — plot methods","title":"Plot Methods — plot methods","text":"Plot impulse frequency response functions.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Methods — plot methods","text":"","code":"# S3 method for pseries plot(   x,   x_list = NULL,   xlim = c(\"global\", \"column\", \"subfig\"),   ylim = c(\"row\", \"subfig\", \"global\"),   main = \"impulse response\",   xlab = \"lag (k)\",   ylab = NULL,   subfigure_main = NA,   parse_subfigure_main = FALSE,   style = c(\"gray\", \"bw\", \"bw2\", \"colored\"),   col = NA,   type = \"l\",   lty = \"solid\",   lwd = 1,   pch = 16,   cex.points = 1,   bg.points = \"black\",   legend = NULL,   legend_args = NA,   ... )  # S3 method for zvalues plot(   x,   x_list = NULL,   style = c(\"gray\", \"bw\", \"colored\"),   which = c(\"modulus\", \"phase\", \"nyquist\", \"real\"),   subfigure_main = NA,   xlim = NA,   ylim = NA,   main = NA,   ylab = NA,   xlab = NA,   legend = NULL,   legend_args = NA,   col = NA,   type = \"l\",   lty = \"solid\",   lwd = 1,   pch = 16,   cex.points = 1,   bg.points = \"black\",   ... )"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Methods — plot methods","text":"x pseries zvalues object. x_list (optional) list additional pseries zvalues objects. xlim, ylim determine axis limits subfigures. E.g. xlim = 'column' means subfigures column use x-axis limits. parameter xlim may also contain 2-dimensional vector c(x1,x2). case sub-figures use given limits x-axis. Furthermore limits y-axis computed based corresponding data \"subset\". main (character expression) main title plot xlab (character string expression) label x-axis ylab (character expression) label y-axis subfigure_main scalar (m x n) matrix type \"character\" titles subfigures. subfigure_main scalar character string procedures creates matrix respective titles replacing \"place holders\" 'i_' 'j_' respective row column number. parse_subfigure_main boolean. TRUE titles subfigures parsed expression plotting. See also plotmath usage expressions plot annotations. style (character string) determines appearance plot (background color plot regions, color line style grid lines, axis color, ...) See also style_parameters. col vector line colors type vector plot types. following values possible:  \"p\" points, \"l\" lines,  \"b\" points lines,  \"c\" empty points joined lines, \"o\" overplotted points lines,  \"s\" \"S\" stair steps \"h\" histogram-like vertical lines.  'n' suppresses plotting. lty vector line types. Line types can either specified integers (0=blank, 1=solid (default), 2=dashed, 3=dotted, 4=dotdash, 5=longdash, 6=twodash) one character strings \"blank\", \"solid\", \"dashed\", \"dotted\", \"dotdash\", \"longdash\", \"twodash\", \"blank\" uses ‘invisible lines’ (.e., draw ). lwd vector line widths. pch vector plotting character symbols. See points possible values. cex.points vector scales plotting symbols. bg.points vector fill color open plot symbols. legend (character expression vector). NULL legend produced. legend_args (optional) list parameters legend.  legend title can included legend_args = list(title = my_legend_title). Note slots x, y ignored legend always put right hand side plot.  See also legend. ... used. (character string) plot (used zvalues  objects). See details.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/plot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Methods — plot methods","text":"plot methods return (invisibly) function, subfig say, may used          add additional graphic elements subfigures. call opar = subfig(,j) creates new (sub) plot (,j)-position suitable margins          axis limits. See examples .","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/plot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot Methods — plot methods","text":"parameter determines plot case zvalues objects. modulus plot moduli abs(x[,j]) versus frequencies -Arg(z)/(2*pi). phase plot arguments Arg(x[,j]) versus frequencies -Arg(z)/(2*pi). nyquist plot imaginary part Im(x[,j]) versus real part Re(x[,j]). real plot real part Re(x[,j]) versus real part Re(z). choices = 'modulus', = 'phase' = 'nyquist'  typically used case, rational matrix evaluated (regular) grid  points unit circle ($|z|=1$). choice = 'real' course designed  case z's real numbers. NA values (optional) parameters mean methods use suitable default values.  (frequency response plots, e.g. labels x- y-axis chosen according  parameter .) NUll values (optional) parameters mean respective graphic element omitted. E.g. subfigure_main=NULL skips titles subfigures. titles (m,n) subfigures determined parameter subfigure_main.  One may pass \\((m,n)\\) matrix character strings procedure. Alternatively one may also  provide expression vector dim attribute subfigure_main[,j]  returns expression used title \\((,j)\\)-th subfigure.  E.g. $(2,2)$ rational matrix one might use subfigure_main scalar (character string expression) procedures creates  respective titles replacing \"place holders\" i_ j_  respective row column number. See examples . parameter xlim determines x-axis subfigures.  xlim='subfigure' subfigure gets  x-axis (different limits). case xlim='column' subfigues   column share common x-axis (common limits). case xlim = 'global'  means subfigures (x-) limits x-axis displayed  subfigures last row. parameter ylim handled analogously. one object plotted (optional parameter x_list empty) suitable legend may added parameters legend, legend_args.  Suppose \\(k\\) objects plotted, legend  character (expression) vector length k. \"style\" parameters col, type, ..., bg.points determine appearance  \"lines\" k objects. (necessary values \"recycled\".) plot methods use internal helper function plot_3D.","code":"subfigure_main = expression(Alpha, Beta, Gamma, Delta) dim(subfigure_main) = c(2,2)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/plot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Methods — plot methods","text":"","code":"# Example for PSERIES ####################  # Generate a random, stable rational matrix a(z) in state space form (m = 3, n = 2, s = 4). a = test_stsp(dim = c(3,2), s = 4, bpoles = 1)  # Generate a power series from this state space system x = pseries(a, lag.max = 25)  # create 'barplot'-like plot of the impulse response #   the parameter 'lwd' has to be chosen accordingly #   to the plot size and the number of lags! par(lend = 'butt') # line end style: butt line caps plot(x, type = 'h', lwd = 10, col = 'blue')   par(lend = 'round') # reset line end style to the default: rounded line caps   # Example for different plot types involving ZVALUES ####################  x = zvalues(a, n.f = 256) plot(x, style = 'bw')  plot(x, which = 'phase')  plot(x, which = 'nyquist')    # Example for ZVALUES ####################  # Create a random polynomial  matrix (2,2) a = test_polm(dim = c(2,2), degree = 2, random = TRUE)  # grid of x-values x = seq(from = -2, to = 2, length.out = 101)   subfig = plot(zvalues(a, z = x),                x_list = list(zvalues(derivative(a), z = x),                              zvalues(derivative(derivative(a)), z = x)),                style = 'colored',                which = 'real',                ylim = 'subfig',                legend = c(expression(A), expression(dA/dx), expression(d^2*A/d^2*x)),                subfigure_main = \"a(i_, j_)(z)\")                # Add horizontal/vertical lines        opar = subfig(1,1)  # save graphic parameters da = derivative(a) for (i in (1:2)) {    for (j in (1:2)) {       subfig(i,j)       graphics::abline(h = 0, col = 'darkgray')       graphics::abline(v = polyroot(unclass(da[i,j])), col = 'darkgray') }}   graphics::par(opar)  # reset graphic parameters"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/plot_3D.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot 3D Arrays — plot_3D","title":"Plot 3D Arrays — plot_3D","text":"internal helper function plots data arranged 3-dimensional arrays. base application follows. Let x,y two 3-dimensional arrays dimension c(m,n,l). plot_3D splits device region matrix like array (m times n) subfigures. (,j)-th subfigure y[,j,] plotted x[,j,].","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/plot_3D.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot 3D Arrays — plot_3D","text":"","code":"plot_3D(   x,   y,   xlim = c(\"subfig\", \"column\", \"global\"),   ylim = c(\"subfig\", \"row\", \"global\"),   log = \"\",   main = NULL,   xlab = NULL,   ylab = NULL,   subfigure_main = \"(i_,j_)-th entry\",   parse_subfigure_main = FALSE,   style = c(\"gray\", \"bw\", \"bw2\", \"colored\"),   col = NA,   type = \"l\",   lty = \"solid\",   lwd = 1,   pch = 16,   cex.points = 1,   bg.points = \"black\",   legend = NULL,   legend_args = NA )"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/plot_3D.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot 3D Arrays — plot_3D","text":"x list 3D-arrays (define 'x'-values) y list 3D-arrays (define 'y'-values) xlim, ylim determine axis limits subfigures. E.g. xlim = 'column' means subfigures column use x-axis limits. parameter xlim may also contain 2-dimensional vector c(x1,x2). case sub-figures use given limits x-axis. Furthermore limits y-axis computed based corresponding data \"subset\". log character string contains \"x\" x axis logarithmic, \"y\" y axis logarithmic \"xy\" \"yx\" axes logarithmic. main (character expression) main title plot xlab (character string expression) label x-axis ylab (character expression) label y-axis subfigure_main scalar (m x n) matrix type \"character\" titles subfigures. subfigure_main scalar character string procedures creates matrix respective titles replacing \"place holders\" 'i_' 'j_' respective row column number. parse_subfigure_main boolean. TRUE titles subfigures parsed expression plotting. See also plotmath usage expressions plot annotations. style (character string) determines appearance plot (background color plot regions, color line style grid lines, axis color, ...) See also style_parameters. col vector line colors type vector plot types. following values possible:  \"p\" points, \"l\" lines,  \"b\" points lines,  \"c\" empty points joined lines, \"o\" overplotted points lines,  \"s\" \"S\" stair steps \"h\" histogram-like vertical lines.  'n' suppresses plotting. lty vector line types. Line types can either specified integers (0=blank, 1=solid (default), 2=dashed, 3=dotted, 4=dotdash, 5=longdash, 6=twodash) one character strings \"blank\", \"solid\", \"dashed\", \"dotted\", \"dotdash\", \"longdash\", \"twodash\", \"blank\" uses ‘invisible lines’ (.e., draw ). lwd vector line widths. pch vector plotting character symbols. See points possible values. cex.points vector scales plotting symbols. bg.points vector fill color open plot symbols. legend (character expression vector). NULL legend produced. legend_args (optional) list parameters legend.  legend title can included legend_args = list(title = my_legend_title). Note slots x, y ignored legend always put right hand side plot.  See also legend.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/plot_3D.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot 3D Arrays — plot_3D","text":"function (\"closure\"), subfig say, may add additional         graphical elements subfigures. call opar = subfig(,j) sets         coordinate system margins figure coordinates one may add lines, text, points, ...         (,j)-th subfigure.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/plot_3D.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot 3D Arrays — plot_3D","text":"function mainly used plot methods, see plot methods. information parameters col, type, lty, ...,bg.points see plot.default. helper function makes basic checks given parameters.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/plot_axes.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Grid Lines, Axes and Axes Labels — plot_axes","title":"Plot Grid Lines, Axes and Axes Labels — plot_axes","text":"tools plots grid lines,axes axes titles/labels. x-axis may date/time axis.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/plot_axes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Grid Lines, Axes and Axes Labels — plot_axes","text":"","code":"plot_axes(   axes = c(TRUE, TRUE, FALSE, FALSE),   tick_labels = axes,   x_date = 0,   titles = rep(NA_character_, 4),   style = style_parameters(\"bw\"),   parse_titles = FALSE )"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/plot_axes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Grid Lines, Axes and Axes Labels — plot_axes","text":"axes 4-dimensional boolean vector, indicating whether axis put respective side plot. tick_labels 4-dimensional boolean vector, indicating whether respective axis tick-labels. x_date scalar number, used convert (numeric) x-axis limits xlim date/time object. x_date class POSIXct limits converted .POSIXct(xlim, origin = x_date). x_date class Date limits converted .Date(xlim, origin = x_date). Otherwise coercion performed. Finally graphics::Axis(x = xlim, ...) called actual plotting x-axis. titles 4-dimensional character vector. respective entry NA label/title put side plot. style list \"style\" parameters returned style_parameters. parse_titles TRUE titles coerced expression plotting.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/plot_axes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Grid Lines, Axes and Axes Labels — plot_axes","text":"(invisible) NULL.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/plot_axes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Grid Lines, Axes and Axes Labels — plot_axes","text":"","code":"if (FALSE) { date = seq(as.Date(\"2019/1/1\"), by = \"month\", length.out = 24) titles = c(NA, 'y','main', NA) plot(date, 1:24, axes = FALSE, xlab = NA, ylab = NA) plot_axes(axes = c(TRUE, FALSE, FALSE, TRUE), titles = titles,           style = style_parameters('gray'), x_date = date[1] - as.numeric(date[1])) points(date, 1:24) }"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/poles_and_zeroes.html","id":null,"dir":"Reference","previous_headings":"","what":"Poles and Zeroes — poles and zeroes","title":"Poles and Zeroes — poles and zeroes","text":"Compute poles zeroes rational matrix. polynomial matrices rational matrices  left matrix fraction form poles (zeroes) computed via (reciprocals )  eigenvalues associated companion matrices, see also companion_matrix.  statespace realizations poles computed via (reciprocals )  eigenvalues state transition matrix \\(\\) zeroes  eigenvalues state transition matrix \\(-BD^{-1}C\\) inverse used.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/poles_and_zeroes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Poles and Zeroes — poles and zeroes","text":"","code":"poles(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)  zeroes(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)  # S3 method for polm zeroes(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)  # S3 method for lpolm zeroes(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)  # S3 method for lmfd zeroes(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)  # S3 method for rmfd zeroes(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)  # S3 method for stsp zeroes(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)  # S3 method for polm poles(x, ...)  # S3 method for lmfd poles(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)  # S3 method for rmfd poles(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)  # S3 method for stsp poles(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/poles_and_zeroes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Poles and Zeroes — poles and zeroes","text":"x object represents rational matrix  (.e. polm, lmfd stsp object). tol Double. Default set sqrt(.Machine$double.eps). Required decide root considered \"infinity\". print_message Boolean. Default set TRUE. Prints message roots \"infinity \" discarded. ... used.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/poles_and_zeroes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Poles and Zeroes — poles and zeroes","text":"Vector poles, respectively zeroes.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/poles_and_zeroes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Poles and Zeroes — poles and zeroes","text":"methods return numerically reliable correct results cases.  details see vignette Rational Matrices. Zeroes computed square, non singular matrices zero        \\(z=0\\). matrix evaluated \\(z=0\\) close singular,        results may unreliable. procedures use threshold tol order decide whether        small eigenvalue returned eigen corresponds        \"true zero\" eigenvalue . pair \\(,b\\) polynomials LMFD left coprime        pole/zero cancellation occurs. taken account procedures. Hence,        case, results also contain spurious poles/zeroes. happens        also non minimal state space realizations.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/poles_and_zeroes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Poles and Zeroes — poles and zeroes","text":"","code":"# zeroes of polynomial matrices #############################################  # scalar polynomial ### (a = polm(c(1, 0, 0, 0.5, 0))) #> ( 1 x 1 ) matrix polynomial with degree <= 4  #>      z^0 [,1] z^1 [,1] z^2 [,1] z^3 [,1] z^4 [,1] #> [1,]        1        0        0      0.5        0 (z = zeroes(a)) #> [1] -1.259921+0.000000i  0.629961-1.091124i  0.629961+1.091124i  # compare with the result of \"polyroot\" all.equal(sort(z), sort(polyroot(as.vector(a)))) #> [1] TRUE  # zero degree polynomial (have no zeroes) ### zeroes(polm(diag(3))) #> numeric(0)  # (2 x 2) polynomial of degree 2 ###  a = polm(dbind(d = 3, diag(2), test_array(dim = c(2,2,2)))) (z = zeroes(a)) #> [1] -0.002994225  0.265114779 -0.991220211 -1.270900343  # check the rank of a(z) at the computed zeroes  az = zvalues(a, z) apply(az, MARGIN = 3, FUN = function(x) {d = svd(x)$d; min(d)/max(d)}) #> [1] 1.403359e-16 8.297615e-17 1.374392e-14 0.000000e+00  if (FALSE) { # the following examples throw an error zeroes(polm(c(0, 0, 0, 0.5))) # constant term is zero zeroes(polm(test_array(dim = c(2, 1, 3)))) # non-square polynomial zeroes(polm(test_array(dim = c(2, 2, 0)))) # zero polynomial }   # zeroes of a Laurent polynomial ################################# (lp = lpolm(1:5, min_deg = -7)) #> ( 1 x 1 ) Laurent polynomial matrix with degree <= -3, and minimal degree >= -7 #>      z^-7 [,1] z^-6 [,1] z^-5 [,1] z^-4 [,1] z^-3 [,1] #> [1,]         1         2         3         4         5 (p = polm(1:5)) #> ( 1 x 1 ) matrix polynomial with degree <= 4  #>      z^0 [,1] z^1 [,1] z^2 [,1] z^3 [,1] z^4 [,1] #> [1,]        1        2        3        4        5 zeroes(p) #> [1] -0.5378323-0.3582847i -0.5378323+0.3582847i  0.1378323-0.6781544i #> [4]  0.1378323+0.6781544i zeroes(lp) #> [1] -0.5378323-0.3582847i -0.5378323+0.3582847i  0.1378323-0.6781544i #> [4]  0.1378323+0.6781544i   # zeroes of a rational matrix in LMFD form #################################  c = lmfd(test_polm(dim = c(2,2), degree = 3, random = TRUE),          test_polm(dim = c(2,2), degree = 1, random = TRUE)) (z = zeroes(c)) #> [1] -0.8437908 -1.4784083 all.equal(z, zeroes(c$b)) #> [1] TRUE   # zeroes of a rational matrix in RMFD form #################################  k = rmfd(c = test_polm(dim = c(2,2), degree = 3, random = TRUE),          d = test_polm(dim = c(2,2), degree = 1, random = TRUE)) (z = zeroes(k)) #> [1]  0.3108737 -0.7265708 all.equal(z, zeroes(k$d)) #> [1] TRUE   # zeroes of a rational matrix in statespace form ###########################  k = stsp(A = matrix(rnorm(3*3), nrow = 3, ncol = 3),          B = matrix(rnorm(3*2), nrow = 3, ncol = 2),          C = matrix(rnorm(3*2), nrow = 2, ncol = 3),          D = matrix(rnorm(2*2), nrow = 2, ncol = 2)) (z = zeroes(k, tol = 0)) #> [1] 0.05053895+0.0000000i 0.13173966-0.6012227i 0.13173966+0.6012227i all.equal(z, 1/(eigen(k$A - k$B %*% solve(k$D, k$C), only.values = TRUE)$values)) #> [1] TRUE  if (FALSE) { k = stsp(k$A, k$B, k$C,           D = matrix(rnorm(2*1), nrow = 2, ncol = 1)[,c(1,1)])  # D is singular zeroes(k)                                                      # zeroes() throws an error  k = stsp(k$A, k$B[,1,drop = FALSE], k$C, k$D[,1,drop = FALSE]) # (2 x 1) rational matrix zeroes(k)                          # throws an error, since k is not square }  # poles of polynomial matrices #############################################  # polynomials have no poles ### poles(test_polm(dim = c(2,1), degree = 2, random = TRUE))  #> numeric(0)  # poles of a rational matrix in LMFD form ##################################  (z = poles(c)) #> [1] -0.1489556+0.000000i -0.5366348+0.000000i  1.2358720-0.212441i #> [4]  1.2358720+0.212441i -1.8012843-1.557224i -1.8012843+1.557224i all.equal(z, zeroes(c$a)) #> [1] TRUE  # poles of a rational matrix in RMFD form ##################################  (z = poles(c)) #> [1] -0.1489556+0.000000i -0.5366348+0.000000i  1.2358720-0.212441i #> [4]  1.2358720+0.212441i -1.8012843-1.557224i -1.8012843+1.557224i all.equal(z, zeroes(c$a)) #> [1] TRUE  # poles of a rational matrix in statespace form ###########################  (z = poles(k, tol = 0)) #> [1] -0.4452459+0.0000000i  0.1281198-0.7713463i  0.1281198+0.7713463i all.equal(z, 1/(eigen(k$A, only.values = TRUE)$values)) #> [1] TRUE"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/polm.html","id":null,"dir":"Reference","previous_headings":"","what":"Constructor for Polynomial Matrices — polm","title":"Constructor for Polynomial Matrices — polm","text":"polm objects represent polynomial matrices $$(z) = a_0 + a_1 z + \\cdots + a_p z^p$$ matrix \\((z)\\) \\((m,n)\\) dimensional polynomial matrix (.e. coefficients  \\(a_i\\) \\((m,n)\\) dimensional real complex valued matrices)  polm object stores coefficients (m,n,p+1) dimensional (numeric complex)  array together class attribute c(\"polm\",\"ratm\").   constructor function polm() takes (numeric complex) vector, matrix  3-dimensional array returns polm object.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/polm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for Polynomial Matrices — polm","text":"","code":"polm(a)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/polm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor for Polynomial Matrices — polm","text":"either (numeric complex) vector, matrix 3-D array. vector coerced scalar  (.e. \\((1,1)\\)-dimensional) polynomial matrix gives polynomial matrix zero degree.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/polm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Constructor for Polynomial Matrices — polm","text":"object class polm.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/polm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Constructor for Polynomial Matrices — polm","text":"dimensions 3-dimensional array may also zero. particular,  third dimension zero, polm object interpreted zero polynomial. important methods functions class look \"see also\" section.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/reference/polm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Constructor for Polynomial Matrices — polm","text":"","code":"# (1 x 1) polynomial matrix a(z) =  0 + 1z + 2z^2 polm(0:2) #> ( 1 x 1 ) matrix polynomial with degree <= 2  #>      z^0 [,1] z^1 [,1] z^2 [,1] #> [1,]        0        1        2  # (2 x 3) polynomial matrix a(z) = a0 (degree is zero) polm(diag(1, nrow = 2, ncol = 3)) #> ( 2 x 3 ) matrix polynomial with degree <= 0  #>      z^0 [,1]  [,2]  [,3] #> [1,]        1     0     0 #> [2,]        0     1     0  # random (2 x 3) polynomial matrix a(z) = a0 + a1 z + a2 z^2 + a3 z^3 (degree = 3) polm(array(stats::rnorm(2*3*4), dim = c(2,3,4))) #> ( 2 x 3 ) matrix polynomial with degree <= 3  #>       z^0 [,1]     [,2]       [,3]  z^1 [,1]       [,2]       [,3]   z^2 [,1] #> [1,] 0.6370071 2.137362 -0.3834814 0.6609966 -0.1441613 -0.4183031 0.62482433 #> [2,] 0.5058216 0.869301  1.0289366 1.4180023  1.1997984  1.2666229 0.08006296 #>            [,2]      [,3]    z^3 [,1]      [,2]       [,3] #> [1,] -0.3267119 -1.022723  0.54688930 0.2083001 -0.7496543 #> [2,]  0.2870435  0.459892 -0.02820572 0.6123943  0.8461007  # random (2 x 1) polynomial matrix with complex coefficients (degree = 2) a = polm(array(complex(real = stats::rnorm(2*1*3),                 imaginary = stats::rnorm(2*1*3)), dim = c(2,1,3))) is.polm(a) #> [1] TRUE dim(a) #> m n p  #> 2 1 2  str(a) #> ( 2 x 1 ) matrix polynomial with degree <= 2 print(a, digits = 3) #> ( 2 x 1 ) matrix polynomial with degree <= 2  #>          z^0 [,1]      z^1 [,1]      z^2 [,1] #> [1,] 0.532+0.578i -1.514-1.296i  0.372-0.958i #> [2,] 0.516+0.903i -0.288-2.804i -0.820-0.166i"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/polm2fwd.html","id":null,"dir":"Reference","previous_headings":"","what":"Transforms to Polynomial in Forward Shift — polm2fwd","title":"Transforms to Polynomial in Forward Shift — polm2fwd","text":"Transform polm object polynomial forward shift (represented lpolm object), .e. transform $$(z) = a_0 + a_1 z^1 + \\cdots + a_p z^p$$        $$(z) = a_0 + a_1 z^{-1} + \\cdots + a_p z^{-p}$$","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/polm2fwd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transforms to Polynomial in Forward Shift — polm2fwd","text":"","code":"polm2fwd(polm_obj)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/polm2fwd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transforms to Polynomial in Forward Shift — polm2fwd","text":"polm_obj polm object","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/polm2fwd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transforms to Polynomial in Forward Shift — polm2fwd","text":"lpolm object","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/polm2fwd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transforms to Polynomial in Forward Shift — polm2fwd","text":"","code":"(p = test_polm(degree = 3)) #> ( 1 x 1 ) matrix polynomial with degree <= 3  #>      z^0 [,1] z^1 [,1] z^2 [,1] z^3 [,1] #> [1,]      110      111      112      113 polm2fwd(p) #> ( 1 x 1 ) Laurent polynomial matrix with degree <= 0, and minimal degree >= -3 #>      z^-3 [,1] z^-2 [,1] z^-1 [,1] z^0 [,1] #> [1,]       113       112       111      110"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/polm_div.html","id":null,"dir":"Reference","previous_headings":"","what":"Division Algorithm for Polynomial Matrices — polm_div","title":"Division Algorithm for Polynomial Matrices — polm_div","text":"given polynomial matrices \\((z), b(z)\\) compute two matrices  \\(c(z), d(z)\\)  $$(z) = c(z) b(z) + d(z)$$ degree \\(d(z)\\) smaller degree \\(b(z)\\).  matrix \\(b(z)\\) must square non singular leading coefficient  matrix! matrices must compatible, .e. number columns \\((z)\\)  must equal number rows (columns) \\(b(z)\\).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/polm_div.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Division Algorithm for Polynomial Matrices — polm_div","text":"","code":"polm_div(a, b)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/polm_div.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Division Algorithm for Polynomial Matrices — polm_div","text":", b Two compatible polynomial matrices.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/polm_div.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Division Algorithm for Polynomial Matrices — polm_div","text":"List two slots qu contains polynomial \\(c(z)\\) rem contains polynomial \\(d(z)\\).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/polm_div.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Division Algorithm for Polynomial Matrices — polm_div","text":"","code":"a = test_polm(dim = c(3,2), degree = 4, random = TRUE) b = test_polm(dim = c(2,2), degree = 2, random = TRUE) (out = polm_div(a, b)) #> $qu #> ( 3 x 2 ) matrix polynomial with degree <= 2  #>        z^0 [,1]       [,2]   z^1 [,1]       [,2]   z^2 [,1]       [,2] #> [1,] -345854.61 -3111.8024  4454.6890  40.080612 -57.407038 -0.7672161 #> [2,]  473715.73  4261.4194 -6101.8933 -54.875451  79.217440  1.5028455 #> [3,]   29308.41   263.8579  -377.8844  -2.772114   4.734525  1.2283036 #>  #> $rem #> ( 3 x 2 ) matrix polynomial with degree <= 1  #>        z^0 [,1]       [,2]   z^1 [,1]       [,2] #> [1,] -119890.26  571691.16  237079.10 -735258.61 #> [2,]  164214.35 -783042.50 -324724.72 1007084.13 #> [3,]   10161.38  -48445.08  -20091.09   62308.33 #>  all.equal(a, out$qu %r% b + out$rem) #> [1] TRUE"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/print.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Methods — print methods","title":"Print Methods — print methods","text":"Printing rational matrix objects.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/print.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Methods — print methods","text":"","code":"# S3 method for lpolm print(   x,   digits = NULL,   format = c(\"i|jz\", \"i|zj\", \"iz|j\", \"zi|j\", \"i|j|z\", \"character\"),   ... )  # S3 method for polm print(   x,   digits = NULL,   format = c(\"i|jz\", \"i|zj\", \"iz|j\", \"zi|j\", \"i|j|z\", \"character\"),   ... )  # S3 method for lmfd print(   x,   digits = NULL,   format = c(\"i|jz\", \"i|zj\", \"iz|j\", \"zi|j\", \"i|j|z\", \"character\"),   ... )  # S3 method for rmfd print(   x,   digits = NULL,   format = c(\"i|jz\", \"i|zj\", \"iz|j\", \"zi|j\", \"i|j|z\", \"character\"),   ... )  # S3 method for stsp print(x, digits = NULL, ...)  # S3 method for pseries print(   x,   digits = NULL,   format = c(\"i|jz\", \"i|zj\", \"iz|j\", \"zi|j\", \"i|j|z\"),   ... )  # S3 method for zvalues print(   x,   digits = NULL,   format = c(\"i|jz\", \"i|zj\", \"iz|j\", \"zi|j\", \"i|j|z\"),   ... )"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/print.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Methods — print methods","text":"x rational matrix object, .e. polm, lpolm, lmfd, rmfd, stsp, pseries zvalues object. digits (integer) non NULL correspondingly rounded numbers printed,  see round. format (character string) selects specific output formats. Note  stsp objects format option. option 'character'  implemented polynomials, Laurent polynomials, LMFDs RMFDs real coefficients, se ... parameters ignored.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/print.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Methods — print methods","text":"invisible(x)","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/print.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print Methods — print methods","text":"","code":"# for polynomials six different print formats are implemented ################### a = test_polm(dim = c(2,3), degree = 2, random = TRUE)  for (fmt in c(\"i|jz\", \"i|zj\", \"iz|j\", \"zi|j\", \"i|j|z\", \"character\")) {    cat('\\nformat =', fmt, '\\n')    print(a, digits = 2, format = fmt) } #>  #> format = i|jz  #> ( 2 x 3 ) matrix polynomial with degree <= 2  #>      z^0 [,1]  [,2]  [,3] z^1 [,1]  [,2]  [,3] z^2 [,1]  [,2]  [,3] #> [1,]    -1.61 -0.11  0.36    -1.77  0.39  0.00    -2.02 -0.65  1.00 #> [2,]    -0.47 -2.02  0.33    -1.64  1.63 -0.17     1.50  0.71  0.67 #>  #> format = i|zj  #> ( 2 x 3 ) matrix polynomial with degree <= 2  #>      [,1] z^0   z^1   z^2 [,2] z^0  z^1   z^2 [,3] z^0   z^1  z^2 #> [1,]    -1.61 -1.77 -2.02    -0.11 0.39 -0.65     0.36  0.00 1.00 #> [2,]    -0.47 -1.64  1.50    -2.02 1.63  0.71     0.33 -0.17 0.67 #>  #> format = iz|j  #> ( 2 x 3 ) matrix polynomial with degree <= 2  #>           [,1]  [,2]  [,3] #> z^0 [1,] -1.61 -0.11  0.36 #>     [2,] -0.47 -2.02  0.33 #> z^1 [1,] -1.77  0.39  0.00 #>     [2,] -1.64  1.63 -0.17 #> z^2 [1,] -2.02 -0.65  1.00 #>     [2,]  1.50  0.71  0.67 #>  #> format = zi|j  #> ( 2 x 3 ) matrix polynomial with degree <= 2  #>           [,1]  [,2]  [,3] #> [1,] z^0 -1.61 -0.11  0.36 #>      z^1 -1.77  0.39  0.00 #>      z^2 -2.02 -0.65  1.00 #> [2,] z^0 -0.47 -2.02  0.33 #>      z^1 -1.64  1.63 -0.17 #>      z^2  1.50  0.71  0.67 #>  #> format = i|j|z  #> ( 2 x 3 ) matrix polynomial with degree <= 2  #> , , z^0 #>  #>       [,1]  [,2] [,3] #> [1,] -1.61 -0.11 0.36 #> [2,] -0.47 -2.02 0.33 #>  #> , , z^1 #>  #>       [,1] [,2]  [,3] #> [1,] -1.77 0.39  0.00 #> [2,] -1.64 1.63 -0.17 #>  #> , , z^2 #>  #>       [,1]  [,2] [,3] #> [1,] -2.02 -0.65 1.00 #> [2,]  1.50  0.71 0.67 #>  #>  #> format = character  #> ( 2 x 3 ) matrix polynomial with degree <= 2  #>                          [,1]                     [,2]                    [,3] #> [1,]  -1.61 - 1.77z - 2.02z^2  -0.11 + 0.39z - 0.65z^2              0.36 + z^2 #> [2,]   -0.47 - 1.64z + 1.5z^2  -2.02 + 1.63z + 0.71z^2  0.33 - 0.17z + 0.67z^2   # \"empty\" (2 x 0) polynomial matrix (degree = 2) a = test_polm(dim = c(2,0), degree = 0) print(a) #> ( 2 x 0 ) matrix polynomial with degree <= -1   # random (2 x 1) polynomial matrix with complex coefficients (degree = 2) a = polm(array(complex(real = stats::rnorm(2*1*3),                         imaginary = stats::rnorm(2*1*3)), dim = c(2,1,3))) print(a, digits = 2) #> ( 2 x 1 ) matrix polynomial with degree <= 2  #>         z^0 [,1]    z^1 [,1]    z^2 [,1] #> [1,] -1.63-1.25i  1.41-1.39i -0.53+0.49i #> [2,]  0.38+0.88i -0.25+0.45i -0.37+0.72i if (FALSE) { # the format option 'character' is only implemented for polynomials matrices  # with real coefficients! print(a, digits = 2, format = 'character') }  # print a rational matrix in statespace form a = test_stsp(dim = c(3,3), s = 2) print(a, digits = 2) #> statespace realization [3,3] with s = 2 states #>       s[1]  s[2]  u[1]  u[2]  u[3] #> s[1] -0.75  0.07 -0.50 -0.06  1.09 #> s[2]  0.15 -1.67 -0.41 -0.01 -0.16 #> x[1] -2.51 -0.15  1.00  0.00  0.00 #> x[2] -1.00  1.48  0.00  1.00  0.00 #> x[3]  0.21 -0.84  0.00  0.00  1.00  # print a rational matrix in 'lmfd' form  a = test_lmfd(dim = c(2,3), degrees = c(2,1)) print(a, digits = 2, format = 'character') #> ( 2 x 3 ) left matrix fraction description a^(-1)(z) b(z) with degrees (p = 2, q = 1) #> left factor a(z): #>                      [,1]                [,2] #> [1,]  1 - 0.14z - 0.93z^2    -0.39z - 0.23z^2 #> [2,]      1.03z + 1.26z^2  1 + 0.37z + 0.2z^2  #> right factor b(z): #>                [,1]          [,2]          [,3] #> [1,]   0.43 - 0.43z  0.34 + 0.77z   0.07 - 1.5z #> [2,]  -0.26 + 0.49z  0.63 - 0.59z  0.86 + 0.55z   # print impulse response  print(pseries(a), format = 'i|zj', digits = 2) #> ( 2 x 3 ) impulse response with maximum lag = 5  #>      [,1] lag=0  lag=1  lag=2  lag=3  lag=4  lag=5 [,2] lag=0  lag=1  lag=2 #> [1,]       0.43  -0.47   0.33  -0.38   0.33  -0.29       0.34   1.07   0.15 #> [2,]      -0.26   0.14  -0.06   0.25  -0.10   0.13       0.63  -1.17  -1.21 #>       lag=3  lag=4  lag=5 [,3] lag=0  lag=1  lag=2  lag=3  lag=4  lag=5 #> [1,]   0.27  -0.42   0.03       0.07  -1.16   0.16  -0.67   0.62  -0.33 #> [2,]  -0.82   0.08   0.22       0.86   0.16   0.87   0.94  -0.03   0.04  # print frequency response  print(zvalues(a), format = 'iz|j', digits = 2) #> ( 2 x 3 ) frequency response #>                             [,1]        [,2]        [,3] #>          z=1+0i [1,]  0.11+0.00i  1.35+0.00i -1.06+0.00i #>                 [2,] -0.02+0.00i -1.93+0.00i  2.44+0.00i #>  z=0.309-0.951i [1,]  0.28+0.22i  0.09-1.13i  0.21+0.89i #>                 [2,] -0.31+0.03i  2.10+0.96i -0.49+0.25i #> z=-0.809-0.588i [1,]  0.32+0.69i -0.02-0.63i  0.09+1.08i #>                 [2,] -0.13-0.24i  0.95+0.14i  1.43+0.18i #> z=-0.809+0.588i [1,]  0.32-0.69i -0.02+0.63i  0.09-1.08i #>                 [2,] -0.13+0.24i  0.95-0.14i  1.43-0.18i #>  z=0.309+0.951i [1,]  0.28-0.22i  0.09+1.13i  0.21-0.89i #>                 [2,] -0.31-0.03i  2.10-0.96i -0.49-0.25i"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/print_3D.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper for Printing Matrix (Laurent) Polynomials — print_3D","title":"Helper for Printing Matrix (Laurent) Polynomials — print_3D","text":"Called rationalmatrices methods print S3 generic.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/print_3D.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper for Printing Matrix (Laurent) Polynomials — print_3D","text":"","code":"print_3D(   a,   digits = NULL,   format = c(\"i|jz\", \"i|zj\", \"iz|j\", \"zi|j\", \"i|j|z\", \"character\"),   laurent = FALSE )"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/print_3D.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper for Printing Matrix (Laurent) Polynomials — print_3D","text":"Array 3 dimensions, representing polynomial Laurent polynomial digits Default NULL. Otherwise integer specifying number digits coefficients printed,  see round. format Default \"|jz\", .e. matrix polynomial printed \"z part slowest moving index. vertical bar designates separation across array dimensions (one bar = two array dimensions, two bars = array dimension 3). addition multiple ordering options regarding row-index , column-index j, polynomial power z,  also option character (partial matching enabled format = \"c\" gives desired result) prints univariate (Laurent) polynomial matrix appropriate numbers rows columns. Note stsp objects format option.  option 'character' implemented polynomials, Laurent polynomials, LMFDs RMFDs real coefficients. laurent Boolean integer. Default set FALSE. one deals Laurent polynomials, integer corresponding minimal degree Laurent polynomial supplied.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/print_3D.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper for Printing Matrix (Laurent) Polynomials — print_3D","text":"Printed (Laurent) polynomial matrix","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/prune.html","id":null,"dir":"Reference","previous_headings":"","what":"Prune (Laurent) Matrix Polynomial — prune","title":"Prune (Laurent) Matrix Polynomial — prune","text":"Performs three steps simplify matrix polynomial. leading coefficients absolute values real imaginary parts   less equal tol set zero.   Laurent polynomials, happening direction. zero leading coefficient matrices dropped.    Laurent polynomials, happening coefficient matrices pertaining low powers. absolute values imaginary parts coefficients less       equal tol coefficients set real values. Empty polynomial matrices (.e. matrices zero rows columns) set polynomial zero degree.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/prune.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prune (Laurent) Matrix Polynomial — prune","text":"","code":"prune(x, tol = sqrt(.Machine$double.eps), brutal = FALSE)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/prune.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prune (Laurent) Matrix Polynomial — prune","text":"x polm lpolm object. tol Double. Tolerance parameter. Default set sqrt(.Machine$double.eps). brutal Boolean. Default set FALSE. TRUE, small elements set zero (irrespective whether leading coefficients ).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/prune.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prune (Laurent) Matrix Polynomial — prune","text":"Laurent matrix polynomial, .e. polm lpolm object.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/prune.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prune (Laurent) Matrix Polynomial — prune","text":"","code":"x = polm(array(c(1,0,0,0,                  0,1,0,0,                  0,0,1,0,                  0,0,0,1,                  0,0,0,0), dim = c(2,2,5)) + 1e-4) x #> ( 2 x 2 ) matrix polynomial with degree <= 4  #>      z^0 [,1]  [,2] z^1 [,1]  [,2] z^2 [,1]   [,2] z^3 [,1]   [,2] z^4 [,1] #> [1,]   1.0001 1e-04   0.0001 1e-04    1e-04 1.0001    1e-04 0.0001    1e-04 #> [2,]   0.0001 1e-04   1.0001 1e-04    1e-04 0.0001    1e-04 1.0001    1e-04 #>       [,2] #> [1,] 1e-04 #> [2,] 1e-04 prune(x, tol = 1e-3) #> ( 2 x 2 ) matrix polynomial with degree <= 3  #>      z^0 [,1]  [,2] z^1 [,1]  [,2] z^2 [,1]   [,2] z^3 [,1]   [,2] #> [1,]   1.0001 1e-04   0.0000 1e-04        0 1.0001        0 0.0000 #> [2,]   0.0001 1e-04   1.0001 1e-04        0 0.0001        0 1.0001 prune(x, tol = 1e-3, brutal = TRUE) #> ( 2 x 2 ) matrix polynomial with degree <= 3  #>      z^0 [,1]  [,2] z^1 [,1]  [,2] z^2 [,1]   [,2] z^3 [,1]   [,2] #> [1,]   1.0001     0   0.0000     0        0 1.0001        0 0.0000 #> [2,]   0.0000     0   1.0001     0        0 0.0000        0 1.0001  # Case of complex variables: x = x + complex(imaginary = 1e-5) x #> ( 2 x 2 ) matrix polynomial with degree <= 4  #>             z^0 [,1]         [,2]  z^1 [,1]     [,2] z^2 [,1]      [,2] #> [1,] 1.0001+0.00001i 1e-04+1e-05i 0.0001+0i 1e-04+0i 1e-04+0i 1.0001+0i #> [2,] 0.0001+0.00001i 1e-04+1e-05i 1.0001+0i 1e-04+0i 1e-04+0i 0.0001+0i #>      z^3 [,1]      [,2] z^4 [,1]     [,2] #> [1,] 1e-04+0i 0.0001+0i 1e-04+0i 1e-04+0i #> [2,] 1e-04+0i 1.0001+0i 1e-04+0i 1e-04+0i prune(x, tol = 1e-3) #> ( 2 x 2 ) matrix polynomial with degree <= 3  #>      z^0 [,1]  [,2] z^1 [,1]  [,2] z^2 [,1]   [,2] z^3 [,1]   [,2] #> [1,]   1.0001 1e-04   0.0000 1e-04        0 1.0001        0 0.0000 #> [2,]   0.0001 1e-04   1.0001 1e-04        0 0.0001        0 1.0001  # also works for constant matrix polynomials (i.e. matrices) x = polm(array(0:3, dim = c(2,2,1))+1e-4) x #> ( 2 x 2 ) matrix polynomial with degree <= 0  #>      z^0 [,1]   [,2] #> [1,]   0.0001 2.0001 #> [2,]   1.0001 3.0001 prune(x, tol = 1e-3) #> ( 2 x 2 ) matrix polynomial with degree <= 0  #>      z^0 [,1]   [,2] #> [1,]   0.0000 2.0001 #> [2,]   1.0001 3.0001  # empty polynomials are coerced to polynomials of degree zero  x = polm(array(0, dim = c(0,2,5))) x #> ( 0 x 2 ) matrix polynomial with degree <= 4  prune(x) #> ( 0 x 2 ) matrix polynomial with degree <= -1   # Laurent polynomials: (lp = lpolm(c(0, 1:3, 0), min_deg = 2)) #> ( 1 x 1 ) Laurent polynomial matrix with degree <= 6, and minimal degree >= 2 #>      z^2 [,1] z^3 [,1] z^4 [,1] z^5 [,1] z^6 [,1] #> [1,]        0        1        2        3        0 prune(lp) #> ( 1 x 1 ) Laurent polynomial matrix with degree <= 5, and minimal degree >= 3 #>      z^3 [,1] z^4 [,1] z^5 [,1] #> [1,]        1        2        3"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pseries.html","id":null,"dir":"Reference","previous_headings":"","what":"Power series Parameters — pseries","title":"Power series Parameters — pseries","text":"function returns coefficients power series expansion (around \\(z=0\\))   rational matrix  $$c(z) = c_0 + c_1 z + c_2 z^2 + \\cdots$$  Note left matrix fraction description \\(c(z) = (z)^{-1} b(z)\\)  matrix \\((0)\\)  must invertible matrix.  rational functions corresponds VARMA statespace model,  sequence coefficients also  called impulse response function.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pseries.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Power series Parameters — pseries","text":"","code":"pseries(obj, lag.max, ...)  # S3 method for default pseries(obj, lag.max = 5, ...)  # S3 method for polm pseries(obj, lag.max = 5, ...)  # S3 method for lmfd pseries(obj, lag.max = 5, ...)  # S3 method for rmfd pseries(obj, lag.max = 5, ...)  # S3 method for stsp pseries(obj, lag.max = 5, ...)  # S3 method for lpolm pseries(obj, ...)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pseries.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Power series Parameters — pseries","text":"obj (rational) matrix object, .e. polm, lmfd,  rmfd, stsp object  object may coerced polynomial matrix polm(obj).  default S3 method first coerces input argument obj polm object.  fails error thrown. lag.max (integer) maximum lag. ... used.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pseries.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Power series Parameters — pseries","text":"object type pseries","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pseries.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Power series Parameters — pseries","text":"pseries object simply 3-dimensional (numeric complex) array  dimension c(m,n,lag.max+1) class attribute c('pseries', 'ratm').  dimensions \\((m,n)\\) may also zero.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pseries.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Power series Parameters — pseries","text":"","code":"(obj = rmfd(c = polm(array(c(c(diag(2)), c(0.5, 0.25, 0.125, 0.5)), dim = c(2,2,2))), d = NULL)) #> ( 2 x 2 ) right matrix fraction description d(z) c^(-1)(z) with degrees deg(c(z)) = p = 1, deg(d(z)) = q = 0 #> left factor d(z): #>      z^0 [,1]  [,2] #> [1,]        1     0 #> [2,]        0     1 #> right factor c(z): #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]        1     0     0.50 0.125 #> [2,]        0     1     0.25 0.500 (k = pseries(obj, lag.max = 4)) #> ( 2 x 2 ) impulse response with maximum lag = 4  #>      lag=0 [,1]  [,2] lag=1 [,1]   [,2] lag=2 [,1]    [,2] lag=3 [,1] #> [1,]          1     0      -0.50 -0.125    0.28125 0.12500 -0.1718750 #> [2,]          0     1      -0.25 -0.500    0.25000 0.28125 -0.1953125 #>             [,2] lag=4 [,1]      [,2] #> [1,] -0.09765625  0.1103516 0.0703125 #> [2,] -0.17187500  0.1406250 0.1103516 pseries2rmfd(k) #> $Xr #> ( 2 x 2 ) right matrix fraction description d(z) c^(-1)(z) with degrees deg(c(z)) = p = 1, deg(d(z)) = q = 1 #> left factor d(z): #>      z^0 [,1]  [,2]     z^1 [,1]          [,2] #> [1,]        1     0 0.000000e+00 -1.526557e-16 #> [2,]        0     1 5.551115e-17  0.000000e+00 #> right factor c(z): #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]        1     0     0.50 0.125 #> [2,]        0     1     0.25 0.500 #>  #> $mu #> [1] 1 1 #>   (obj = lmfd(a = polm(array(c(c(diag(2)), c(0.5, 0.25, 0.125, 0.5)), dim = c(2,2,2))))) #> ( 2 x 2 ) left matrix fraction description a^(-1)(z) b(z) with degrees (p = 1, q = 0) #> left factor a(z): #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]        1     0     0.50 0.125 #> [2,]        0     1     0.25 0.500 #> right factor b(z): #>      z^0 [,1]  [,2] #> [1,]        1     0 #> [2,]        0     1 (k = pseries(obj, lag.max = 4)) #> ( 2 x 2 ) impulse response with maximum lag = 4  #>      lag=0 [,1]  [,2] lag=1 [,1]   [,2] lag=2 [,1]    [,2] lag=3 [,1] #> [1,]          1     0      -0.50 -0.125    0.28125 0.12500 -0.1718750 #> [2,]          0     1      -0.25 -0.500    0.25000 0.28125 -0.1953125 #>             [,2] lag=4 [,1]      [,2] #> [1,] -0.09765625  0.1103516 0.0703125 #> [2,] -0.17187500  0.1406250 0.1103516 pseries2lmfd(k) #> $Xl #> ( 2 x 2 ) left matrix fraction description a^(-1)(z) b(z) with degrees (p = 1, q = 1) #> left factor a(z): #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]        1     0     0.50 0.125 #> [2,]        0     1     0.25 0.500 #> right factor b(z): #>      z^0 [,1]  [,2]      z^1 [,1]         [,2] #> [1,]        1     0 -1.110223e-16 2.775558e-17 #> [2,]        0     1  0.000000e+00 0.000000e+00 #>  #> $nu #> [1] 1 1 #>"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pseries2hankel.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct Hankel Matrix from Impulse Response Coefficients — pseries2hankel","title":"Construct Hankel Matrix from Impulse Response Coefficients — pseries2hankel","text":"(internal) helper function builds Hankel matrix  given impulse response dimension \\((m,n)\\)  \\(l\\) lags. parameter Hsize=c(f,p) given,  default choice number block rows (\\(f\\))  block columns (\\(p\\)) made  \\(f+p-1 = l\\), \\(p\\geq 1\\)  \\(f \\geq p+1\\).  function throws error conditions \\(p\\geq 1\\),   \\(f \\geq 2\\) \\(l \\geq f+p-1\\)  satisfied. particular, implies  \\(l \\geq 2\\) must hold.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pseries2hankel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct Hankel Matrix from Impulse Response Coefficients — pseries2hankel","text":"","code":"pseries2hankel(obj, Hsize = NULL)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pseries2hankel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct Hankel Matrix from Impulse Response Coefficients — pseries2hankel","text":"obj pseries object 3-D array dimension \\((m,n,l+1)\\). Hsize integer vector c(f,p), number block rows block columns.  NULL default choice made.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pseries2hankel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct Hankel Matrix from Impulse Response Coefficients — pseries2hankel","text":"Block Hankel matrix dimension \\((fm, pn)\\)          attributes order=c(m,n,f,p) k0. \\((m,n)\\)-dimensional          matrix k0 lag zero coefficient impulse response.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pseries2lmfd.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a LMFD Representation from Impulse Response — pseries2lmfd","title":"Construct a LMFD Representation from Impulse Response — pseries2lmfd","text":"(helper) function constructs left matrix fraction description rational matrix impulse response.  course impulse response must contain sufficiently many lags.  constructed LMFD echelon canonical form.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pseries2lmfd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a LMFD Representation from Impulse Response — pseries2lmfd","text":"","code":"pseries2lmfd(obj, Hsize = NULL, nu = NULL, tol = sqrt(.Machine$double.eps))"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pseries2lmfd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a LMFD Representation from Impulse Response — pseries2lmfd","text":"obj pseries object 3-D array dimension \\((m,n,l+1)\\). Hsize integer vector c(f,p), number block rows block columns Hankel matrix used construct LMFD. NULL default choice made. nu integer vector Kronecker indices. NULL Kronecker indices computed via QR decomposition transpose Hankel matrix, see qr. tol tolerance parameter, used qr.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pseries2lmfd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct a LMFD Representation from Impulse Response — pseries2lmfd","text":"List components Xl lmfd object contains LMFD representation          rational matrix (echelon form). nu integer vector Kronecker indices.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pseries2lmfd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Construct a LMFD Representation from Impulse Response — pseries2lmfd","text":"number restrictions dimension \\((m,n)\\) number lags \\(l\\) impulse response, number block rows (\\(f\\)), block columns (\\(p\\)) Hankel matrix Kronecker indices \\(\\nu_i\\): require : \\(m>0\\), \\(p>0\\), \\(f>1\\), \\(l \\geq f+p-1\\) \\(\\nu_i <f\\). restrictions satisfied error thrown.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pseries2lmfd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct a LMFD Representation from Impulse Response — pseries2lmfd","text":"","code":"# generate a random LMFD object m = 3 n = 2 p = 1 q = 1 a = test_polm(dim = c(m,m), degree = p, random = TRUE, bzeroes = 1) b = test_polm(dim = c(m,n), degree = q, random = TRUE, bzeroes = 1) Xl = lmfd(a,b)  # compute impulse response of this matrix Xi = pseries(Xl, lag.max = 2*(max(p,q)+1))  # reconstruct a matrix from this impulse response out = pseries2lmfd(Xi) out #> $Xl #> ( 3 x 2 ) left matrix fraction description a^(-1)(z) b(z) with degrees (p = 1, q = 1) #> left factor a(z): #>      z^0 [,1]  [,2]  [,3]   z^1 [,1]       [,2]        [,3] #> [1,]        1     0     0  0.2021378  0.5196404  0.07302681 #> [2,]        0     1     0  0.1762166  0.3624118 -0.09171068 #> [3,]        0     0     1 -3.0680283 -1.5370144  0.12294962 #> right factor b(z): #>        z^0 [,1]       [,2]   z^1 [,1]       [,2] #> [1,]  0.5502865  0.5634542 -1.2404774 -0.8986685 #> [2,]  0.7836649 -0.5728499 -0.2694364  2.3756215 #> [3,] -1.9600901 -1.8889912  3.7005316 -4.6949403 #>  #> $nu #> [1] 1 1 1 #>   # check that the lmfd object is a realization of the given impulse response Xi1 = pseries(out$Xl, lag.max = 2*(max(p,q)+1)) all.equal(Xi, Xi1) #> [1] TRUE"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pseries2rmfd.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct an RMFD Representation from Impulse Response — pseries2rmfd","title":"Construct an RMFD Representation from Impulse Response — pseries2rmfd","text":"(helper) function constructs right matrix fraction description rational matrix impulse response. course, impulse response must contain sufficently many lags. constructed RMFD canonical form.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pseries2rmfd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct an RMFD Representation from Impulse Response — pseries2rmfd","text":"","code":"pseries2rmfd(obj, Hsize = NULL, mu = NULL, tol = sqrt(.Machine$double.eps))"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pseries2rmfd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct an RMFD Representation from Impulse Response — pseries2rmfd","text":"obj pseries object 3-D array dimension \\((m,n,l+1)\\). Hsize integer vector c(f,p), number block rows block columns Hankel matrix used construct RMFD. NULL default choice made. mu integer vector right-Kronecker indices. NULL right-Kronecker indices computed via QR decomposition transpose Hankel matrix, see qr. tol tolerance parameter, used qr.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pseries2rmfd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct an RMFD Representation from Impulse Response — pseries2rmfd","text":"List components Xr rmfd object contains RMFD resresentation          rational matrix (echelon form). mu integer vector right-Kronecker indices.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pseries2rmfd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Construct an RMFD Representation from Impulse Response — pseries2rmfd","text":"number restrictions dimension \\((m,n)\\) number lags \\(l\\) impulse response, number block rows (\\(f\\)), block columns (\\(p\\)) Hankel matrix right-Kronecker indices \\(\\mu_i\\): require : \\(m>0\\), \\(p>0\\), \\(f>1\\), \\(l \\geq f+p-1\\) \\(\\nu_i <f\\). restrictions satisfied error thrown.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pseries2rmfd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct an RMFD Representation from Impulse Response — pseries2rmfd","text":"","code":"# generate a random RMFD object m = 3 n = 2 p = 1 q = 1 cc = test_polm(dim = c(n,n), degree = p, random = TRUE) dd = test_polm(dim = c(m,n), degree = q, random = TRUE) Xr = rmfd(cc,dd)  # compute impulse response of this matrix Xi = pseries(Xr, lag.max = 2*(max(p,q)+1))  # reconstruct a matrix from this impulse response out = pseries2rmfd(Xi) out #> $Xr #> ( 3 x 2 ) right matrix fraction description d(z) c^(-1)(z) with degrees deg(c(z)) = p = 1, deg(d(z)) = q = 1 #> left factor d(z): #>        z^0 [,1]        [,2]  z^1 [,1]         [,2] #> [1,]  0.4236526 -0.45826756 0.4371393  0.725291829 #> [2,]  0.1545386 -0.04794727 0.6680970  0.675800085 #> [3,] -0.2190662  0.78092679 0.3556937 -0.006669578 #> right factor c(z): #>      z^0 [,1]  [,2]   z^1 [,1]      [,2] #> [1,]        1     0 -0.6625206 1.0062681 #> [2,]        0     1 -0.3398077 0.7877269 #>  #> $mu #> [1] 1 1 #>   # check that the lmfd object is a realization of the given impulse response Xi1 = pseries(out$Xr, lag.max = 2*(max(p,q)+1)) all.equal(Xi, Xi1) #> [1] TRUE"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pseries2stsp.html","id":null,"dir":"Reference","previous_headings":"","what":"Ho-Kalman Realization Algorithm — pseries2stsp","title":"Ho-Kalman Realization Algorithm — pseries2stsp","text":"helper function implements Ho-Kalman algorithm.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pseries2stsp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ho-Kalman Realization Algorithm — pseries2stsp","text":"","code":"pseries2stsp(   obj,   method = c(\"balanced\", \"echelon\"),   Hsize = NULL,   s = NULL,   nu = NULL,   tol = sqrt(.Machine$double.eps),   Wrow = NULL,   Wcol = NULL )"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pseries2stsp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ho-Kalman Realization Algorithm — pseries2stsp","text":"obj pseries object 3-D array dimension \\((m,n,l+1)\\). method Character string, determines method \"parametrization\" type state space model. See details. Hsize integer vector c(f,p), number block rows block columns Hankel matrix used construct statespace realization. NULL default choice made. s desired state dimension. used method = \"balanced\". Note however, \\(s\\) larger rank Hankel matrix, procedure break . s missing, state dimension determined singular values Hankel matrix. precise state dimension chosen number singular values greater equal tol times maximum singular value. nu Kronecker indices. used  method = \"echelon\". missing, nu computed QR decomposition transpose Hankel matrix impulse response coefficients. tol tolerance parameter used QR decomposition SVD decomposition Hankel matrix \\(H\\) impulse response coefficients. Wrow, Wcol weighting matrices (default weighting, .e. identity matrices). weighting matrices used method=\"balanced\", SVD weighted Hankel matrix Wrow %*% H %*% t(Wcol) computed.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pseries2stsp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ho-Kalman Realization Algorithm — pseries2stsp","text":"List slots Xs stsp object, rational matrix statespace form Hsv Singular values Hankel matrix method='balanced' NULL else. nu Kronecker indices method='echelon' NULL else.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pseries2stsp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Ho-Kalman Realization Algorithm — pseries2stsp","text":"procedure(s) may used model reduction (care). number restrictions number lags \\(l\\) impulse response, number block rows (\\(f\\)), block columns (\\(p\\)) Hankel matrix Kronecker indices \\(\\nu_i\\). require : \\(p>0\\), \\(f>1\\), \\(l \\geq f+p-1\\) \\(\\nu_i <f\\). restrictions satisfied error thrown.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/pseries2stsp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ho-Kalman Realization Algorithm — pseries2stsp","text":"","code":"# generate random rational matrix X(z) in statespace form # make sure that the A matrix is stable m = 3 n = 2 s = 7 A = matrix(rnorm(s*s), nrow = s, ncol = s) A = A / (1.1 * max(abs(eigen(A, only.values = TRUE)$values))) Xs = stsp(A, B = matrix(rnorm(s*n), nrow = s, ncol = n),           C = matrix(rnorm(s*m), nrow = m, ncol = s),           D = diag(1, nrow = m, ncol = n)) Xi = pseries(Xs, lag.max = 20)  out = pseries2stsp(Xi, method = 'balanced') print(out) #> $Xs #> statespace realization [3,2] with s = 7 states #>             s[1]         s[2]        s[3]        s[4]          s[5]        s[6] #> s[1]  0.94059576 -0.077400057 -0.14467953 -0.10142121  0.0008186168 -0.03978968 #> s[2]  0.13979877 -0.391080136  0.43510004  0.26385470 -0.1920962871 -0.10392392 #> s[3]  0.19215554  0.170454565 -0.09702761 -0.17671571 -0.2023622757  0.12768778 #> s[4] -0.03104238 -0.643291247  0.31225486 -0.10452909  0.0991831151 -0.06277821 #> s[5]  0.01136420  0.172348201  0.30454896  0.12242087 -0.5621051342  0.11346711 #> s[6] -0.02402529 -0.084165683 -0.10863003 -0.19484134 -0.5706754654  0.16468170 #> s[7] -0.00158137  0.008479835  0.04223383 -0.08950554  0.0814023245  0.30049401 #> x[1]  0.37524517  0.315063567  0.99848755 -0.60132403  0.1319152937  0.16531778 #> x[2]  0.13220776  0.976381715  0.30715097  0.11136427 -0.0379094538 -0.32236101 #> x[3] -0.65787270 -0.203696993 -0.24002398 -0.99523744 -0.1478933766 -0.21448852 #>              s[7]        u[1]         u[2] #> s[1] -0.010729627  0.28617084 -0.763454772 #> s[2] -0.043342636  0.64065669  0.940671073 #> s[3]  0.064504440 -0.94489090  0.817468020 #> s[4]  0.091902326 -0.63576753 -0.357681166 #> s[5] -0.079535367 -0.09549396 -0.154750062 #> s[6]  0.193961292  0.09813842  0.010462806 #> s[7] -0.733126907  0.02750497  0.007446502 #> x[1] -0.007200611  1.00000000  0.000000000 #> x[2]  0.038605876  0.00000000  1.000000000 #> x[3] -0.057758278  0.00000000  0.000000000 #>  #> $Hsv #>  [1] 4.989318e+00 2.222811e+00 1.895922e+00 1.665142e+00 4.444566e-01 #>  [6] 2.675638e-01 9.535001e-02 4.345988e-16 3.423288e-16 3.128856e-16 #> [11] 2.953181e-16 2.559072e-16 2.177170e-16 1.769149e-16 1.422830e-16 #> [16] 1.321921e-16 9.415949e-17 7.567866e-17 6.810119e-17 5.112092e-17 #>  #> $nu #> NULL #>  # check impulse response all.equal(pseries(out$Xs, lag.max = 20), Xi) #> [1] TRUE  Xs1 = as.stsp(Xi) all.equal(Xs1, out$Xs) #> [1] TRUE  out = pseries2stsp(Xi, method = 'echelon') print(out) #> $Xs #> statespace realization [3,2] with s = 7 states #>             s[1]        s[2]        s[3]        s[4]       s[5]       s[6] #> s[1]  0.00000000  0.00000000  0.00000000  1.00000000  0.0000000  0.0000000 #> s[2]  0.00000000  0.00000000  0.00000000  0.00000000  1.0000000  0.0000000 #> s[3]  0.00000000  0.00000000  0.00000000  0.00000000  0.0000000  1.0000000 #> s[4]  0.00000000  0.00000000  0.00000000  0.00000000  0.0000000  0.0000000 #> s[5]  0.07171019  0.09925553 -0.06150195 -0.04182307 -0.7976700 -0.2799509 #> s[6] -0.30898396  0.32531639 -0.11511100 -0.58224594  0.4533548 -0.9470607 #> s[7]  0.14974483 -0.13227020  0.06138948  0.36205164  0.1158408  0.4834687 #> x[1]  1.00000000  0.00000000  0.00000000  0.00000000  0.0000000  0.0000000 #> x[2]  0.00000000  1.00000000  0.00000000  0.00000000  0.0000000  0.0000000 #> x[3]  0.00000000  0.00000000  1.00000000  0.00000000  0.0000000  0.0000000 #>            s[7]        u[1]       u[2] #> s[1]  0.0000000 -0.24849885  1.0224646 #> s[2]  0.0000000  0.27537951  1.0315537 #> s[3]  0.0000000  0.53225702  0.4906222 #> s[4]  1.0000000  0.72432651 -0.1122603 #> s[5]  0.5935999 -0.72912387 -0.3388397 #> s[6] -1.7121241  0.42327569  0.8356666 #> s[7]  0.9621392  0.04322717 -0.8011817 #> x[1]  0.0000000  1.00000000  0.0000000 #> x[2]  0.0000000  0.00000000  1.0000000 #> x[3]  0.0000000  0.00000000  0.0000000 #>  #> $Hsv #> NULL #>  #> $nu #> [1] 3 2 2 #>  # check impulse response all.equal(pseries(out$Xs, lag.max = 20), Xi) #> [1] TRUE  Xs1 = as.stsp(Xi, method = 'echelon') all.equal(Xs1, out$Xs) #> [1] TRUE"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/purge_rc.html","id":null,"dir":"Reference","previous_headings":"","what":"Purge Rows or Columns of a Polynomial Matrix — purge_rc","title":"Purge Rows or Columns of a Polynomial Matrix — purge_rc","text":"helper function main work horse computing Hermite normal form  (see hnf) Smith normal form (see snf)  polynomial matrices. \"purges\" elements , , right  left pivot element elementary row- column- operations.  \"purge\" means elements either reduced zero degree  elements made smaller degree pivot element.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/purge_rc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Purge Rows or Columns of a Polynomial Matrix — purge_rc","text":"","code":"purge_rc(   a,   pivot = c(1, 1),   direction = c(\"down\", \"up\", \"left\", \"right\"),   permute = TRUE,   tol = sqrt(.Machine$double.eps),   monic = FALSE,   debug = FALSE )"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/purge_rc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Purge Rows or Columns of a Polynomial Matrix — purge_rc","text":"Polynomial matrix dimension \\((m,n)\\), .e. object class polm. pivot Integer vector length 2. Specifies position \"pivot\" element. direction Character string. (default) \"purge\" elements pivot element elementary row-operations. \"purge\" elements pivot element elementary row-operations right \"purge\" elements right pivot element              elementary column-operations left \"purge\" elements left pivot element              elementary column-operations permute Logical, defaults TRUE. See details . tol Tolerance parameter, used \"pruning\" polynomial matrix (step).  See prune. monic Logical, defaults FALSE. TRUE, coefficient pertaining highest degree pivot element  normalized 1. debug Logical, default FALSE. TRUE, diagnostic messages printed.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/purge_rc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Purge Rows or Columns of a Polynomial Matrix — purge_rc","text":"List three slots h Polynomial matrix dimension \\((m,n)\\), .e. object class polm.          matrix result \"purging\" operation(s). u Unimodular polynomial matrix, .e. class polm object.         direction = ''  direction = '' matrix         \\(u(z)\\) \\((m,m)\\) dimensional satisfies \\((z) = u(z) h(z)\\).        direction = 'left'  direction = 'right' matrix         \\(u(z)\\) \\((n,n)\\) dimensional satisfies \\((z) = h(z) u(z)\\). u_inv Unimodular polynomial matrix, .e. class polm object.          matrix inverse \\(u(z)\\).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/purge_rc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Purge Rows or Columns of a Polynomial Matrix — purge_rc","text":"Suppose matrix \\((z)\\) \\(m\\) rows, \\(n\\) columns pivot  position \\((,j)\\). Furthermore, let us first consider case direction=''  permute=FALSE. case suitable multiple - computed  Euclidean polynomial division algorithm - \\(\\)-th row subtracted rows  \\(\\)-th row respective degree elements  pivot element degree smaller degree pivot. option permute=TRUE first rows \\(:m\\) permuted  \\((,j)\\)-th element smallest degree among elements \\(j\\)-th  column rows \\(:m\\). Next suitable multiple \\(\\)-th row  subtracted rows \\(\\)-th row respective degree  elements pivot element degree smaller  degree pivot. two steps repeated elements pivot element zero. Quite analogously cases direction='',  direction='left'  direction='right' may discussed. Note however, cases  direction='left'  direction='right'  elementary column-operations used. Finally, monic=TRUE pivot element made monic, multiplying  respective row (column) suitable scalar.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/purge_rc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Purge Rows or Columns of a Polynomial Matrix — purge_rc","text":"","code":"# Generate matrix polynomial a = test_polm(dim = c(2,3), degree = 1) print(a, format = 'c') #> ( 2 x 3 ) matrix polynomial with degree <= 1  #>             [,1]        [,2]        [,3] #> [1,]  110 + 111z  120 + 121z  130 + 131z #> [2,]  210 + 211z  220 + 221z  230 + 231z   ######################################################## # Purge first column downwards out = purge_rc(a, pivot = c(1,1), monic = TRUE)  # First col zero except for (1,1) element print(out$h, digits = 2, format = 'c') #> ( 2 x 3 ) matrix polynomial with degree <= 2  #>       [,1]                    [,2]                    [,3] #> [1,]     1                -9 - 10z               -19 - 20z #> [2,]     0  1110 + 2220z + 1110z^2  2220 + 4440z + 2220z^2   # Check polynomial matrix products all.equal(a, prune(out$u %r% out$h)) #> [1] TRUE all.equal(out$h, prune(out$u_inv %r% a)) #> [1] TRUE all.equal(polm(diag(2)), prune(out$u_inv %r% out$u)) #> [1] TRUE  ######################################################## # Purge last column upwards out = purge_rc(a, pivot = c(2,3), direction = \"up\", monic = TRUE)  # Last col zero except for (2,3) element print(out$h, digits = 2, format = 'c') #> ( 2 x 3 ) matrix polynomial with degree <= 2  #>                          [,1]                     [,2]  [,3] #> [1,]  -4620 - 9240z - 4620z^2  -2310 - 4620z - 2310z^2     0 #> [2,]                 21 + 20z                 11 + 10z     1   # Check polynomial matrix products all.equal(a, prune(out$u %r% out$h)) #> [1] TRUE all.equal(out$h, prune(out$u_inv %r% a)) #> [1] TRUE all.equal(polm(diag(2)), prune(out$u_inv %r% out$u)) #> [1] TRUE  ######################################################## # Purge first row right out = purge_rc(a, pivot = c(1,1), direction = \"right\", monic = TRUE)  # first row zero except for (1,1) element print(out$h, digits = 2, format = 'c') #> ( 2 x 3 ) matrix polynomial with degree <= 2  #>             [,1]                       [,2]  [,3] #> [1,]           1                          0     0 #> [2,]  -99 - 100z  11100 + 22200z + 11100z^2     0   # Check polynomial matrix products all.equal(a, prune(out$h %r% out$u)) #> [1] TRUE all.equal(out$h, prune(a %r% out$u_inv)) #> [1] TRUE all.equal(polm(diag(3)), prune(out$u_inv %r% out$u)) #> [1] TRUE  ######################################################## # Purge last row left out = purge_rc(a, pivot = c(2,3), direction = \"left\", monic = TRUE)  # last row zero except for (2,3) element print(out$h, digits = 2, format = 'c') #> ( 2 x 3 ) matrix polynomial with degree <= 2  #>       [,1]                        [,2]        [,3] #> [1,]     0  -23100 - 46200z - 23100z^2  101 + 100z #> [2,]     0                           0           1   # Check polynomial matrix products all.equal(a, prune(out$h %r% out$u)) #> [1] TRUE all.equal(out$h, prune(a %r% out$u_inv)) #> [1] TRUE all.equal(polm(diag(3)), prune(out$u_inv %r% out$u)) #> [1] TRUE"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/ql_decomposition.html","id":null,"dir":"Reference","previous_headings":"","what":"QL and LQ Decomposition — QL and LQ decomposition","title":"QL and LQ Decomposition — QL and LQ decomposition","text":"Returns QL LQ decomposition matrix non-negative \"diagonal\" elements QL LQ decompositions. works column pivoting occurs QR decomposition qr.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/ql_decomposition.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"QL and LQ Decomposition — QL and LQ decomposition","text":"","code":"ql_decomposition(x, ...)  lq_decomposition(x, ...)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/ql_decomposition.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"QL and LQ Decomposition — QL and LQ decomposition","text":"x Matrix. ... arguments qr","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/ql_decomposition.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"QL and LQ Decomposition — QL and LQ decomposition","text":"List two elements: q Semi-orthogonal matrix l Lower triangular matrix non-negative diagonal elements.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/ql_decomposition.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"QL and LQ Decomposition — QL and LQ decomposition","text":"export function publishing package!","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/ql_decomposition.html","id":"implementation-of-the-ql-decomposition-using-the-qr-decomposition","dir":"Reference","previous_headings":"","what":"Implementation of the QL decomposition using the QR decomposition","title":"QL and LQ Decomposition — QL and LQ decomposition","text":"base function qr used following way. (need assume pivoting since otherwise function throws error). First, reorder columns input matrix x last first QR-decompose matrix. Next, reorder columns Q rows R way.  original matrix x now QL decomposition.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/ql_decomposition.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"QL and LQ Decomposition — QL and LQ decomposition","text":"","code":"set.seed(1803)  # Tall matrix x = matrix(stats::rnorm(5*3), 5, 3) out = ql_decomposition(x) all.equal(x, out$q %*% out$l) #> [1] TRUE all.equal(diag(ncol(out$q)), t(out$q) %*% out$q) #> [1] TRUE out$l #>            [,1]     [,2]     [,3] #> [1,]  2.3430442 0.000000 0.000000 #> [2,] -0.4813528 2.504091 0.000000 #> [3,]  0.2570508 1.183947 2.350825 out = lq_decomposition(x) all.equal(x, out$l %*% out$q) #> [1] TRUE all.equal(diag(nrow(out$q)), out$q %*% t(out$q)) #> [1] TRUE out$l #>            [,1]       [,2]       [,3] #> [1,]  2.4318488  0.0000000  0.0000000 #> [2,]  0.1373582  1.0693912  0.0000000 #> [3,] -0.9217318 -1.7489450  0.7996942 #> [4,]  0.6810998 -0.7241543 -2.0071689 #> [5,] -0.8357022 -1.1436741 -0.5818361  # Wide matrix x = matrix(stats::rnorm(5*3), 3, 5) out = ql_decomposition(x) all.equal(x, out$q %*% out$l) #> [1] TRUE all.equal(diag(ncol(out$q)), t(out$q) %*% out$q) #> [1] TRUE out$l #>            [,1]       [,2]       [,3]     [,4]     [,5] #> [1,]  1.0854922 1.16839176  0.6295948 0.000000 0.000000 #> [2,]  1.0702433 1.45849417  0.1366193 1.302877 0.000000 #> [3,] -0.8729544 0.08863472 -0.1230865 1.160753 2.179503 out = lq_decomposition(x) all.equal(x, out$l %*% out$q) #> [1] TRUE all.equal(diag(nrow(out$q)), out$q %*% t(out$q)) #> [1] TRUE out$l #>            [,1]      [,2]     [,3] #> [1,]  1.4032852 0.0000000 0.000000 #> [2,] -0.2164448 2.6480266 0.000000 #> [3,]  1.8590980 0.2003933 1.512196  # Square matrix x = matrix(stats::rnorm(4*4), 4, 4) out = ql_decomposition(x) all.equal(x, out$q %*% out$l) #> [1] TRUE all.equal(diag(ncol(out$q)), t(out$q) %*% out$q) #> [1] TRUE out$l #>            [,1]       [,2]       [,3]     [,4] #> [1,]  0.7835124  0.0000000  0.0000000 0.000000 #> [2,]  1.6198819  0.4521451  0.0000000 0.000000 #> [3,] -0.5476521 -0.1655997  2.3140488 0.000000 #> [4,]  0.4083269 -1.1031379 -0.1874477 2.482612 out = lq_decomposition(x) all.equal(x, out$l %*% out$q) #> [1] TRUE all.equal(diag(nrow(out$q)), out$q %*% t(out$q)) #> [1] TRUE out$l #>           [,1]       [,2]      [,3]      [,4] #> [1,] 2.1763716  0.0000000  0.000000 0.0000000 #> [2,] 0.2516972  2.0028011  0.000000 0.0000000 #> [3,] 0.7376794 -1.5175622  1.353042 0.0000000 #> [4,] 1.0090988 -0.5026001 -1.351903 0.3450825  # reset seed set.seed(NULL)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/range_3D.html","id":null,"dir":"Reference","previous_headings":"","what":"Range of Values in a 3-D Array — range_3D","title":"Range of Values in a 3-D Array — range_3D","text":"range_3D computes range values three-dimensional array.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/range_3D.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Range of Values in a 3-D Array — range_3D","text":"","code":"range_3D(x, MARGIN = integer(0))"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/range_3D.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Range of Values in a 3-D Array — range_3D","text":"x (m,n,k)-dimensional numeric array MARGIN integer(0), 1, 2 (1:2). determines \"margin\" compute range(s).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/range_3D.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Range of Values in a 3-D Array — range_3D","text":"(m,n,2)-dimensional array.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/range_3D.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Range of Values in a 3-D Array — range_3D","text":"input, x say, (m,n,k) dimensional array range_3D returns (m,n,2) dimensional array, m say: MARGIN = c(1,2): m[,j,] contains range values x[,j,]. MARGIN = 1: m[,j,] contains range values x[,,]. MARGIN = 2: m[,j,] contains range values x[,j,]. MARGIN = integer(0): m[,j,] contains range values x[,,].","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/rationalmatrices.html","id":null,"dir":"Reference","previous_headings":"","what":"A Collection of Tools for Rational Matrices — rationalmatrices","title":"A Collection of Tools for Rational Matrices — rationalmatrices","text":"package rationalmatrices collects classes, methods tools  creating manipulating rational matrices, .e. matrices whose  entries rational functions.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/rationalmatrices.html","id":"classes","dir":"Reference","previous_headings":"","what":"Classes","title":"A Collection of Tools for Rational Matrices — rationalmatrices","text":"exist many different representations rational matrices. package particular  deals \"left matrix fraction\" representations (implemented lmfd class)  \"statespace\" representations (implemented stsp class). special case course  also polynomial matrices (polm class) implemented. coefficients  power series expansion rational function stored pseries objects  collection values rational function may stored  zvalues objects. package particular offers tools convert one representation another  (equivalent) representation, see e.g. pseries2stsp pseries2lmfd.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/rationalmatrices.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"A Collection of Tools for Rational Matrices — rationalmatrices","text":"package provides \"standard\" matrix - tools: General methods, like print, dim, plot, ... Arithmetic operations, like addition multiplication. See particular       Ops.ratm %r%. Extract parts matrix, transposition, (column row) bind two matrices, ... specific methods rational matrices Compute poles zeroes rational matrices. Check properties rational matrix, like stability inverse stability. support echelon canonical form, see e.g. Kronecker-Indices. Normal Forms polynomial matrices, like Hermite normal form Smith form.        See hnf, snf, whf col_reduce.        Check \"left (co)primeness\" .coprime. Compute derivative (respect \\(z\\)). Tools related statespace representations, e.g. computation        controllability observability Grammians computation balanced        (truncated) realizations. See grammians, balance, ...","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/rationalmatrices.html","id":"author-s-","dir":"Reference","previous_headings":"","what":"Author(s)","title":"A Collection of Tools for Rational Matrices — rationalmatrices","text":"Wolfgang Scherrer Bernd Funovits Maintainer: <bernd.funovits@gmail.com> References: See Also: Examples:","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/ratm_mult.html","id":null,"dir":"Reference","previous_headings":"","what":"Matrix Multiplication of Rational Matrices — %r%","title":"Matrix Multiplication of Rational Matrices — %r%","text":"Matrix Multiplication Rational Matrices","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/ratm_mult.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matrix Multiplication of Rational Matrices — %r%","text":"","code":"e1 %r% e2"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/ratm_mult.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matrix Multiplication of Rational Matrices — %r%","text":"e1, e2 two rational matrix objects (.e. polm, lmfd, rmfd, stsp, pseries zvalues objects),  objects may coerced rational matrix objects.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/ratm_mult.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matrix Multiplication of Rational Matrices — %r%","text":"rational matrix object. class depends classes arguments e1,e1.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/ratm_mult.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Matrix Multiplication of Rational Matrices — %r%","text":"","code":"(lp1 = test_lpolm(degree_max = 1, degree_min = -1, random = TRUE)) #> ( 1 x 1 ) Laurent polynomial matrix with degree <= 1, and minimal degree >= -1 #>      z^-1 [,1] z^0 [,1]   z^1 [,1] #> [1,] 0.1320614 1.226072 -0.6586723 (lp2 = test_lpolm(degree_max = 1, degree_min = -1, random = TRUE)) #> ( 1 x 1 ) Laurent polynomial matrix with degree <= 1, and minimal degree >= -1 #>      z^-1 [,1]  z^0 [,1] z^1 [,1] #> [1,] 0.2434346 0.1516305 1.759386 lp1 %r% lp2 #> ( 1 x 1 ) Laurent polynomial matrix with degree <= 2, and minimal degree >= -2 #>      z^-2 [,1] z^-1 [,1]  z^0 [,1] z^1 [,1]  z^2 [,1] #> [1,] 0.0321483 0.3184928 0.2579132 2.057259 -1.158859"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/reflect_poles.html","id":null,"dir":"Reference","previous_headings":"","what":"Reflect Poles of Rational Matrices — reflect_poles","title":"Reflect Poles of Rational Matrices — reflect_poles","text":"Given square, rational matrix \\(x(z)\\) set poles \\(x(z)\\),  function reflect_poles constructs allpass matrix \\(U(z)\\)  \\(x(z)U(z)\\) poles reciprocals  selected poles poles changed.  Also zeroes changed, .e. \\(x\\) \\(xU\\) zeroes.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/reflect_poles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reflect Poles of Rational Matrices — reflect_poles","text":"","code":"reflect_poles(x, poles, ...)  # S3 method for stsp reflect_poles(x, poles, tol = sqrt(.Machine$double.eps), ...)  # S3 method for rmfd reflect_poles(   x,   poles,   tol = sqrt(.Machine$double.eps),   check_poles = TRUE,   ... )"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/reflect_poles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reflect Poles of Rational Matrices — reflect_poles","text":"x Square, rational matrix object (real coefficients). poles Complex real vector poles reflected.  assumed complex conjugated pairs poles,  one contained vector. ... used. tol (double) Tolerance parameter used checks. check_poles TRUE procedure checks  given poles poles rational matrix x(z).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/reflect_poles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reflect Poles of Rational Matrices — reflect_poles","text":"Rational matrix object represents rational matrix  \\(x(z)U(z)\\) reflected poles. object          class input object x.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/reflect_poles.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Reflect Poles of Rational Matrices — reflect_poles","text":"procedures implemented rational matrices real coefficients.  Therefore complex poles occur complex conjugated pairs pairs jointly reflected ensure result real coefficients.  Note however, argument poles must contain one element  pairs reflected. degnerate cases procedure(s) may run numerical problems:  matrices rmfd form,  procedure assumes matrix poles \\(z=0\\).  matrices statespace form, poles  (close ) unit circle allowed. addition multiple  poles may lead unreliable results.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/reference/reflect_poles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reflect Poles of Rational Matrices — reflect_poles","text":"","code":"# ################################################################### # rational matrix in statespace form ('stsp' object)  set.seed(12345) # create random (2,2) rational matrix in state space form  # with state dimension s=5 ( x = test_stsp(dim = c(2,2), s = 5) ) #> statespace realization [2,2] with s = 5 states #>            s[1]       s[2]       s[3]       s[4]       s[5]        u[1] #> s[1]  0.5855288 -0.2761841 -0.7505320  1.4557851  0.6121235  0.49118828 #> s[2]  0.7094660 -0.2841597  0.8168998 -0.6443284 -0.1623110 -0.32408658 #> s[3] -0.1093033 -0.9193220 -0.8863575 -1.5531374  0.8118732 -1.66205024 #> s[4] -0.4534972 -0.1162478 -0.3315776 -1.5977095  2.1968335  1.76773385 #> s[5]  0.6058875  1.8173120  1.1207127  1.8050975  2.0491903  0.02580105 #> x[1] -1.8179560  0.3706279  0.2987237 -0.4816474  1.6324456  1.00000000 #> x[2]  0.6300986  0.5202165  0.7796219  0.6203798  0.2542712  0.00000000 #>            u[2] #> s[1]  1.1285108 #> s[2] -2.3803581 #> s[3] -1.0602656 #> s[4]  0.9371405 #> s[5]  0.8544517 #> x[1]  0.0000000 #> x[2]  1.0000000 # poles of x(z) ( x_poles = poles(x) ) #> [1]  0.3228713+0.0000000i -0.3326091+0.0000000i  0.0091529-0.8604103i #> [4]  0.0091529+0.8604103i -4.0175418+0.0000000i  # reflect all unstable poles (inside the unit circle) ########### # note: for complex zeroes, select only one of the complex conjugated pair! x1 = reflect_poles(x, poles = x_poles[(abs(x_poles) < 1) & (Im(x_poles) >= 0)])  r_poles = x_poles r_poles[abs(r_poles) < 1] = 1 / r_poles[abs(r_poles) < 1] (x1_poles = poles(x1)) #> [1]  0.012362-1.162105i  0.012362+1.162105i -3.006533+0.000000i #> [4]  3.097209+0.000000i -4.017542+0.000000i j = match_vectors(r_poles, x1_poles) all.equal(r_poles, x1_poles[j])  #> [1] TRUE  # Check that the transformation matrix U (x1 = x %r% U) is all-pass all.equal(zvalues(x) %r% Ht(zvalues(x)), zvalues(x1) %r% Ht(zvalues(x1))) #> [1] TRUE  set.seed(NULL)   # ################################################################### # rational matrix in RMFD form  set.seed(12345) # create random (2 x 2) rational matrix in RMFD form with degrees (2,1) ( x = test_rmfd(dim = c(2,2), degree = c(2,1)) ) #> ( 2 x 2 ) right matrix fraction description d(z) c^(-1)(z) with degrees deg(c(z)) = p = 2, deg(d(z)) = q = 1 #> left factor d(z): #>        z^0 [,1]       [,2]  z^1 [,1]       [,2] #> [1,] -0.2841597 -0.1162478 0.3706279 -0.7505320 #> [2,] -0.9193220  1.8173120 0.5202165  0.8168998 #> right factor c(z): #>      z^0 [,1]  [,2]  z^1 [,1]       [,2]   z^2 [,1]       [,2] #> [1,]        1     0 0.5855288 -0.1093033  0.6058875  0.6300986 #> [2,]        0     1 0.7094660 -0.4534972 -1.8179560 -0.2761841 # poles of x(z) ( x_poles = poles(x) ) #> [1] -0.492635-0.6478764i -0.492635+0.6478764i  1.045832-0.6704744i #> [4]  1.045832+0.6704744i  # reflect all unstable poles (inside the unit circle) ########### # note: for complex zeroes, select only one of the complex conjugated pair! x1 = reflect_poles(x, poles = x_poles[(abs(x_poles) < 1) & (Im(x_poles) >= 0)])  r_poles = x_poles r_poles[abs(r_poles) < 1] = 1 / r_poles[abs(r_poles) < 1] (x1_poles = poles(x1)) #> [1] -0.7436752-0.9780254i -0.7436752+0.9780254i  1.0458317-0.6704744i #> [4]  1.0458317+0.6704744i j = match_vectors(r_poles, x1_poles) all.equal(r_poles, x1_poles[j])  #> [1] TRUE  # Check that the transformation matrix U (x1 = x %r% U) is all-pass all.equal(zvalues(x) %r% Ht(zvalues(x)), zvalues(x1) %r% Ht(zvalues(x1))) #> [1] TRUE  set.seed(NULL)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/reflect_zeroes.html","id":null,"dir":"Reference","previous_headings":"","what":"Reflect Zeroes of Rational Matrices — reflect_zeroes","title":"Reflect Zeroes of Rational Matrices — reflect_zeroes","text":"Given square, rational matrix \\(x(z)\\) set zeroes \\(x(z)\\),  function reflect_zeroes constructs rational, allpass matrix  \\(U(z)\\) \\(x(z)U(z)\\) zeroes reciprocals  selected zeroes. zeroes \\(x(z)\\) poles  \\(x(z)\\) changed.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/reflect_zeroes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reflect Zeroes of Rational Matrices — reflect_zeroes","text":"","code":"reflect_zeroes(x, zeroes, ...)  # S3 method for polm reflect_zeroes(   x,   zeroes,   tol = sqrt(.Machine$double.eps),   check_zeroes = TRUE,   ... )  # S3 method for lmfd reflect_zeroes(   x,   zeroes,   tol = sqrt(.Machine$double.eps),   check_zeroes = TRUE,   ... )  # S3 method for stsp reflect_zeroes(x, zeroes, tol = sqrt(.Machine$double.eps), ...)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/reflect_zeroes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reflect Zeroes of Rational Matrices — reflect_zeroes","text":"x Square, rational matrix object (real coefficients). zeroes Complex real vector zeroes reflected.  assumed complex conjugated pairs roots,  one contained vector. ... used. tol (double) Tolerance parameter used checks. check_zeroes TRUE procedure checks given  zeroes zeroes rational matrix \\(x(z)\\).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/reflect_zeroes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reflect Zeroes of Rational Matrices — reflect_zeroes","text":"Rational matrix object represents rational matrix  \\(x(z)U(z)\\) reflected zeroes. object          class input object x.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/reflect_zeroes.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Reflect Zeroes of Rational Matrices — reflect_zeroes","text":"procedures implemented rational matrices real coefficients.  Therefore complex zeroes occur complex conjugated pairs pairs jointly reflected ensure result real coefficients.  Note however, argument zeroes must contain one  element pairs reflected. degnerate cases procedure(s) may run numerical problems:  polynomial matrices matrices lmfd form,  procedure assumes value matrix evaluated  \\(z=0\\) non singular. matrices statespace form, zeroes  (close ) unit circle allowed. addition multiple  zeroes may lead unreliable results.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/reference/reflect_zeroes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reflect Zeroes of Rational Matrices — reflect_zeroes","text":"","code":"# ################################################################### # polynomial matrix   # construct a (2 x 2) polynomial matrix with degree 2 x = polm(array(c(1,0,                  0,1,                  -1,0,                  0,0,                  1,0.25,                  0.75,-1), dim = c(2,2,3))) x #> ( 2 x 2 ) matrix polynomial with degree <= 2  #>      z^0 [,1]  [,2] z^1 [,1]  [,2] z^2 [,1]  [,2] #> [1,]        1     0       -1     0     1.00  0.75 #> [2,]        0     1        0     0     0.25 -1.00  # determine zeroes of x(z) ( x_zeroes = zeroes(x) ) #> [1]  0.9236707+0.0000000i  0.4447071-0.8609171i  0.4447071+0.8609171i #> [4] -0.9709796+0.0000000i  # evaluate the polynomial at the (real) zeroe x_zeroes[1]  ( x_value = zvalue(x, x_zeroes[1]) ) #>              [,1]         [,2] #> [1,] 0.9294969+0i 0.6398757+0i #> [2,] 0.2132919+0i 0.1468324+0i  # Verify that the matrix evaluated at z = x_zeroes[1] is rank deficient d = svd(x_value)$d (min(d) < (max(d) * sqrt(.Machine$double.eps))) #> [1] TRUE  # Reflect this zeroe at the unit circle and check the zeroes of the result x1 = reflect_zeroes(x, x_zeroes[1])  r_zeroes = x_zeroes r_zeroes[1] = 1 / r_zeroes[1] x1_zeroes = zeroes(x1) j = match_vectors(r_zeroes, x1_zeroes) all.equal(r_zeroes, x1_zeroes[j])  #> [1] TRUE  # x_zeroes[2] and x_zeroes[3] form a pair of complex conjugated zeroes ( x_value = zvalue(x, x_zeroes[2]) ) #>                        [,1]                  [,2] #> [1,]  0.01187902+0.0952052i -0.4075604-0.5742839i #> [2,] -0.13585347-0.1914280i  1.5434139+0.7657119i  # Verify that the matrix evaluated at x_zeroes[2] is rank deficient d = svd(x_value)$d (min(d) < (max(d) * sqrt(.Machine$double.eps))) #> [1] TRUE  # reflect the real zeroe x_zeroes[1] and this pair of  # complex conjugated zeroes at the unit circle and verify the result x1 = reflect_zeroes(x, x_zeroes[c(1,2)])  r_zeroes = x_zeroes r_zeroes[1:3] = 1 / r_zeroes[1:3] x1_zeroes = zeroes(x1) j = match_vectors(r_zeroes, x1_zeroes) all.equal(r_zeroes, x1_zeroes[j])  #> [1] TRUE  # Check that the transformation matrix U (x1 = x %r% U) is all-pass all.equal(zvalues(x) %r% Ht(zvalues(x)), zvalues(x1) %r% Ht(zvalues(x1))) #> [1] TRUE   # ################################################################### # rational matrix in LMFD form  set.seed(12345) (x = test_lmfd(dim = c(3,3), degrees = c(2,2), digits = 2)) #> ( 3 x 3 ) left matrix fraction description a^(-1)(z) b(z) with degrees (p = 2, q = 2) #> left factor a(z): #>      z^0 [,1]  [,2]  [,3] z^1 [,1]  [,2]  [,3] z^2 [,1]  [,2]  [,3] #> [1,]        1     0     0     0.59 -0.45  0.63    -0.92  0.37  0.82 #> [2,]        0     1     0     0.71  0.61 -0.28    -0.12  0.52 -0.89 #> [3,]        0     0     1    -0.11 -1.82 -0.28     1.82 -0.75 -0.33 #> right factor b(z): #>      z^0 [,1]  [,2]  [,3] z^1 [,1]  [,2]  [,3] z^2 [,1]  [,2]  [,3] #> [1,]     1.12  1.46 -1.60     0.62  0.81  1.63    -0.32  0.03 -1.06 #> [2,]     0.30 -0.64  1.81     0.61  2.20  0.25    -1.66  1.13  0.94 #> [3,]     0.78 -1.55 -0.48    -0.16  2.05  0.49     1.77 -2.38  0.85 (x_zeroes = zeroes(x)) #> [1] -0.4672627+0.0000000i  0.3378125-0.5740499i  0.3378125+0.5740499i #> [4]  0.1408149-1.3499406i  0.1408149+1.3499406i  4.9799815+0.0000000i  # reflect all zeroes inside the unit circle # note: for complex zeroes, select only one of the complex conjugated pair! x1 = reflect_zeroes(x, x_zeroes[(abs(x_zeroes) <1) & (Im(x_zeroes) >=0 )])  r_zeroes = x_zeroes r_zeroes[abs(r_zeroes) < 1] = 1 / r_zeroes[abs(r_zeroes) < 1] (x1_zeroes = zeroes(x1)) #> [1]  0.140815-1.349941i  0.140815+1.349941i  0.761438-1.293923i #> [4]  0.761438+1.293923i -2.140124+0.000000i  4.979981+0.000000i j = match_vectors(r_zeroes, x1_zeroes) all.equal(r_zeroes, x1_zeroes[j])  #> [1] TRUE  # Check that the transformation matrix U (x1 = x %r% U) is all-pass all.equal(zvalues(x) %r% Ht(zvalues(x)), zvalues(x1) %r% Ht(zvalues(x1))) #> [1] TRUE  set.seed(NULL)   # ################################################################### # rational matrix in statespace form (stsp object)  # create a random (2,2) rational matrix in state space form with  # state dimension s=5 set.seed(12345) (x = test_stsp(dim = c(2,2), s = 5)) #> statespace realization [2,2] with s = 5 states #>            s[1]       s[2]       s[3]       s[4]       s[5]        u[1] #> s[1]  0.5855288 -0.2761841 -0.7505320  1.4557851  0.6121235  0.49118828 #> s[2]  0.7094660 -0.2841597  0.8168998 -0.6443284 -0.1623110 -0.32408658 #> s[3] -0.1093033 -0.9193220 -0.8863575 -1.5531374  0.8118732 -1.66205024 #> s[4] -0.4534972 -0.1162478 -0.3315776 -1.5977095  2.1968335  1.76773385 #> s[5]  0.6058875  1.8173120  1.1207127  1.8050975  2.0491903  0.02580105 #> x[1] -1.8179560  0.3706279  0.2987237 -0.4816474  1.6324456  1.00000000 #> x[2]  0.6300986  0.5202165  0.7796219  0.6203798  0.2542712  0.00000000 #>            u[2] #> s[1]  1.1285108 #> s[2] -2.3803581 #> s[3] -1.0602656 #> s[4]  0.9371405 #> s[5]  0.8544517 #> x[1]  0.0000000 #> x[2]  1.0000000 # zeroes of x(z) (x_zeroes = zeroes(x)) #> [1]  0.2849467-0.0302833i  0.2849467+0.0302833i -0.3112259-0.4083715i #> [4] -0.3112259+0.4083715i -0.5438276+0.0000000i  # reflect all unstable zeroes (inside the unit circle)  # note: for complex zeroes, select only one of the complex conjugated pair! x1 = reflect_zeroes(x, x_zeroes[(abs(x_zeroes) <1) & (Im(x_zeroes) >=0 )])  r_zeroes = x_zeroes r_zeroes[abs(r_zeroes) < 1] = 1 / r_zeroes[abs(r_zeroes) < 1] (x1_zeroes = zeroes(x1)) #> [1] -1.838818+0.000000i -1.180546-1.549040i -1.180546+1.549040i #> [4]  3.470232-0.368805i  3.470232+0.368805i j = match_vectors(r_zeroes, x1_zeroes) all.equal(r_zeroes, x1_zeroes[j])  #> [1] TRUE  # Check that the transformation matrix U (x1 = x %r% U) is all-pass all.equal(zvalues(x) %r% Ht(zvalues(x)), zvalues(x1) %r% Ht(zvalues(x1))) #> [1] TRUE  set.seed(NULL)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/replace.html","id":null,"dir":"Reference","previous_headings":"","what":"Replace Parts of a (Laurent) Polynomial Matrix — replace","title":"Replace Parts of a (Laurent) Polynomial Matrix — replace","text":"assignment operation x[,] <- value (Laurent) polynomial matrices works quite analogously  assignment operation \"ordinary\" matrices.   case Laurent polynomial objects lpolm value lpolm object  (.e. value vector, matrix, array), value first coerced lpolm object min_deg = 0.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/replace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Replace Parts of a (Laurent) Polynomial Matrix — replace","text":"","code":"# S3 method for polm [(x, i, j) <- value  # S3 method for lpolm [(x, i, j) <- value"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/replace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Replace Parts of a (Laurent) Polynomial Matrix — replace","text":"x polm lpolm object , j indices value Either polm lpolm object, vector/matrix/array may coerced  polm lpolm object polm(value) lpolm(value).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/replace.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Replace Parts of a (Laurent) Polynomial Matrix — replace","text":"Note \"named\" arguments supported (order simplify coding).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/replace.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Replace Parts of a (Laurent) Polynomial Matrix — replace","text":"","code":"a = test_polm(dim = c(3,2), degree = 1) print(a, format = 'c') #> ( 3 x 2 ) matrix polynomial with degree <= 1  #>             [,1]        [,2] #> [1,]  110 + 111z  120 + 121z #> [2,]  210 + 211z  220 + 221z #> [3,]  310 + 311z  320 + 321z   a[FALSE] = 0           # no items to replace, print(a, format = 'c') # a is not changed #> ( 3 x 2 ) matrix polynomial with degree <= 1  #>             [,1]        [,2] #> [1,]  110 + 111z  120 + 121z #> [2,]  210 + 211z  220 + 221z #> [3,]  310 + 311z  320 + 321z   a[lower.tri(matrix(0, nrow = 3, ncol = 2))] = 0 # set elements below the  print(a, format = 'c')                          # diagonal equal to zero #> ( 3 x 2 ) matrix polynomial with degree <= 1  #>             [,1]        [,2] #> [1,]  110 + 111z  120 + 121z #> [2,]           0  220 + 221z #> [3,]           0           0   a[3,1] = c(1,-1)       # set (3,1) element print(a, format = 'c') # equal to (1 - z) #> ( 3 x 2 ) matrix polynomial with degree <= 1  #>             [,1]        [,2] #> [1,]  110 + 111z  120 + 121z #> [2,]           0  220 + 221z #> [3,]       1 - z           0   a[1:2, 2:1] = c(0,1)   # set the elements in rows 1,2 and coluimns 1,2 print(a, format = 'c') # equal to z #> ( 3 x 2 ) matrix polynomial with degree <= 1  #>        [,1]  [,2] #> [1,]      z     z #> [2,]      z     z #> [3,]  1 - z     0   a[2, ] = test_polm(dim = c(1,2), degree = 4) print(a, format = 'c') #> ( 3 x 2 ) matrix polynomial with degree <= 4  #>                                        [,1]                                   [,2] #> [1,]                                      z                                      z #> [2,]  110 + 111z + 112z^2 + 113z^3 + 114z^4  120 + 121z + 122z^2 + 123z^3 + 124z^4 #> [3,]                                  1 - z                                      0   a[, 1] = test_polm(dim = c(2,1), degree = 4) # this gives a warning #> Warning: number of items to replace is not a multiple of replacement length print(a, format = 'c') #> ( 3 x 2 ) matrix polynomial with degree <= 4  #>                                        [,1]                                   [,2] #> [1,]  110 + 111z + 112z^2 + 113z^3 + 114z^4                                      z #> [2,]  210 + 211z + 212z^2 + 213z^3 + 214z^4  120 + 121z + 122z^2 + 123z^3 + 124z^4 #> [3,]  110 + 111z + 112z^2 + 113z^3 + 114z^4                                      0   if (FALSE) { a[i=1] = 0   # named arguments are not supported }   (lp = lpolm(1:3, min_deg = -1)) #> ( 1 x 1 ) Laurent polynomial matrix with degree <= 1, and minimal degree >= -1 #>      z^-1 [,1] z^0 [,1] z^1 [,1] #> [1,]         1        2        3 lp[1] = 0 lp #> ( 1 x 1 ) Laurent polynomial matrix with degree <= 1, and minimal degree >= -1 #>      z^-1 [,1] z^0 [,1] z^1 [,1] #> [1,]         0        0        0  (lp = lpolm(1:3, min_deg = -1)) #> ( 1 x 1 ) Laurent polynomial matrix with degree <= 1, and minimal degree >= -1 #>      z^-1 [,1] z^0 [,1] z^1 [,1] #> [1,]         1        2        3 lp[1] = polm(1:4) lp #> ( 1 x 1 ) Laurent polynomial matrix with degree <= 3, and minimal degree >= -1 #>      z^-1 [,1] z^0 [,1] z^1 [,1] z^2 [,1] z^3 [,1] #> [1,]         0        1        2        3        4  (lp = lpolm(1:3, min_deg = -1)) #> ( 1 x 1 ) Laurent polynomial matrix with degree <= 1, and minimal degree >= -1 #>      z^-1 [,1] z^0 [,1] z^1 [,1] #> [1,]         1        2        3 lp[1] = lpolm(1, min_deg = 0) lp #> ( 1 x 1 ) Laurent polynomial matrix with degree <= 1, and minimal degree >= -1 #>      z^-1 [,1] z^0 [,1] z^1 [,1] #> [1,]         0        1        0"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/rmfd.html","id":null,"dir":"Reference","previous_headings":"","what":"Constructor for Right Matrix Fraction Descriptions (RMFDs) — rmfd","title":"Constructor for Right Matrix Fraction Descriptions (RMFDs) — rmfd","text":"Right Matrix Fraction Description (RMFD) rational matrix, \\(k(z)\\) say,  pair \\((c(z),d(z))\\) polynomial matrices, \\(k(z) = d(z) c^{-1}(z)\\). polynomial matrix \\(c(z)\\) must square invertible.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/rmfd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for Right Matrix Fraction Descriptions (RMFDs) — rmfd","text":"","code":"rmfd(c = NULL, d = NULL)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/rmfd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor for Right Matrix Fraction Descriptions (RMFDs) — rmfd","text":"c, d polm objects, objects may coerced polm object, via x = polm(x).  Either two arguments may omitted.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/rmfd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Constructor for Right Matrix Fraction Descriptions (RMFDs) — rmfd","text":"object class rmfd.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/rmfd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Constructor for Right Matrix Fraction Descriptions (RMFDs) — rmfd","text":"Suppose \\(k(z) = d(z) c^{-1}(z)\\) \\((m,n)\\)-dimensional matrix \\(c(z)\\) \\(d(z)\\) degrees \\(p\\) \\(q\\) respectively. corresponding rmfd object stores coefficients polynomials \\(c(z), d(z)\\) \\((n(p+1)+m(q+1), n)\\) dimensional (real complex valued) matrix. rmfd object also stores attribute order = c(m,n,p,q) class attribute c(\"lmfd\", \"ratm\"). valid RMFD require \\(m>0\\) \\(p\\geq 0\\).","code":""},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/reference/rmfd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Constructor for Right Matrix Fraction Descriptions (RMFDs) — rmfd","text":"","code":"### (1 x 1) rational matrix k(z) =  (3+2z+z^2) (1+z+z^2)^(-1) rmfd(c(1,1,1), c(3,2,1)) %>% print(format = 'c') #> ( 1 x 1 ) right matrix fraction description d(z) c^(-1)(z) with degrees deg(c(z)) = p = 2, deg(d(z)) = q = 2 #> left factor d(z): #>               [,1] #> [1,]  3 + 2z + z^2  #> right factor c(z): #>              [,1] #> [1,]  1 + z + z^2   ### (1 x 1) rational matrix k(z) = (3+2z+z^2) rmfd(c = c(3,2,1)) %>% print(format = 'c') #> ( 1 x 1 ) right matrix fraction description d(z) c^(-1)(z) with degrees deg(c(z)) = p = 2, deg(d(z)) = q = 0 #> left factor d(z): #>       [,1] #> [1,]     1  #> right factor c(z): #>               [,1] #> [1,]  3 + 2z + z^2   ### (1 x 1) rational matrix k(z) = (1+z+z^2)^(-1) rmfd(c(1,1,1)) %>% print(format = 'c') #> ( 1 x 1 ) right matrix fraction description d(z) c^(-1)(z) with degrees deg(c(z)) = p = 2, deg(d(z)) = q = 0 #> left factor d(z): #>       [,1] #> [1,]     1  #> right factor c(z): #>              [,1] #> [1,]  1 + z + z^2   ### (3 x 2) rational matrix with degrees p=1, q=1 x = rmfd(array(rnorm(2*2*2), dim = c(2,2,2)),           array(rnorm(3*2*2), dim = c(3,2,2))) is.rmfd(x) #> [1] TRUE dim(x) #> m n p q  #> 3 2 1 1  str(x) #> ( 3 x 2 ) right matrix fraction description with degrees (deg(c(z)) = p = 1, deg(d(z)) = q = 1) print(x, digits = 2) #> ( 3 x 2 ) right matrix fraction description d(z) c^(-1)(z) with degrees deg(c(z)) = p = 1, deg(d(z)) = q = 1 #> left factor d(z): #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]    -0.69  0.59    -1.44  0.74 #> [2,]     0.67 -0.16    -0.67 -0.39 #> [3,]     0.85  1.40     0.87  0.82 #> right factor c(z): #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]     0.06 -1.78     0.18  0.77 #> [2,]     0.41 -0.50     1.11 -0.09  xr = test_rmfd(dim = c(3,2), degree = c(2,2))  if (FALSE) { ### the following calls to rmfd() throw an error  rmfd() # no arguments! rmfd(c = test_polm(dim = c(2,3), degree = 1))  # c(z) must be square  rmfd(c = test_polm(dim = c(2,2), degree = -1)) # c(z) must have degree >= 0 }"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/roots_as_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Polynomial Roots as List — roots_as_list","title":"Polynomial Roots as List — roots_as_list","text":"helper function coerces vector (complex real) roots list.  complex conjugate pair roots, one positive  imaginary part retained.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/roots_as_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Polynomial Roots as List — roots_as_list","text":"","code":"roots_as_list(roots, tol = sqrt(.Machine$double.eps))"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/roots_as_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Polynomial Roots as List — roots_as_list","text":"roots Vector cplx doubles. Obtained e.g. call  zeroes. tol Double. Tolerance parameter used decide whether roots  conjugate roots \"match\".","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/roots_as_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Polynomial Roots as List — roots_as_list","text":"List roots. complex conjugated pairs roots, ones          positive part returned. procedure orders roots          according imaginary part, thus real roots come first.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/roots_as_list.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Polynomial Roots as List — roots_as_list","text":"routine assumes complex roots appear, small numerical errors, complex conjugate pairs. Therefore procedure tries match roots complex conjugates. possible, error thrown. Roots, classified real, replaced real part. Roots, classified complex, replaced mean  root best matching conjugate root.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/reference/roots_as_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Polynomial Roots as List — roots_as_list","text":"","code":"set.seed(12345) p = 5 a = rnorm(p+1)   # coefficients of a random polynomial a(z) of degree p = 5 z = polyroot(a)  # compute the roots of a(z) z #> [1]  0.2353419+0.9290992i -0.5313699+0.3107316i -0.5313699-0.3107316i #> [4]  0.9253355-0.0000000i  0.2353419-0.9290992i  # try to match roots and conjugate roots j = match_vectors(z, Conj(z)) # z is approximately equal to Conj( z[j] ) print(data.frame(z = z, j = j, `Conj(z[j])` = Conj(z[j]), d = z-Conj(z[j]))) #>                       z j            Conj.z.j..                           d #> 1  0.2353419+0.9290992i 5  0.2353419+0.9290992i  1.221245e-15-9.992007e-16i #> 2 -0.5313699+0.3107316i 3 -0.5313699+0.3107316i  3.108624e-15+1.887379e-15i #> 3 -0.5313699-0.3107316i 2 -0.5313699-0.3107316i -3.108624e-15+1.887379e-15i #> 4  0.9253355-0.0000000i 4  0.9253355+0.0000000i  0.000000e+00-1.750357e-15i #> 5  0.2353419-0.9290992i 1  0.2353419-0.9290992i -1.221245e-15-9.992007e-16i # z[1] and z[5] are complex conjugates (up to numerical errors) # z[2] and z[3] are complex conjugates (up to numerical errors) # z[4] is real (up to numerical errors)  # coerce the vector \"z\" to a list (z_list = roots_as_list(z)) #> [[1]] #> [1] 0.9253355 #>  #> [[2]] #> [1] -0.5313699+0.3107316i #>  #> [[3]] #> [1] 0.2353419+0.9290992i #>  # the first slot contains the real root (and thus is of class \"numeric\") # z_list[[1]] = Re(z[4]) # the slots 2 and 3 contain the complex roots and thus are of class \"complex\" # z_list[[2]] = (z[2] + Conj(z[3])/2 # z_list[[3]] = (z[1] + Conj(z[5])/2  # The routine zeroes() uses the function eigen()  # (to compute the eigenvalues of the companion matrix)  # and thus returns exact conjugate pairs: (z = zeroes(polm(a))) #> [1] -0.5313699-0.3107316i -0.5313699+0.3107316i  0.9253355+0.0000000i #> [4]  0.2353419-0.9290992i  0.2353419+0.9290992i  # match roots and conjugate roots j = match_vectors(z, Conj(z)) # z is equal to Conj(z[j]) print(j) #> [1] 2 1 3 5 4 all.equal(z, Conj(z[j])) #> [1] TRUE  # coerce the vector \"z\" to a list (z_list = roots_as_list(z)) #> [[1]] #> [1] 0.9253355 #>  #> [[2]] #> [1] -0.5313699+0.3107316i #>  #> [[3]] #> [1] 0.2353419+0.9290992i #>   set.seed(NULL)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/schur.html","id":null,"dir":"Reference","previous_headings":"","what":"Schur Decomposition — schur","title":"Schur Decomposition — schur","text":"Schur decomposition (real, square) matrix \\(\\)  $$= U S U'$$ \\(U\\) orthogonal matrix S  upper quasi-triangular 1--1 2--2 blocks diagonal.  2--2 blocks correspond complex eigenvalues \\(\\).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/schur.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Schur Decomposition — schur","text":"","code":"schur(A, select = NULL, tol = sqrt(.Machine$double.eps))"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/schur.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Schur Decomposition — schur","text":"square, non-empty, real matrix. select non NULL, Schur decomposition reordered  selected cluster eigenvalues appear leading  diagonal blocks quasi-triangular matrix \\(S\\). See details . tol tolerance used decide whether target eigenvalues match  eigenvalues \\(\\). See details .","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/schur.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Schur Decomposition — schur","text":"List components U, S, lambda k,          lambda contains (computed) eigenvalues \\(\\)  k indicates many eigenvalues selected (put top).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/schur.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Schur Decomposition — schur","text":"optional parameter select determines eigenvalues, respectively  1--1 2--2 blocks, put top matrix \\(S\\). select='iuc': Select eigenvalues moduli less one        (inside unit circle). select='ouc': Select eigenvalues moduli greater one        (outside unit circle). select='lhf': Select eigenvalues negative imaginary part        (left half plane). select='rhf': Select eigenvalues positive imaginary part        (right half plane). select='real': Select real eigenvalues. select='cplx': Select complex eigenvalues. select (complex) vector eigenvalues. function checks whether       \"target eigenvalues\", .e. entries select,  match eigenvalues        matrix \\(\\). addition procedure also makes sure        complex eigenvalues selected complex conjugated pairs. function schur simply wrapper qz.dgees  qz.dtrsen.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/schur.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Schur Decomposition — schur","text":"","code":"# generate a \"random\" 6-by-6 matrix A m = 6 set.seed(1532) A = matrix(stats::rnorm(m*m, sd = 0.5), nrow = m, ncol = m) set.seed(NULL)  # compute the Schur decomposition of A (and its eigenvalues) out = schur(A) lambda = out$lambda # eigenvalues of A  # check A = U S U'  all.equal(A, out$U %*% out$S %*% t(out$U)) #> [1] TRUE print(out$S) #>           [,1]        [,2]        [,3]       [,4]         [,5]       [,6] #> [1,] -1.258119  0.16047666  0.11317140  0.8606362 -0.003078162  0.6654092 #> [2,]  0.000000 -0.07298067 -1.88015298 -0.6360467  0.070634280 -0.3670152 #> [3,]  0.000000  0.43391617 -0.07298067 -0.2158021  0.295439282 -0.2451203 #> [4,]  0.000000  0.00000000  0.00000000  0.7667058  1.205338328  0.7751998 #> [5,]  0.000000  0.00000000  0.00000000 -0.5427939  0.766705822  0.2745867 #> [6,]  0.000000  0.00000000  0.00000000  0.0000000  0.000000000  0.5968981 print(lambda) #> [1] -1.2581190+0.0000000i -0.0729807+0.9032324i -0.0729807-0.9032324i #> [4]  0.7667058+0.8088574i  0.7667058-0.8088574i  0.5968981+0.0000000i  # compute an \"ordered\" Schur decomposition where the eigenvalues  # inside the unit circle are put to the top of S: out = schur(A, 'iuc') print(out$S) #>             [,1]        [,2]       [,3]       [,4]        [,5]        [,6] #> [1,] -0.07298067  0.44125325 -0.3372971 -0.1346907  0.17508505 -0.03645365 #> [2,] -1.84889014 -0.07298067 -0.2813143  0.4372502 -0.08687296  0.50003336 #> [3,]  0.00000000  0.00000000  0.5968981 -0.8305954  0.25520954 -0.64478335 #> [4,]  0.00000000  0.00000000  0.0000000 -1.2581190  0.21109806 -0.56034950 #> [5,]  0.00000000  0.00000000  0.0000000  0.0000000  0.76670582  0.45519124 #> [6,]  0.00000000  0.00000000  0.0000000  0.0000000 -1.43730860  0.76670582 print(out$k) # three eigenvalues are inside the unit circle. #> [1] 3 print(out$lambda)  #> [1] -0.0729807+0.9032324i -0.0729807-0.9032324i  0.5968981+0.0000000i #> [4] -1.2581190+0.0000000i  0.7667058+0.8088574i  0.7667058-0.8088574i  # compute an \"ordered\" Schur decomposition where the eigenvalues  # lambda[5] and lambda[6] apear in the top. Note that  # lambda[5] is complex and hence the procedure also selects  # the conjugate of lambda[5]:   out = schur(A, lambda[c(6,5)]) print(out$S) #>            [,1]      [,2]       [,3]       [,4]        [,5]        [,6] #> [1,]  0.7667058 0.5359624 -0.2917256 -0.4321118 -0.03373457  0.07288711 #> [2,] -1.2207018 0.7667058  1.0416001 -0.6797241 -0.61359022 -0.43178545 #> [3,]  0.0000000 0.0000000  0.5968981 -0.5021335  0.46948321  0.19968389 #> [4,]  0.0000000 0.0000000  0.0000000 -1.2581190 -0.26080155 -0.25951666 #> [5,]  0.0000000 0.0000000  0.0000000  0.0000000 -0.07298067  0.46503579 #> [6,]  0.0000000 0.0000000  0.0000000  0.0000000 -1.75433548 -0.07298067 print(out$k) # three eigenvalues have been selected #> [1] 3 print(out$lambda)  #> [1]  0.7667058+0.8088574i  0.7667058-0.8088574i  0.5968981+0.0000000i #> [4] -1.2581190+0.0000000i -0.0729807+0.9032324i -0.0729807-0.9032324i  if (FALSE) { # If the \"target\" eigenvalues do not match the eigenvalues of A  # then \"schur\" throws an error: out = schur(A, select = lambda[1:3]+ 1) }"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/set_default_par.html","id":null,"dir":"Reference","previous_headings":"","what":"Set Default Graphical Parameters — set_default_par","title":"Set Default Graphical Parameters — set_default_par","text":"Set default graphical parameters.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/set_default_par.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set Default Graphical Parameters — set_default_par","text":"","code":"set_default_par(m = 1, n = 1)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/set_default_par.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set Default Graphical Parameters — set_default_par","text":"m, n integers. procedure assumes device split m--n array (sub-) figures scales cex.axis, cex.lab cex.main correspondingy.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/set_default_par.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set Default Graphical Parameters — set_default_par","text":"invisible list original graphical parameters.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/set_default_par.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set Default Graphical Parameters — set_default_par","text":"","code":"opar = set_default_par(2,3) print(opar) #> $oma #> [1] 0 0 0 0 #>  #> $fig #> [1] 0 1 0 1 #>  #> $mar #> [1] 5.1 4.1 4.1 2.1 #>  #> $tcl #> [1] -0.5 #>  #> $mgp #> [1] 3 1 0 #>  #> $mex #> [1] 1 #>  #> $cex #> [1] 1 #>  #> $mex #> [1] 1 #>  #> $cex.axis #> [1] 1 #>  #> $cex.lab #> [1] 1 #>  #> $cex.main #> [1] 1.2 #>  #> $xaxs #> [1] \"r\" #>  #> $yaxs #> [1] \"r\" #>  #> $col.axis #> [1] \"black\" #>"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/snf.html","id":null,"dir":"Reference","previous_headings":"","what":"Smith Normal Form — snf","title":"Smith Normal Form — snf","text":"Calculates Smith normal form \\((m,n)\\)-dimensional polynomial matrix \\((z)\\), .e. factorization \\((z)\\) form  $$(z) = u(z) s(z) v(z),$$ \\(u(z)\\) \\(v(z)\\) unimodular polynomial matrices dimensions \\((m,m)\\)  \\((n,n)\\) respectively, \\(s(z)\\) quasi-diagonal polynomial matrix dimension \\((m,n)\\) diagonal elements \\(d_i(z)\\) satisfy \\(d_{ii}\\) monic \\(\\leq r\\)        \\(d_{ii}\\) zero \\(>r\\), \\(d_{ii}\\) divides \\(d_{+1,+1}\\) \\(< r\\). \\(0\\leq r \\leq \\min(m,n)\\) rank \\((z)\\)  considered rational matrix.    See *Gohberg, Lancaster, Rodman 09 - Matrix Polynomials* page 318 (Hannan Deistler 2012)  page 42, Lemma 2.2.3.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/snf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Smith Normal Form — snf","text":"","code":"snf(a, tol = sqrt(.Machine$double.eps), debug = FALSE)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/snf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Smith Normal Form — snf","text":"Polynomial matrix, .e. object  class polm. tol Tolerance parameter, used \"pruning\" polynomial matrix (step).  See prune. debug Logical, default FALSE. TRUE, diagnostic messages printed.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/snf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Smith Normal Form — snf","text":"list five elements s Matrix polynomial class polm dimensions \\((m,n)\\),     representing \\(s(z)\\) Smith-form (whose non-zero elements diagonal). u Unimodular matrix polynomial class polm dimensions \\((m,m)\\),     Represents \\(u(z)\\) Smith form \\((z) = u(z) s(z) v(z)\\). u_inv Unimodular matrix polynomial class polm dimensions \\((m,m)\\),     Represents inverse \\(u(z)\\). v Unimodular matrix polynomial class polm dimensions \\((n,n)\\),     Represents \\(v(z)\\) Smith form \\((z) = u(z) s(z) v(z)\\). v_inv Unimodular matrix polynomial class polm dimensions \\((n,n)\\),     Represents inverse \\(v(z)\\).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/snf.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Smith Normal Form — snf","text":"Hannan EJ, Deistler M (2012). Statistical Theory Linear Systems,  Classics Applied Mathematics. SIAM, Philadelphia. Originally published: John Wiley & Sons, New York, 1988.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/snf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Smith Normal Form — snf","text":"","code":"############## # Quadratic case  a = test_polm(dim = c(2,2), degree = 1) out = snf(a)  print(out$s, digits = 2, format = 'c') #> ( 2 x 2 ) matrix polynomial with degree <= 2  #>       [,1]          [,2] #> [1,]     1             0 #> [2,]     0  1 + 2z + z^2   all.equal(a, prune(out$u %r% out$s %r% out$v)) #> [1] TRUE  ############## # Tall case  a = test_polm(dim = c(3,2), degree = 1) out = snf(a)  print(out$s, digits = 2, format = 'c') #> ( 3 x 2 ) matrix polynomial with degree <= 2  #>       [,1]          [,2] #> [1,]     1             0 #> [2,]     0  1 + 2z + z^2 #> [3,]     0             0   all.equal(a, prune(out$u %r% out$s %r% out$v)) #> [1] TRUE  ############## # Wide case  a = test_polm(dim = c(2,3), degree = 1) out = snf(a)  print(out$s, digits = 2, format = 'c') #> ( 2 x 3 ) matrix polynomial with degree <= 2  #>       [,1]          [,2]  [,3] #> [1,]     1             0     0 #> [2,]     0  1 + 2z + z^2     0   all.equal(a, prune(out$u %r% out$s %r% out$v)) #> [1] TRUE  ############## # Diagonal case  z = polm(c(0,1)) a = polm(diag(3)) a[3,3] = 1+2*z  a[2,2] = a[3,3] * (1-z) a[1,1] = a[2,2] * (1+z) print(a, format = 'c') #> ( 3 x 3 ) matrix polynomial with degree <= 3  #>                      [,1]          [,2]    [,3] #> [1,]  1 + 2z - z^2 - 2z^3             0       0 #> [2,]                    0  1 + z - 2z^2       0 #> [3,]                    0             0  1 + 2z   out = snf(a)  print(out$s, digits = 2, format = 'c') #> ( 3 x 3 ) matrix polynomial with degree <= 3  #>          [,1]               [,2]                     [,3] #> [1,]  0.5 + z                  0                        0 #> [2,]        0  -0.5 - 0.5z + z^2                        0 #> [3,]        0                  0  -0.5 - z + 0.5z^2 + z^3   all.equal(a, prune(out$u %r% out$s %r% out$v)) #> [1] TRUE  ############## # Common factor(s)  a = test_polm(dim = c(3,3), degree = 1, random = TRUE, digits = 1) a = a * z a[,2] = a[,2] * (1+z) a[,1] = a[,2] * (1-z)  print(a, format = 'c') #> ( 3 x 3 ) matrix polynomial with degree <= 4  #>                                   [,1]                     [,2]            [,3] #> [1,]   0.4z + 0.5z^2 - 0.4z^3 - 0.5z^4   0.4z + 0.9z^2 + 0.5z^3          0.6z^2 #> [2,]  -0.7z - 1.1z^2 + 0.7z^3 + 1.1z^4  -0.7z - 1.8z^2 - 1.1z^3  -1.4z - 0.2z^2 #> [3,]   0.7z + 0.1z^2 - 0.7z^3 - 0.1z^4   0.7z + 0.8z^2 + 0.1z^3  -1.4z + 2.9z^2   out = snf(a)  print(out$s, digits = 2, format = 'c') #> ( 3 x 3 ) matrix polynomial with degree <= 2  #>       [,1]     [,2]  [,3] #> [1,]     z        0     0 #> [2,]     0  z + z^2     0 #> [3,]     0        0     0   all.equal(a, prune(out$u %r% out$s %r% out$v)) #> [1] TRUE"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/start_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Start a new Plot — start_plot","title":"Start a new Plot — start_plot","text":"tools starts new plot writes optional \"labels\" xlab, ylab main (outer) margins plot. addition (optional) legend put right (outer) margin. outer margins plot determined based whether text legend put respective margin.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/start_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Start a new Plot — start_plot","text":"","code":"start_plot(xlab = NULL, ylab = NULL, main = NULL, legend_args = NULL)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/start_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Start a new Plot — start_plot","text":"xlab, ylab, main (optional) character expression. NULL respective outer margin set zero. legend_args (optional) list legend arguments. Note legend always put \"right\" side plot. NULL right outer margin set zero.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/start_plot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Start a new Plot — start_plot","text":"(invisible) 4-dimensional vector outer margins  par(\"mar\").","code":""},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/reference/start_plot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Start a new Plot — start_plot","text":"","code":"if (FALSE) { set_default_par() start_plot(xlab = 'x', ylab = 'y', main = 'main',            legend_args = list(legend = c('eins','zwei'), fill = c('red','blue')))            graphics::box(which = 'inner', col = 'red') }"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/state_trafo.html","id":null,"dir":"Reference","previous_headings":"","what":"State Transformation — state_trafo","title":"State Transformation — state_trafo","text":"Applies \"state transformation\" given rational matrix \\(K(z) = C(Iz^{-1} - )^{-1}B +D\\) statespace form.  parameter matrices transformed \\(\\rightarrow T T^{-1}\\), \\(B \\rightarrow T B\\) \\(C \\rightarrow C T^{-1}\\), \\(T\\) non-singular (square) matrix.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/state_trafo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"State Transformation — state_trafo","text":"","code":"state_trafo(obj, T, inverse = FALSE)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/state_trafo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"State Transformation — state_trafo","text":"obj stsp object, represents rational matrix \\(K(z)\\). T state transformation matrix. parameter T must non-singular (s--s) matrix, vector length s^2 (case T coerced s--s matrix) vector length s. latter case T coerced diagonal s--s matrix. inverse TRUE, transformation reversed, .e.  \\(\\rightarrow T^{-1} T\\), \\(B \\rightarrow T^{-1} B\\) \\(C \\rightarrow C T\\).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/state_trafo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"State Transformation — state_trafo","text":"stsp object represents transformed state space realization.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/state_trafo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"State Transformation — state_trafo","text":"","code":"obj = stsp(A = c(0,0.2,1,-0.5),            B = c(1,1), C = c(1,0))             # random state transformation T = stats::rnorm(4) obj1 = state_trafo(obj, T)  # obj and obj1 are equivalent, they produce the same IRF testthat::expect_equivalent(pseries(obj), pseries(obj1))  # diagonal state transformation matrix T = stats::rnorm(2) obj1 = state_trafo(obj, T)  # revert the transformation testthat::expect_equivalent(obj, state_trafo(obj1, T, inverse = TRUE)) if (FALSE) { state_trafo(obj, stats::rnorm(9)) # dimension of T does not fit state_trafo(obj, c(1,0))          # T = diag(c(1,0)) is singular! }"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/str.html","id":null,"dir":"Reference","previous_headings":"","what":"Display the Structure of Objects — str methods","title":"Display the Structure of Objects — str methods","text":"Display Structure Objects","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/str.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Display the Structure of Objects — str methods","text":"","code":"# S3 method for lpolm str(object, ...)  # S3 method for polm str(object, ...)  # S3 method for lmfd str(object, ...)  # S3 method for rmfd str(object, ...)  # S3 method for stsp str(object, ...)  # S3 method for pseries str(object, ...)  # S3 method for zvalues str(object, ...)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/str.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Display the Structure of Objects — str methods","text":"object object ... used","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/str.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Display the Structure of Objects — str methods","text":"invisible(NULL)","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/stsp.html","id":null,"dir":"Reference","previous_headings":"","what":"Constructor for Statespace Realizations — stsp","title":"Constructor for Statespace Realizations — stsp","text":"rational (\\((m,n)\\)-dimensional) matrix \\(x(z)\\) pole  \\(z=0\\) may represented  $$x(z) = C(z^{-1} I_s - )^{-1} B + D$$ \\(I_s\\) denotes \\((s,s)\\)-dimensional identity matrix \\(,B,C,D\\)  (real complex valued) matrices size \\((s,s)\\), \\((s,n)\\), \\((m,s)\\) \\((m,n)\\) respectively. integer \\(s \\geq 0\\) called state dimension  statespace realization \\(x(z)\\).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/stsp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for Statespace Realizations — stsp","text":"","code":"stsp(A, B, C, D)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/stsp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor for Statespace Realizations — stsp","text":"\\((s,s)\\) matrix (vector length \\((s^2)\\)) B \\((s,n)\\) matrix (vector length \\((sn)\\)) C \\((m,s)\\) matrix (vector length \\((ms)\\)) D \\((m,n)\\) matrix (vector length \\((mn)\\))","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/stsp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Constructor for Statespace Realizations — stsp","text":"object class stsp.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/stsp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Constructor for Statespace Realizations — stsp","text":"Internally statespace realizations stored \\((s+m, s+n)\\)-dimensional matrix  attribute order = c(m,n,s) class attribute  c(\"stsp\",\"ratm\"). integers \\(m,n,s\\) may zero. arguments ,B,C missing, statespace realization  statespace dimension \\(s=0\\) constructed. case D must matrix  scalar.  ,B,C given (compatible) D missing,  D = diag(x = 1, nrow = m, ncol = n) used.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/rationalmatrices/reference/stsp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Constructor for Statespace Realizations — stsp","text":"","code":"### x(z) =  I stsp(D = diag(3)) #> statespace realization [3,3] with s = 0 states #>      u[1] u[2] u[3] #> x[1]    1    0    0 #> x[2]    0    1    0 #> x[3]    0    0    1  ### random (2 x 3) rational matrix in statespace form with state dimension s = 4 x = stsp(A = stats::rnorm(4*4), B = stats::rnorm(4*3), C = stats::rnorm(2*4))  is.stsp(x) #> [1] TRUE dim(x) #> m n s  #> 2 3 4  str(x) #> ( 2 x 3 ) statespace realization with s = 4 states print(x, digits = 3) #> statespace realization [2,3] with s = 4 states #>        s[1]   s[2]   s[3]   s[4]   u[1]   u[2]   u[3] #> s[1] -1.582  0.847 -0.084 -0.812  0.564 -0.001  0.667 #> s[2] -1.748  0.147  0.413 -0.577 -0.891  0.070 -0.846 #> s[3]  0.564  1.440  0.160 -1.805 -0.444 -1.162  0.096 #> s[4]  0.140  0.279  1.310  0.024 -0.137  1.001 -2.402 #> x[1]  0.660 -0.547 -0.667  1.223  1.000  0.000  0.000 #> x[2] -0.496 -0.230 -0.974 -1.191  0.000  1.000  0.000"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/style_parameters.html","id":null,"dir":"Reference","previous_headings":"","what":"Style Parameters — style_parameters","title":"Style Parameters — style_parameters","text":"plotting functions use list common style parameters.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/style_parameters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Style Parameters — style_parameters","text":"","code":"style_parameters(style = c(\"bw\", \"bw2\", \"gray\", \"colored\"))"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/style_parameters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Style Parameters — style_parameters","text":"style character indicating desired \"style\".","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/style_parameters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Style Parameters — style_parameters","text":"list slots: border.grid background color plot region col.grid,lty.grid,lwd.grid color, line style line width grid lines col.axis axis color col.box,lwd.box color linew idth  box surrounding plot region bg.labels,border.labels background border color axis labels col.labels text color axis labels","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/style_parameters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Style Parameters — style_parameters","text":"","code":"style_parameters('colored') #> $bg.grid #> [1] \"#E6E6E6\" #>  #> $border.grid #> [1] NA #>  #> $col.grid #> [1] \"white\" #>  #> $lty.grid #> [1] \"solid\" #>  #> $lwd.grid #> [1] 1 #>  #> $col.axis #> [1] \"#808080\" #>  #> $col.box #> [1] NA #>  #> $lwd.box #> [1] 1 #>  #> $bg.labels #> [1] \"orange\" #>  #> $border.labels #> [1] NA #>  #> $col.labels #> [1] \"black\" #>"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_array.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Test Array — test_array","title":"Create Test Array — test_array","text":"helper function test_array creates arrays given dimension.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_array.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Test Array — test_array","text":"","code":"test_array(dim, random = FALSE, dimnames = FALSE)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_array.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Test Array — test_array","text":"dim Integer vector. random Boolean. Default set FALSE. TRUE, elements randomly generated (standard normal). dimnames (logical) decides whether dimnames created.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_array.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Test Array — test_array","text":"Real valued array dimension dim.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_array.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create Test Array — test_array","text":"function test_array creates array either entries form x[,j,...] = *10^(n-1) + j*10^(n-2) + ...,       n number dimensions, randomly generated (standard normal) entries. function mainly used test operations arrays (like btoeplitz, bhankel, bmatrix  dbind).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_array.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Test Array — test_array","text":"","code":"test_array(dim = 5) #> [1] 1 2 3 4 5 test_array(dim = c(2,4), dimnames = TRUE) #>      B #> A     B=1 B=2 B=3 B=4 #>   A=1  11  12  13  14 #>   A=2  21  22  23  24 test_array(dim = c(2,4,3), dimnames = FALSE) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]  111  121  131  141 #> [2,]  211  221  231  241 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]  112  122  132  142 #> [2,]  212  222  232  242 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]  113  123  133  143 #> [2,]  213  223  233  243 #>   if (FALSE) { # the examples below throw an error test_array(dim = c()) test_array(dim = c(2,-1,2)) }"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_lmfd.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Test Rational Matrix in LMFD Form — test_lmfd","title":"Create Test Rational Matrix in LMFD Form — test_lmfd","text":"simple tool may used create random, \\((m,n)\\)-dimensional, rational matrix  LMFD form  $$x(z)=^{-1}(z) b(z)$$ degrees polynomials \\((z), b(z)\\) denoted \\(p\\) \\(q\\) respectively.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_lmfd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Test Rational Matrix in LMFD Form — test_lmfd","text":"","code":"test_lmfd(   dim = c(1, 1),   degrees = c(1, 1),   digits = NULL,   bpoles = NULL,   bzeroes = NULL,   n.trials = 100 )"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_lmfd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Test Rational Matrix in LMFD Form — test_lmfd","text":"dim integer vector c(m,n). degrees integer vector c(p,q). digits integer, non NULL randomly generated numbers rounded  \"digits\" number decimal places. bpoles lower bound moduli poles rational matrix (NULL). bzeroes lower bound moduli zeroes rational matrix (NULL).  parameter ignored non-square matrices (m != n). n.trials maximum number trials.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_lmfd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Test Rational Matrix in LMFD Form — test_lmfd","text":"lmfd object, represents generated rational matrix \\(x(z)\\)          LMFD form.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_lmfd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create Test Rational Matrix in LMFD Form — test_lmfd","text":"require \\(m>0\\) \\(p\\geq 0\\). left factor \\((z)\\)  normalized \\((0)=I_m\\) \\(I_m\\) denotes  \\((m,m)\\)-dimensional identity matrix. user may prescribe lower bounds moduli zeroes /poles rational matrix. case procedure simply generates (n.trials) random matrices matrix found  satisfies constraint. standard deviation normal distribution, used  generate random entries, decreased step. course crude method  may fail need large number randomly generated matrices.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_lmfd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Test Rational Matrix in LMFD Form — test_lmfd","text":"","code":"### generate a random (2 x 2) rational matrix in LMFD form with degrees p=1 and q =1 ### we require that the matrix has no poles and no zeroes within the unit circle! x = try(test_lmfd(dim = c(2,2), degrees = c(1,1), digits = 2, bpoles = 1, bzeroes = 1)) if (!inherits(x, 'try-error')) {    print(x)    print(abs(poles(x)))    print(abs(zeroes(x))) } #> ( 2 x 2 ) left matrix fraction description a^(-1)(z) b(z) with degrees (p = 1, q = 1) #> left factor a(z): #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]        1     0     0.03 -0.18 #> [2,]        0     1    -0.67  0.03 #> right factor b(z): #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]     0.73 -0.07     0.15  0.72 #> [2,]    -0.55 -1.67     0.20  0.00 #> [1] 2.650586 3.151839 #> [1] 2.955221 2.955221"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_lpolm.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Test Laurent Polynomial Matrix — test_lpolm","title":"Create Test Laurent Polynomial Matrix — test_lpolm","text":"See test_polm. simple tool creates Laurent polynomial matrices testing purposes. column_start_matrix, .e. matrix consisting columns pertaining smallest column degrees, value_at_0, column_end_matrix matrix set order. Thus, column_end_matrix may potentially overwrite value_at_0.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_lpolm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Test Laurent Polynomial Matrix — test_lpolm","text":"","code":"test_lpolm(   dim = c(1, 1),   degree_max = 1,   degree_min = -1,   random = FALSE,   col_start_matrix = NULL,   value_at_0 = NULL,   col_end_matrix = NULL )"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_lpolm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Test Laurent Polynomial Matrix — test_lpolm","text":"dim two dimensional vector non negative integers, determines dimension  polynomial matrix created. prescribed number rows number columns  zero \"empty\" polynomial matrix generated. case  parameters ignored. degree_max, degree_min Integer, vector, matrix specifying minimal maximal (column) degrees random TRUE coefficents generated drawing normal distribution. FALSE coefficient \\(k\\)-th power \\(z^k\\)  (,j)-th entry set equal \"\\(ijk\\)\". case  parameters ignored! col_start_matrix Force matrix lowest column degrees value_at_0 desired value polynomial \\(z=0\\) (NULL). col_end_matrix desired column end matrix (NULL).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_lpolm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Test Laurent Polynomial Matrix — test_lpolm","text":"lpolm object","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_lpolm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create Test Laurent Polynomial Matrix — test_lpolm","text":"contrast test_polm, absolute value zeros forced larger certain lower bound bzeroes.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_lpolm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Test Laurent Polynomial Matrix — test_lpolm","text":"","code":"(lp = test_lpolm(dim = c(1,1), degree_max = 1, degree_min = -2)) #> ( 1 x 1 ) Laurent polynomial matrix with degree <= 1, and minimal degree >= -2 #>       z^-2 [,1]  z^-1 [,1] z^0 [,1]  z^1 [,1] #> [1,] -0.0573139 -0.6091713 1.356686 -1.292133 (lp = test_lpolm(dim = c(3,3), degree_max = c(0,1,2), degree_min = -2)) #> ( 3 x 3 ) Laurent polynomial matrix with degree <= 2, and minimal degree >= -2 #>       z^-2 [,1]       [,2]      [,3]  z^-1 [,1]       [,2]       [,3] #> [1,] -1.0818170 -1.6777888 0.5634944  0.3613606 -1.0296306 -0.5648035 #> [2,] -0.3162265 -0.6745122 0.4016654 -1.2450496  0.7879264  1.2118775 #> [3,]  0.5130466  0.2085760 0.2434347 -0.6171134 -0.5576488 -1.0736304 #>        z^0 [,1]       [,2]       [,3] z^1 [,1]      [,2]       [,3] z^2 [,1] #> [1,]  0.3305136 1.02069209 0.02485754        0 -1.186798 -0.9777846        0 #> [2,] -0.5790311 0.02228287 2.63452313        0 -1.170768  0.9766730        0 #> [3,]  1.2558528 0.29723744 1.15570761        0  1.180335 -0.5386221        0 #>       [,2]       [,3] #> [1,]     0 -0.0789744 #> [2,]     0 -0.1980905 #> [3,]     0 -0.3045719 (lp = test_lpolm(dim = c(3,3), degree_max = 1, degree_min = c(0,-1,-2))) #> ( 3 x 3 ) Laurent polynomial matrix with degree <= 1, and minimal degree >= -2 #>      z^-2 [,1]  [,2]       [,3] z^-1 [,1]       [,2]       [,3]   z^0 [,1] #> [1,]         0     0 -1.2318070         0  0.4427599 -0.2969489  0.6242764 #> [2,]         0     0 -2.7866153         0 -0.8854852 -0.5212250 -0.2046457 #> [3,]         0     0  0.9879036         0  1.5276170  2.1029635 -0.8817940 #>             [,2]       [,3]   z^1 [,1]     [,2]       [,3] #> [1,] -1.96838387  0.0968671 -0.9206873 0.468321 -0.3119690 #> [2,]  0.38789192 -0.1257129 -0.2541162 1.398362 -0.4133924 #> [3,]  0.06668116 -0.3040039  0.6562660 1.063606 -1.0929876"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_polm.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Test Polynomial Matrix — test_polm","title":"Create Test Polynomial Matrix — test_polm","text":"simple tool creates (random) polynomial matrices testing purposes.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_polm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Test Polynomial Matrix — test_polm","text":"","code":"test_polm(   dim = c(1, 1),   degree = 0,   random = FALSE,   digits = NULL,   col_end_matrix = NULL,   value_at_0 = NULL,   bzeroes = NULL,   n.trials = 100 )"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_polm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Test Polynomial Matrix — test_polm","text":"dim two dimensional vector non negative integers, determines dimension  polynomial matrix created. prescribed number rows number columns  zero \"empty\" polynomial matrix generated. case  parameters ignored. degree desired degree(s), either scalar, vector matrix. matrix case  degree prescribes degrees entries polynomial matrix.  vector degree defines column degrees matrix, .e.  respective maximal degrees within columns, scalar degree  determines maximum degree entries matrix. course  degree compatible parameter dim.  desired degree \\(-1\\) zero polynomial generated  parameters ignored. random TRUE coefficents generated drawing normal distribution. FALSE coefficient \\(k\\)-th power \\(z^k\\)  (,j)-th entry set equal \"\\(ijk\\)\". case  parameters ignored! digits integer, non NULL randomly generated numbers rounded  \"digits\" number decimal places. col_end_matrix desired column end matrix (NULL). value_at_0 desired value polynomial \\(z=0\\) (NULL). bzeroes lower bound moduli zeroes rational matrix (NULL).  parameter ignored non-square matrices (m != n). n.trials maximum number trials.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_polm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Test Polynomial Matrix — test_polm","text":"polm object, represents generated polynomial matrix.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_polm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create Test Polynomial Matrix — test_polm","text":"Note desired parameters value_at_0 column_end_matrix  may conflict desired degree(s). See examples . matrices column_end_matrix value_at_0 may contain NA's.  entries replaced randomly generated numbers. user may prescribe lower bounds moduli zeroes  polynomial. case procedure simply generates (n.trials)  random matrices matrix found satisfies constraint. standard deviation  normal distribution, used generate random entries, decreased step.  course crude method may fail need large number randomly  generated matrices.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_polm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Test Polynomial Matrix — test_polm","text":"","code":"### \"empty\" polynomials, number of rows or number of columns is zero.  test_polm(dim = c(0,0)) #> ( 0 x 0 ) matrix polynomial with degree <= -1  test_polm(dim = c(0,2)) #> ( 0 x 2 ) matrix polynomial with degree <= -1  test_polm(dim = c(3,0)) #> ( 3 x 0 ) matrix polynomial with degree <= -1   ### (3,3) polynomial of degree -1 (i.e. a(z)=0)  test_polm(dim = c(3,3), degree = -1) #> ( 3 x 3 ) matrix polynomial with degree <= -1   ### (3,3) polynomial with degree 1  test_polm(dim = c(3,3), degree = 1) %>% print(format = 'c') #> ( 3 x 3 ) matrix polynomial with degree <= 1  #>             [,1]        [,2]        [,3] #> [1,]  110 + 111z  120 + 121z  130 + 131z #> [2,]  210 + 211z  220 + 221z  230 + 231z #> [3,]  310 + 311z  320 + 321z  330 + 331z   ### (3,3) polynomial with column degrees -1, 0 and 1  test_polm(dim = c(3,3), degree = c(-1,0,1))  %>% print(format = 'c') #> ( 3 x 3 ) matrix polynomial with degree <= 1  #>       [,1]  [,2]        [,3] #> [1,]     0   120  130 + 131z #> [2,]     0   220  230 + 231z #> [3,]     0   320  330 + 331z   ### random, (3,3) polynomial with prescribed degrees for each element  deg = matrix(c(0, 1, 2,                1,-1,-1,                1, 1, 1), nrow = 3, ncol = 3, byrow = TRUE) print(deg) #>      [,1] [,2] [,3] #> [1,]    0    1    2 #> [2,]    1   -1   -1 #> [3,]    1    1    1  a = test_polm(dim = c(3,3), degree = deg, random = TRUE) print(a, digits = 2, format = 'c') #> ( 3 x 3 ) matrix polynomial with degree <= 2  #>                [,1]           [,2]                     [,3] #> [1,]          -0.84   0.42 + 0.28z  -2.51 - 0.39z - 0.43z^2 #> [2,]  -0.86 - 0.98z              0                        0 #> [3,]   0.89 - 1.86z  -1.11 + 0.37z            -2.15 + 0.44z   ### random, (3,3) polynomial with prescribed column degree and column end matrix cm = matrix(NA_real_, nrow = 3, ncol = 3) cm[lower.tri(cm, diag = FALSE)] = 0 a = test_polm(dim = c(3,3), degree = c(0,1,2), random = TRUE,                digits = 2, col_end_matrix = cm) print(a, digits = 2, format = 'c') #> ( 3 x 3 ) matrix polynomial with degree <= 2  #>       [,1]           [,2]                     [,3] #> [1,]  -0.8   0.73 - 0.29z  -1.26 - 0.39z + 0.39z^2 #> [2,]     0  -0.39 - 0.61z  -0.78 - 0.13z + 2.06z^2 #> [3,]     0           1.89   0.32 + 0.29z - 1.94z^2  print(degree(a, which = 'column')) #> [1] 0 1 2 print(col_end_matrix(a)) #>      [,1]  [,2]  [,3] #> [1,] -0.8 -0.29  0.39 #> [2,]  0.0 -0.61  2.06 #> [3,]  0.0  0.00 -1.94  ### the parameters column_end_matrix and value_at_zero  ### may be in conflict with the prescribed degree(s).   # E.g. if we set the second column of \"cm\" equal to zero cm[, 2] = 0 a = test_polm(dim = c(3,3), degree = c(0,1,2), random = TRUE,                digits = 2, col_end_matrix = cm) print(a, digits = 2, format = 'c') #> ( 3 x 3 ) matrix polynomial with degree <= 2  #>       [,1]   [,2]                     [,3] #> [1,]  0.55    0.4  -0.77 + 0.06z + 0.29z^2 #> [2,]     0  -0.57  -0.92 - 0.03z - 0.19z^2 #> [3,]     0  -0.83  -0.04 - 0.61z - 0.87z^2   # then the generated polynomial has column degrees 0,0,2  # and the column end matrix is not upper triangular! print(degree(a, which = 'column')) #> [1] 0 0 2 print(col_end_matrix(a)) #>      [,1]  [,2]  [,3] #> [1,] 0.55  0.40  0.29 #> [2,] 0.00 -0.57 -0.19 #> [3,] 0.00 -0.83 -0.87  ### here we set a(0) equal to the identity matrix and  ### require that a(z) has no zeroes within the unit circle a = try(test_polm(dim = c(3,3), degree = 2, random = TRUE,          digits = 2, value_at_0 = diag(3), bzeroes = 1)) if (!inherits(a, 'try-error')) {   print(a, digits = 2, format = 'c')   print(abs(zeroes(a))) } #> ( 3 x 3 ) matrix polynomial with degree <= 2  #>                      [,1]                 [,2]                 [,3] #> [1,]  1 - 0.23z - 0.25z^2      0.34z + 0.11z^2     -0.26z + 0.37z^2 #> [2,]       0.54z + 0.2z^2  1 - 0.13z + 0.56z^2      0.29z + 0.24z^2 #> [3,]      0.39z - 0.23z^2      0.08z + 0.04z^2  1 + 0.37z + 0.22z^2  #> [1]  1.233144  1.270674  1.270674  1.477123  1.477123 20.363498"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_rmfd.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Test Rational Matrix in RMFD Form — test_rmfd","title":"Create Test Rational Matrix in RMFD Form — test_rmfd","text":"simple tool may used create random, \\((m,n)\\)-dimensional, rational matrix RMFD form  $$k(z) = d(z) c^{-1}(z)$$ degrees polynomials \\((c'(z), d'(z))'\\) denoted \\(p\\) \\(q\\) respectively.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_rmfd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Test Rational Matrix in RMFD Form — test_rmfd","text":"","code":"test_rmfd(   dim = c(1, 1),   degrees = c(1, 1),   digits = NULL,   bpoles = NULL,   bzeroes = NULL,   n.trials = 100 )"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_rmfd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Test Rational Matrix in RMFD Form — test_rmfd","text":"dim integer vector c(m,n). degrees integer vector c(p,q). digits integer, non NULL randomly generated numbers rounded \"digits\" number decimal places. bpoles lower bound moduli poles rational matrix (NULL). bzeroes lower bound moduli zeroes rational matrix (NULL).  parameter ignored non-square matrices (m != n). n.trials maximum number trials.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_rmfd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Test Rational Matrix in RMFD Form — test_rmfd","text":"rmfd object, represents generated rational matrix \\(k(z)\\) RMFD form.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_rmfd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create Test Rational Matrix in RMFD Form — test_rmfd","text":"require \\(m>0\\) \\(p\\geq 0\\).  right factor \\(c(z)\\) normalized \\(c(0)=I_n\\) \\(I_n\\) denotes \\((n,n)\\)-dimensional identity matrix. user may prescribe lower bounds moduli zeroes /poles rational matrix. case, procedure simply generates (n.trials) random matrices matrix found satisfies constraint.  standard deviation normal distribution, used generate random entries, decreased step.  course, crude method may fail need large number randomly generated matrices.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_rmfd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Test Rational Matrix in RMFD Form — test_rmfd","text":"","code":"### generate a random (2 x 2) rational matrix in RMFD form with degrees p=1 and q=1 ### we require that the matrix has no poles and no zeroes within the unit circle! x = try(test_rmfd(dim = c(2,2), degrees = c(1,1), digits = 2, bpoles = 1, bzeroes = 1)) if (!inherits(x, 'try-error')) {    print(x)    print(abs(poles(x)))    print(abs(zeroes(x))) } #> ( 2 x 2 ) right matrix fraction description d(z) c^(-1)(z) with degrees deg(c(z)) = p = 1, deg(d(z)) = q = 1 #> left factor d(z): #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]     0.66  0.51     0.36 -0.02 #> [2,]    -0.37  0.52     0.40  0.48 #> right factor c(z): #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]        1     0    -0.95 -0.03 #> [2,]        0     1    -0.67  0.14 #> [1] 1.03291 6.32357 #> [1] 1.715204 1.715204"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_stsp.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Test Rational Matrix in Statespace Form — test_stsp","title":"Create Test Rational Matrix in Statespace Form — test_stsp","text":"simple tool may used create random, \\((m,n)\\)-dimensional, rational matrix statespace form statespace dimension \\(s\\).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_stsp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Test Rational Matrix in Statespace Form — test_stsp","text":"","code":"test_stsp(   dim = c(1, 1),   s = NULL,   nu = NULL,   D = NULL,   digits = NULL,   bpoles = NULL,   bzeroes = NULL,   n.trials = 100 )"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_stsp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Test Rational Matrix in Statespace Form — test_stsp","text":"dim integer vector c(m,n). s state dimension (NULL). nu vector Kronecker indices (NULL). Either statespace dimension s  Kronecker indices nu must non NULL. parameters given,  parameter s ignored. D \\((m,n)\\) dimensional matrix (NULL). See details . digits integer, non NULL randomly generated numbers rounded  \"digits\" number decimal places. bpoles lower bound moduli poles rational matrix (NULL). bzeroes lower bound moduli zeroes rational matrix (NULL).  parameter ignored non-square matrices (m != n). n.trials maximum number trials.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_stsp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Test Rational Matrix in Statespace Form — test_stsp","text":"stsp object, represents generated rational matrix  \\(x(z)\\) statespace form.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_stsp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create Test Rational Matrix in Statespace Form — test_stsp","text":"Kronecker indices (parameter nu)  given, statespace model echelon canonical form generated. means  entries \\(,B,C\\) matrices fixed one zero  others considerd \"free\". See also Kronecker-Indices.  entries \\(, B, C\\) matrices, priori fixed  randomly generated. state dimension \\(s\\) (parameter s)  given, entries \\(, B, C\\) matrices  considered \"free\". \\(D\\) matrix defaults \\((m,n)\\)-dimensional diagonal matrix  ones diagonal (diag(x=1, nrow = m, ncol = n)). However, one may  also pass arbitray (compatible) \\(D\\) matrix procedure.  matrix may contain NA's, replaced random numbers. user may prescribe lower bounds moduli poles zeroes  rational matrix. case procedure simply generates (n.trials)  random matrices matrix found satisfies constraints. standard deviation  normal distribution, used generate random entries, decreased step.  course crude method may fail need large number randomly  generated matrices. Note also, generated model may non-minimal.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/test_stsp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Test Rational Matrix in Statespace Form — test_stsp","text":"","code":"## random (2 x 2) statespace realization with state dimension s = 3 ## no poles and zeroes within the unit circle x = test_stsp(dim = c(2,2), s = 3, digits = 2, bpoles = 1, bzeroes = 1) x #> statespace realization [2,2] with s = 3 states #>       s[1]  s[2]  s[3]  u[1]  u[2] #> s[1] -0.28  0.08  0.45 -1.09 -0.48 #> s[2]  0.11 -0.05  0.19 -0.17 -0.20 #> s[3]  0.95 -0.29  0.20  0.79  0.74 #> x[1] -0.45 -0.45 -0.54  1.00  0.00 #> x[2] -0.06 -0.01 -0.33  0.00  1.00 min(abs(poles(x))) > 1 #> [1] TRUE min(abs(zeroes(x))) > 1 #> [1] TRUE pseries2nu(pseries(x, lag.max = 5)) # Kronecker indices #> [1] 2 1  ## random (3 x 2) statespace realization in echelon canonical form ## D is lower triangular (with ones on the diagonal) ## no poles within the unit circle x = test_stsp(dim = c(3, 2), nu = c(2,3,0), D = matrix(c(1,NA,NA,0,1,NA), nrow = 3, ncol = 2),                digits = 2, bpoles = 1)  x #> statespace realization [3,2] with s = 5 states #>       s[1]  s[2] s[3]  s[4]  s[5]  u[1]  u[2] #> s[1]  0.00  0.00 1.00  0.00  0.00  0.27 -0.02 #> s[2]  0.00  0.00 0.00  1.00  0.00  0.75 -1.51 #> s[3]  0.18 -0.67 0.14 -0.05  0.00 -1.41 -0.87 #> s[4]  0.00  0.00 0.00  0.00  1.00  0.66 -0.06 #> s[5] -0.02 -0.11 1.05  0.22 -0.35 -0.37  0.80 #> x[1]  1.00  0.00 0.00  0.00  0.00  1.00  0.00 #> x[2]  0.00  1.00 0.00  0.00  0.00  0.71  1.00 #> x[3] -1.26 -0.42 0.00  0.00  0.00  0.39 -0.53 min(abs(poles(x))) > 1 #> [1] TRUE pseries2nu(pseries(x, lag.max = 10)) # check Kronecker indices #> [1] 2 3 0"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/transpose.html","id":null,"dir":"Reference","previous_headings":"","what":"Rational Matrix Transpose — transpose","title":"Rational Matrix Transpose — transpose","text":"Compute transpose rational matrix \\(x(z)\\).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/transpose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rational Matrix Transpose — transpose","text":"","code":"# S3 method for polm t(x)  # S3 method for lpolm t(x)  # S3 method for lmfd t(x)  # S3 method for rmfd t(x)  # S3 method for stsp t(x)  # S3 method for pseries t(x)  # S3 method for zvalues t(x)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/transpose.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rational Matrix Transpose — transpose","text":"x rational matrix object, .e. polm, lpolm,  lmfd, rmfd, stsp,  pseries zvalues object.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/transpose.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rational Matrix Transpose — transpose","text":"rational matrix object,    represents transposed rational matrix \\(x'(z)\\).     output class input x unless  x lmfd rmfd object:     transposition     lmfd object rmfd object, vice versa.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/transpose.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rational Matrix Transpose — transpose","text":"","code":"x = test_polm(dim = c(2,3), degree = 3, random = TRUE) all.equal(pseries(t(x)), t(pseries(x))) #> [1] TRUE  x = test_stsp(dim = c(3,2), s = 1) all.equal(zvalues(t(x)), t(zvalues(x))) #> [1] TRUE  # the transpose of an LMFD object is RMFD (x = test_lmfd(dim = c(3,2), degrees = c(1,1))) #> ( 3 x 2 ) left matrix fraction description a^(-1)(z) b(z) with degrees (p = 1, q = 1) #> left factor a(z): #>      z^0 [,1]  [,2]  [,3]  z^1 [,1]       [,2]       [,3] #> [1,]        1     0     0 1.3249976  1.7078150 -1.1669165 #> [2,]        0     1     0 1.5178235 -2.3328057 -0.1161027 #> [3,]        0     0     1 0.7004871 -0.9891472 -0.8800032 #> right factor b(z): #>       z^0 [,1]       [,2]   z^1 [,1]        [,2] #> [1,] -1.081509 -0.7079270 -0.5170237  0.18757343 #> [2,]  1.096239  0.8248984  0.2090721 -0.14121976 #> [3,]  1.755518  0.8607571 -0.1762874 -0.00452162 t(x) #> ( 2 x 3 ) right matrix fraction description d(z) c^(-1)(z) with degrees deg(c(z)) = p = 1, deg(d(z)) = q = 1 #> left factor d(z): #>       z^0 [,1]      [,2]      [,3]   z^1 [,1]       [,2]        [,3] #> [1,] -1.081509 1.0962393 1.7555177 -0.5170237  0.2090721 -0.17628739 #> [2,] -0.707927 0.8248984 0.8607571  0.1875734 -0.1412198 -0.00452162 #> right factor c(z): #>      z^0 [,1]  [,2]  [,3]  z^1 [,1]       [,2]       [,3] #> [1,]        1     0     0  1.324998  1.5178235  0.7004871 #> [2,]        0     1     0  1.707815 -2.3328057 -0.9891472 #> [3,]        0     0     1 -1.166916 -0.1161027 -0.8800032 all.equal(x, t(t(x))) #> [1] TRUE"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/upgrade_objects.html","id":null,"dir":"Reference","previous_headings":"","what":"Upgrade Objects to Common Class — upgrade_objects","title":"Upgrade Objects to Common Class — upgrade_objects","text":"Used cbind,  rbind,  ratm_mult,  Ops.ratm  make operations different subclasses (super-) class ratm possible.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/upgrade_objects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Upgrade Objects to Common Class — upgrade_objects","text":"","code":"upgrade_objects(force = TRUE, ...)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/upgrade_objects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Upgrade Objects to Common Class — upgrade_objects","text":"force Default set TRUE.  FALSE, objects also coerced one object supplied. Option FALSE used bind methods ... Arbitrary number objects superclass ratm","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/upgrade_objects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Upgrade Objects to Common Class — upgrade_objects","text":"Upgraded inputs","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/upgrade_objects.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Upgrade Objects to Common Class — upgrade_objects","text":"Constant matrices always upgraded polm, lmfd rmfd always upgraded stsp two ratm objects involved. Therefore, operations performed state space setting. Depending highest \"grade\" object involved operation, lower ranked object upgraded highest one.  following ranks assigned ratm objects: 1: polm 2: lpolm 3: lmfd 4: rmfd 5: stsp 6: pseries 7: zvalues Laurent polynomials lpolm special place detached /unconnected elements lmfd, rmfd, stsp, pseries, zvalues. Operations lpolm possible polm objects (can coerced polm). Operations defined pseries zvalues: pseries coerced (easily) zvalues object Anything involving lpolm except polm objects","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/upgrade_objects.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Upgrade Objects to Common Class — upgrade_objects","text":"","code":"p = test_polm(degree = 2) lp = test_lpolm(degree_max = 1, degree_min = -1) l = test_lmfd() r = test_lmfd() ss = test_stsp(s = 1) ps = pseries(ss) zv = zvalues(ss)  # Only one argument rationalmatrices:::upgrade_objects(force = TRUE, l) #> [[1]] #> statespace realization [1,1] with s = 1 states #>          s[1]      u[1] #> s[1] -1.08899  1.354742 #> x[1]  1.00000 -1.026447 #>  rationalmatrices:::upgrade_objects(force = FALSE, l) #> [[1]] #> ( 1 x 1 ) left matrix fraction description a^(-1)(z) b(z) with degrees (p = 1, q = 1) #> left factor a(z): #>      z^0 [,1] z^1 [,1] #> [1,]        1  1.08899 #> right factor b(z): #>       z^0 [,1]  z^1 [,1] #> [1,] -1.026447 0.2369519 #>   # Upgrade poly to rmfd rationalmatrices:::upgrade_objects(force = TRUE, p, r) #> [[1]] #> statespace realization [1,1] with s = 2 states #>      s[1] s[2] u[1] #> s[1]    0    0    1 #> s[2]    1    0    0 #> x[1]  111  112  110 #>  #> [[2]] #> statespace realization [1,1] with s = 1 states #>            s[1]       u[1] #> s[1] -0.3768608  0.4549682 #> x[1]  1.0000000 -0.6594440 #>  rationalmatrices:::upgrade_objects(force = TRUE, l, ps) #> [[1]] #> ( 1 x 1 ) impulse response with maximum lag = 5  #>      lag=0 [,1] lag=1 [,1] lag=2 [,1] lag=3 [,1] lag=4 [,1] lag=5 [,1] #> [1,]  -1.026447   1.354742  -1.475301   1.606588  -1.749558   1.905251 #>  #> [[2]] #> ( 1 x 1 ) impulse response with maximum lag = 5  #>      lag=0 [,1] lag=1 [,1] lag=2 [,1] lag=3 [,1] lag=4 [,1] lag=5 [,1] #> [1,]          1 -0.5873021 -0.4396098 -0.3290586 -0.2463083 -0.1843677 #>"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/whf.html","id":null,"dir":"Reference","previous_headings":"","what":"Wiener-Hopf Factorization — whf","title":"Wiener-Hopf Factorization — whf","text":"(Right-) Wiener-Hopf factorization (R-WHF) (square \\((m,m)\\)-dimensional, non singular) polynomial matrix \\((z)\\) factorization form  $$(z) = A_f(z) A_0(z) A_b(z) = A_r(z) A_b(z),$$ \\(A_b(z)\\) polynomial matrix zeros outside unit circle. \\(A_r(z)\\) column reduced polynomial matrix column degrees                             \\(\\kappa_i\\) zeroes inside unit circle. \\(A_0(z)\\) diagonal matrix diagonal entries                     \\(z^{\\kappa_i}\\) \\(\\kappa_i \\geq \\kappa_{+1}\\) \\(A_f(z)\\) polynomial \\(z^{-1}\\).                     Note \\(A_f(z) = Ar(z) A_0^{-1}(z)\\). factors \\(A_f(z), A_0(z), A_b(z)\\) called  forward, null backward components \\((z)\\) integers  \\((\\kappa_1,\\ldots,\\kappa_n)\\)  partial indices \\((z)\\).  Similarly, Left-WHF defined $$(z) = A_b(z) A_0(z) A_g(z) = A_b(z) A_r(z),$$ \\(A_r(z)\\) now row-reduced.  Note zeroes unit circle allowed.  case procedure whf() throws error.  Wiener-Hopf factorization plays important role analysis linear,  rational expectation models. See e.g. (Al-Sadoon 2017) .","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/whf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wiener-Hopf Factorization — whf","text":"","code":"whf(a, right_whf = TRUE, tol = sqrt(.Machine$double.eps), debug = FALSE)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/whf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wiener-Hopf Factorization — whf","text":"polm object, represents polynomial matrix \\((z)\\). right_whf Boolean. Default set TRUE.  FALSE, left WHF $$(z) = A_b(z) A_0(z) A_f(z) = A_b(z) A_r(z),$$ matrix \\(A_r(z)\\) row-reduced. tol Tolerance parameter, used \"pruning\" polynomial matrix (step).  See prune. debug Logical, default set FALSE.  TRUE, diagnostic messages printed.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/whf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wiener-Hopf Factorization — whf","text":"List components  af: lpolm object. Forward component \\(A_f\\), Laurent polynomial whose coefficients pertaining positive powers zero. ab: polm object. Backward component \\(A_b\\) a0: polm object. Diagonal matrix monomials degrees equal partial indices \\(A_0\\) ar: polm object) column reduced polynomial \\(A_r\\) idx:  vector integers. partial indices \\((\\kappa_1,\\ldots,\\kappa_n)\\)","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/whf.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Wiener-Hopf Factorization — whf","text":"algorithm based Smith normal form (SNF), snf, column reduction step, see col_reduce. alternative described (Gohberg et al. 2003)  pages 7ff.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/whf.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Wiener-Hopf Factorization — whf","text":"Al-Sadoon MM (2017). “Linear Systems Approach Linear Rational Expectations Models.” Econometric Theory, 1-31. doi:10.1017/S0266466617000160 .  (Gohberg et al. 2003)","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/whf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wiener-Hopf Factorization — whf","text":"","code":"set.seed(1234)   # create test polynomial a = test_polm(dim = c(3,3), deg = 2, digits = 2, random = TRUE)  # compute WHF and print the result out = whf(a) print(out$af, digits = 2, format = 'c') #> ( 3 x 3 ) Laurent polynomial matrix with degree <= 0, and minimal degree >= -1 #>                   [,1]             [,2]              [,3] #> [1,]                 0        -2.44z^-1              3.81 #> [2,]  -1.69z^-1 - 2.51  1.97z^-1 + 1.97     -0.42z^-1 - 1 #> [3,]  -0.59z^-1 - 5.78  1.22z^-1 + 5.56  -0.34z^-1 - 1.98  print(out$a0, digits = 2, format = 'c') #> ( 3 x 3 ) matrix polynomial with degree <= 1  #>       [,1]  [,2]  [,3] #> [1,]     z     0     0 #> [2,]     0     z     0 #> [3,]     0     0     z  print(out$ab, digits = 2, format = 'c') #> ( 3 x 3 ) matrix polynomial with degree <= 1  #>                [,1]          [,2]          [,3] #> [1,]    1.3 - 5.01z  0.68 + 1.39z  -0.01 + 3.7z #> [2,]   0.49 - 5.26z  0.96 + 1.48z  0.23 + 3.88z #> [3,]  -3.61 - 0.22z  0.75 - 0.13z  2.46 - 0.18z   # check the result all.equal(a, prune(out$ar %r% out$ab))           # A = Ar * Ab #> [1] TRUE  # check A(z) = Ab(z^{-1}) A0(z) Ab(z) # generate random complex z's z = complex(real = rnorm(10), imaginary = rnorm(10)) a_z  = zvalues(a, z)         # A(z) ab_z = zvalues(out$ab, z)    # Ab(z) a0_z = zvalues(out$a0, z)    # A0(z) af_z = zvalues(out$af, 1/z)  # Af(z^{-1})   attr(af_z, 'z') = z           # in order to combine the 'zvalues' objects,                                # the attribute 'z' must be identical all.equal(a_z, af_z %r% a0_z %r% ab_z) #> [1] \"Mean relative Mod difference: 7.613902\"  all.equal(out$idx, degree(out$ar, 'columns'))    # idx = column degrees of Ar #> [1] TRUE all(svd(col_end_matrix(out$ar))$d > 1e-7)     # Ar is column reduced #> [1] TRUE abs(zeroes(out$ar, print_message = FALSE))       # Ar has zeroes inside the unit circle #> [1] 0.3582517 0.4852823 0.4852823 abs(zeroes(out$ab, print_message = FALSE))       # Ab zeroes outside the unit circle #> [1] 1.934098 1.934098 9.472821  set.seed(NULL)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/zoom_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Zoom and Scroll — zoom_plot","title":"Zoom and Scroll — zoom_plot","text":"utility zoom_plot creates runs \"shiny app\" displays two plots: Drawing (dragging) \"brush\" \"control\" plot bottom zooms zooms selected x-range plot top.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/zoom_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Zoom and Scroll — zoom_plot","text":"","code":"zoom_plot(p, p0 = p, title = NULL, ...)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/zoom_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Zoom and Scroll — zoom_plot","text":"p, p0 two function (\"closure\") objects produce R plot calling p(), p(xlim) p0() respectively. plots use range \"x-values\". title (character) optimal title \"shiny app window\" ... used.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/zoom_plot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Zoom and Scroll — zoom_plot","text":"function normally return; interrupt R stop application (usually pressing Ctrl+C Esc).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/zoom_plot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Zoom and Scroll — zoom_plot","text":"utility based shiny package.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/zoom_plot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Zoom and Scroll — zoom_plot","text":"","code":"if (FALSE) { make_plot_fun = function(x, y, type, col) {    fun = function(xlim = NULL) {    plot(x, y, xlim= xlim, type = type, col = col)    }    return(fun) }  p = make_plot_fun(1:10, rnorm(10), type = 'p', col = 'red') p0 = make_plot_fun(1:10, sin(1:10), type = 'l', col = 'black') zoom_plot(p, p0, title = 'test \"zoom_plot\"') }"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/zvalue.html","id":null,"dir":"Reference","previous_headings":"","what":"Frequency Response Function — zvalue","title":"Frequency Response Function — zvalue","text":"function evaluates rational matrix one given (complex) arguments.  non-plural version zvalues.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/zvalue.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Frequency Response Function — zvalue","text":"","code":"zvalue(obj, z, ...)  # S3 method for lpolm zvalue(obj, z = NULL, ...)  # S3 method for polm zvalue(obj, z = NULL, ...)  # S3 method for lmfd zvalue(obj, z = NULL, ...)  # S3 method for rmfd zvalue(obj, z = NULL, ...)  # S3 method for stsp zvalue(obj, z = NULL, ...)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/zvalue.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Frequency Response Function — zvalue","text":"obj (rational) matrix object, .e. polm, lpolm, lmfd, rmfd, stsp object  object may coerced polynomial matrix polm(obj). default S3 method first coerces input argument obj polm object.  fails error thrown. z (numeric complex) vector length one evaluate rational matrix. ... optional additional parameters","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/zvalue.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Frequency Response Function — zvalue","text":"Matrix dimensions input object","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/zvalues.html","id":null,"dir":"Reference","previous_headings":"","what":"Frequency Response Function — zvalues","title":"Frequency Response Function — zvalues","text":"function evaluates rational matrix given (complex) arguments.  rational matrix corresponds linear, dynamic filter,  rational function also called transfer function filter  values function complex unit circle called  frequency response filter.","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/zvalues.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Frequency Response Function — zvalues","text":"","code":"zvalues(obj, z, f, n.f, sort.frequencies, ...)  # S3 method for default zvalues(obj, z = NULL, f = NULL, n.f = NULL, sort.frequencies = FALSE, ...)  # S3 method for polm zvalues(obj, z = NULL, f = NULL, n.f = 5, sort.frequencies = FALSE, ...)  # S3 method for lpolm zvalues(obj, z = NULL, f = NULL, n.f = 5, sort.frequencies = FALSE, ...)  # S3 method for lmfd zvalues(obj, z = NULL, f = NULL, n.f = 5, sort.frequencies = FALSE, ...)  # S3 method for rmfd zvalues(obj, z = NULL, f = NULL, n.f = 5, sort.frequencies = FALSE, ...)  # S3 method for stsp zvalues(obj, z = NULL, f = NULL, n.f = 5, sort.frequencies = FALSE, ...)"},{"path":"https://bfunovits.github.io/rationalmatrices/reference/zvalues.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Frequency Response Function — zvalues","text":"obj (rational) matrix object, .e. polm, lpolm, lmfd, rmfd, stsp object.  object may coerced polynomial matrix polm(obj). default S3 method acts constructor zvalues objects: array object z supplied, corresponding evaluated object values z. (Numeric complex) vectors matrices coerced arrays. f supplied instead z, z considered exp(complex(imaginary = (-2*pi)*f)). z (numeric complex) vector, points evaluate rational matrix. Theses values stored attribute can accessed zvalues_obj$z. f (numeric) vector frequencies. z = NULL z set  z = exp(complex(imaginary = (-2*pi)*f)). z non NULL,  f set f = -Arg(z)/(2*pi). Theses values can accessed zvalues_obj$f. n.f (integer) number frequencies. z = f = NULL grid frequencies f = (0:(n.f-1))/n.f  used (z generated explained ). sort.frequencies boolean, sort frequencies ... optional additional parameters","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/zvalues.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Frequency Response Function — zvalues","text":"Object type zvalues","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/zvalues.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Frequency Response Function — zvalues","text":"zvalues object simply (complex valued) 3-dimensional array dimension \\((m,n,n.f)\\)  attribute z class attribute c('zvalues','ratm').  dimensions \\((m,n,n.f)\\) may also zero, n.f length z. z f can accessed zvalues_obj$z zvalues_obj$z, respectively. need value matrix evaluated one point, use  zvalue(obj, z).","code":""},{"path":"https://bfunovits.github.io/rationalmatrices/reference/zvalues.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Frequency Response Function — zvalues","text":"","code":"(vv = zvalues(1:3, z = 4:6)) #> ( 1 x 1 ) frequency response #>      z[1] [,1] z[2] [,1] z[3] [,1] #> [1,]         1         2         3 (mm = zvalues(matrix(1:4, 2, 2), z = 1)) #> ( 2 x 2 ) frequency response #>      z[1] [,1]  [,2] #> [1,]         1     3 #> [2,]         2     4 (aa = zvalues(array(1:8, dim = c(2,2,2)), f = c(0.2, 0.8))) #> ( 2 x 2 ) frequency response #>      z[1] [,1]  [,2] z[2] [,1]  [,2] #> [1,]         1     3         5     7 #> [2,]         2     4         6     8 (ll = test_lmfd(dim = c(2,2), bpoles = 1, bzeroes = 1)) #> ( 2 x 2 ) left matrix fraction description a^(-1)(z) b(z) with degrees (p = 1, q = 1) #> left factor a(z): #>      z^0 [,1]  [,2]   z^1 [,1]         [,2] #> [1,]        1     0 -0.1117179  0.008887902 #> [2,]        0     1  0.8994798 -0.714928485 #> right factor b(z): #>        z^0 [,1]       [,2]    z^1 [,1]       [,2] #> [1,] -1.3697123 -0.3045451 -0.01513686  0.4533451 #> [2,]  0.4141261  0.5098894 -0.57085123 -0.2060265 zvalues(ll) #> ( 2 x 2 ) frequency response #>         z[1] [,1]         [,2]             z[2] [,1]                  [,2] #> [1,] -1.604164+0i 0.1619624+0i -1.3973964+0.1701824i -0.2141019-0.4155124i #> [2,]  4.511807+0i 0.5548822+0i -0.0948641-0.8154555i  0.7090359-0.4541520i #>                 z[3] [,1]                  [,2]            z[4] [,1] #> [1,] -1.2398933+0.081492i -0.6259878-0.2077699i -1.2398933-0.081492i #> [2,] -0.0821171-0.143302i  0.1388910-0.2657262i -0.0821171+0.143302i #>                       [,2]             z[5] [,1]                  [,2] #> [1,] -0.6259878+0.2077699i -1.3973964-0.1701824i -0.2141019+0.4155124i #> [2,]  0.1388910+0.2657262i -0.0948641+0.8154555i  0.7090359+0.4541520i"}]
